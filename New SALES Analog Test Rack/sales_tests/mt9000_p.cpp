//Test at Agilent Penang

#pragma warning(disable:4786)

#include <cassert>

#include <cstdlib>

#include <cstring>

#include <p2c/p2c.h>

#include <stdio.h>

#include <visa.h>

#include "mt9000_p.h"

#include "../tests/mt8000c.h" //added sri, on the 5th Dec 2007 to support utility card load test

#include "digital_const_p.h"

#include "mtglobal_p.h"

#include "../../../uCC/src/future.h"

#include "../../../vmc/src/vmc.h"

#include "../../../u/src/num_p.h"

#include "../../../u/src/umath.h"

#include "../util.h"

#include "../termio_p.h"

#include "../filelist.h"

#include "../parms_p.h"

#include "../exec_p.h"

#include "../../../u/src/OSLayer.h"



//Added for Dragon Heart - Sri

/*#include <stdlib.h>*/



#include "../../../vth/src/vth_aim.h"

#include "../../../vth/src/vth_mac.h"

#include "../../../vth/src/aimasm.h"

#include "../../../vth/src/midasm.h"

#include "../../../vth/src/vth_utility.h"

#include "../../../vth/src/utilityasm.h"



/* inlcude mod when linking is fixed and remove relays definition*/

//#include "../../../mod/src/utilityvth.h"

#include "../execsup_p.h"

//sri//





bool new_generator = true;    // use false, if the old pulse generator is in the system

                              // use true, if using the new pulse generator



bool debug_9143 = false;   //debug statements for test 9143?



static void close_mac_mk2202(int mod_id)

{

  vth_mclose_rly(mod_id, MK2202);

}



/* static variables for t9000: */

struct LOC_t9000

{

  test_result_type result;

};

//------------------------------------------------------------------------------

static char *vth_read_string_result(char * result, int mod_id, struct LOC_t9000 * LINK)

{

  char s[MAX_S_LENGTH + 1];

  char *s_ptr;



  if (get_result_nolog(mod_id, &LINK->result))

  {

    s_ptr = static_cast(char*, LINK->result.UU.Pstring_ptr);

    strcpy(s, s_ptr);

    return strcpy(result, s);

  }

  else

  {

    display_prompt("No result in result log - Expected string value.", true);

    return strcpy(result, "");

  }

}  /*read_string_result*/



//------------------------------------------------------------------------------

void t9000(void)
{
	/*Verify rack settings & connections*/
	struct LOC_t9000 V;

	int    mod_id;

	int    analog_rack_exists = 9;

	int  * debug_int_ptr;

	double ps_sense_voltage;

	char   id_string[MAX_S_LENGTH + 1];

	char   str1[256];

	char   rack_serial_number[81];

	char   buffer[81];

	char *start_date_ptr;

	time_t now;

	FILE * infile;

	start_date_ptr = start_date;

	now = time(NULL); //record current date and time

	strcpy(start_date_ptr, ctime(&now));  //copy date and time for later

										  //use by t9999

	 // only start the time if 9000 is run at beginning of sales, not during exception cleanup

	if (reset9000 == 0)
	{
		start_time = time(NULL);  //record current time in seconds
	}

	infile = NULL;

	debug_int_ptr = &dbg_int;

	sprintf(buffer, "%sdebug_sales", testwhere_path);

	infile = fopen(buffer, "r");

	if (infile == NULL)
	{

		display_prompt("The file 'debug_sales' was not found.  Please create.", true);

		dbg_int = 0;

	}

	else
	{
		fscanf(infile, "%d%*[^\n]", debug_int_ptr);
	}

	if (infile != NULL)
	{
		fclose(infile);
	}

	infile = NULL;

	sprintf(buffer, "%sVerAndRelDate", testwhere_path);

	infile = fopen(buffer, "r");



	display_prompt("**************************************************", true);

	display_prompt("**************************************************", true);

	display_prompt("***                                            ***", true);

	display_prompt("***           --   06.xx Sales Test --         ***", true);

	display_prompt("***           --       For PC       --         ***", true);

	display_prompt("***                                            ***", true);

	display_prompt("**************************************************", true);

	display_prompt("**************************************************", true);

	if (infile != NULL)
	{
		fclose(infile);
	}

	mod_id = any_module_present();
	OpenResourceManager();





	/************************************************************/
	/* MUX - read mux serial number */

	display_prompt("Verifying MUX ...", true);

	//open_mux(mod_id);//chun comment out to test 34980A
	open_34980A(mod_id);//chun15112021


	if (get_34980A_IDN() == true)
	{
		//open_34980A(mod_id);//chun15112021
		verify_34980A(mod_id);//chun15112021

		close_34980A(mod_id);
	}
	else if(get_34980A_IDN() == false)
	{
		open_mux(mod_id);//chun comment out to test 34980A
		get_sales_rack_serial_number(rack_serial_number, mod_id);//chun comment out to test 34980A
		display_prompt(rack_serial_number, true);//chun comment out to test 34980A
	}

	if (!strcmp(rack_serial_number, "ANALOGTEST"))
	{
		analog_rack_exists = 7;
	}

	get_mux_serial_number(mod_id);

	vth_read_string_result(id_string, mod_id, &V);

	if (get_34980A_IDN() == false)
	{
		display_prompt("HP3235 mux okay\n", true);
		close_mux(mod_id);
	}
	//else if (get_34980A_IDN() == true)
	//{
	//	display_prompt("34980A switchbox okay", true);
	//}
	//close_34980A(mod_id);//close_mux(mod_id);

	flush_commands(mod_id);





	/************************************************************/
	  /* SYNTHESIZER - read & verify ID string */
	display_prompt("Verifying FUNCTION GENERATOR ...", true);

	//open_syn(mod_id); remarked chuanho, 15jun2012

	/* Old code for 3325B

	vth_mhpib_wr(mod_id, 2, "*IDN?");

	vth_mhpib_rd(mod_id, 2);

	vth_read_string_result(id_string, mod_id, &V);

	sprintf(str1, "%.21s", id_string);
	*/

	/* SYNTHESIZER - check either one of the synthesizer ID and prompt back to pass - modified by Yeoh Shiau Whei, 21-May-08*/
	/* Old code for 3325B

	 if (!strcmp(str1, "HEWLETT-PACKARD,3325B")) //Old Function Generator's ID checking

	   display_prompt("   synthesizer okay", true);

	 else if (!strcmp(str1, "Agilent Technologies,33250A")) //New Function Generator's ID checking

	   display_prompt("   synthesizer okay", true);

	 else

	 {

	   display_prompt("   SYNTHESIZER ERROR !!!!!", true);

	   display_prompt(id_string, true);

	 }
	 */

	 /*New codes for synthesizer*/
	 //added by chuanho, 6Jul2011
	open_33250A(mod_id);

	verify_syn(mod_id);

	if (check_syn_model())//check if function generator is Agilent model
	{
		close_33250A(mod_id);
	}
	else //check if function generator is HP model
	{
		close_syn(mod_id);
	}
	flush_commands(mod_id);
	/*End of new codes for synthesizer*/





  /************************************************************/
	/*if (get_34980A_IDN() == false)
	{*/
		/* Olympus N6700B*/
		display_prompt("Verifying N6734B/N6776A...", true);
		open_olym(mod_id);      //N6734B/N6776A
		verify_olym(mod_id);
		close_olym(mod_id);
		flush_commands(mod_id);
		/*End of Olympus N6700B*/
	/*}
	else if (get_34980A_IDN() == true)
	{*/
		/* Olympus N6700C*/
		//display_prompt("Verifying N6734B/N6776A...", true);
		//open_olym(mod_id);       //N6734B/N6776A
		//verify_olym(mod_id);
		//close_olym(mod_id);
		//flush_commands(mod_id);
		/*End of Olympus N6700B*/
	//}





	if (analog_rack_exists != 7)
	{
		/************************************************************/
		  /*PULSE GENERATOR */
		display_prompt("Verifying Pulse Generator ...", true);//pulse generator
		open_gen(mod_id);

		//new confirmation code for new generator

			if (new_generator)
			{
				vth_mhpib_wr(mod_id, 3, ":SYST:ERR?");

				vth_mhpib_rd(mod_id, 3);

				vth_read_string_result(id_string, mod_id, &V);

				sprintf(str1, "%.2s", id_string);

				if (!strcmp(str1, "+0"))
				{
					display_prompt(str1, true);
					display_prompt("pulse generator okay\n", true);
				}
				else
				{
					display_prompt("PULSE GENERATOR ERROR !!!!!\n", true);

					display_prompt(id_string, true);
				}
			}

			else //old confirmation code for old (8112) generator -- mjs 4/9/97
			{
				vth_mhpib_wr(mod_id, 3, "EST");

				vth_mhpib_rd(mod_id, 3);

				vth_read_string_result(id_string, mod_id, &V);

				sprintf(str1, "%.11s", id_string);

				if (!strcmp(str1, " NO MESSAGE"))
				{
					display_prompt(str1, true);
					display_prompt("   generator okay\n", true);
				}
				else
				{
					display_prompt("   GENERATOR ERROR !!!!!\n", true);

					display_prompt(id_string, true);
				}
			}  //end of old generator block

			close_gen(mod_id);
			flush_commands(mod_id);

	} //if analog_rack_exists...





	/************************************************************/
	/* COUNTER - check if measurement pending */

	display_prompt("Presetting and verifying COUNTER ...", true);

		open_cntr(mod_id);

		vth_mhpib_wr(mod_id, 4, ":INP1:COUP DC");    // input coupling = DC

		vth_mhpib_wr(mod_id, 4, ":INP2:COUP DC");    // input coupling = DC

		vth_mhpib_wr(mod_id, 4, ":INP1:IMP 50");     // input impedance 50 ohms

		vth_mhpib_wr(mod_id, 4, ":INP2:IMP 50");     // input impedance 50 ohms

		setup_cntr_function(mod_id, TIME_INTERVAL);  // to match old 5370 cntr

		setup_cntr_trg_levels(mod_id, 1.3, 1.3);

		setup_cntr_gate_time(mod_id, 0.0);

		vth_mhpib_wr(mod_id, 4, "*SAV 1");           // save preset 1

		vth_mhpib_wr(mod_id, 4, "*IDN?");

		vth_mhpib_rd(mod_id, 4);

		vth_read_string_result(id_string, mod_id, &V);

		sprintf(str1, "%.22s", id_string);


//	if (get_34980A_IDN() == false)
//	{
//		if (!strcmp(str1, "HEWLETT-PACKARD,53132A"))

//    display_prompt("   counter okay", true);

//  else

//  {

 //   display_prompt("   COUNTER ERROR !!!!!", true);

//    display_prompt(id_string, true);

//		}
//	}
//	else if (get_34980A_IDN() == true)
//	{
//		if (!strcmp(str1, "Agilent Technologies,53230A"))//Agilent Technologies,53230A,MY61400282,03.02-1924.2831-3.15-4.16-127-159-35

//			display_prompt("53230A counter okay", true);

	    if (!strcmp(str1, "HEWLETT-PACKARD,53132A"))
		{
			display_prompt(str1, true);
			display_prompt("53132A counter okay\n", true);
		}
		else
		{
			display_prompt("53132A COUNTER ERROR !!!!!\n", true);

			display_prompt(id_string, true);
		}

		close_cntr(mod_id);

		flush_commands(mod_id);
	/*}
	else if (get_53230A_IDN() == true)
	{*/
		//open_53230A(mod_id);
		//verify_53230A_counter(mod_id);
		//close_53230A(mod_id);
		//flush_commands(mod_id);
	//}





	/************************************************************/
	/* DMM - check if measurement pending */

	display_prompt("Verifying DMM ...", true);

	open_dmm(mod_id);

	/* dmm_measurement_complete result does not mean error or not */

	/* either result verifies dmm operation.  Timeout means failure. */

	if (dmm_measurement_complete())
	{
		display_prompt("   dmm okay\n", true);
	}
	else
	{
		display_prompt("   dmm has problem\n", true);
	}

	close_dmm(mod_id);

	flush_commands(mod_id);





	/************************************************************/
	/* DMM50 - check if measurement pending */
	display_prompt("Verifying DMM50 ...", true);

	open_dmm50(mod_id);

	display_prompt("   dmm50 okay\n", true);

	close_dmm50(mod_id);

	flush_commands(mod_id);





	/************************************************************/
	display_prompt("Verifying LCR ...", true);


		open_lcr(mod_id);

		vth_mhpib_wr(mod_id, 6, "*RST");

		vth_mhpib_wr(mod_id, 6, ":SYST:ERR?");

		vth_mhpib_rd(mod_id, 6);

		vth_read_string_result(id_string, mod_id, &V);

		sprintf(str1, "%.2s", id_string);


  //if (get_34980A_IDN() == false)
  //{
	//  if (!strcmp(str1, "+0"))

    //display_prompt("   lcr okay", true);

  //else

  //{

    //display_prompt("   LCR ERROR !!!!!", true);

    //display_prompt(id_string, true);

	  //}
  //}
  //else if (get_34980A_IDN() == true)
  //{
	//  if (!strcmp(str1, "+0"))

	//	  display_prompt("E4980AL LCR okay", true);

	  //else

	  //{

	//	  display_prompt("E4980AL LCR ERROR !!!!!", true);

	//	  display_prompt(id_string, true);

	 // }
 // }
		if (!strcmp(str1, "+0"))
		{
			display_prompt(id_string, true);
			display_prompt("4263B LCR okay\n", true);
		}
		else
		{
			display_prompt("4263B LCR ERROR !!!!!\n", true);

			display_prompt(id_string, true);
		}

		vth_mhpib_wr(mod_id, 6, "*RST");

		vth_mhpib_wr(mod_id, 6, ":SYST:PRES");

		close_lcr(mod_id);

		flush_commands(mod_id);

		open_E4980AL_LCR(mod_id);
		verify_E4980AL_LCR(mod_id);
		close_E4980AL_LCR(mod_id);
		flush_commands(mod_id);

  /************************************************************/
  /* PS - make sense voltage measurement */

	  display_prompt("Verifying 6634B PS ...", true);//6634B

	  open_ps(mod_id);

	  ps_sense_voltage = measure_ps_sense_voltage(mod_id);

	  display_prompt("6634B ps okay\n", true);

	  close_ps(mod_id);

	  flush_commands(mod_id);







	  display_prompt("Verifying N6746B PS ...", true);

	  open_PS_N6746B(mod_id);

	  verify_PS_N6746B(mod_id);

	  ps_sense_voltage = measure_PS_N6746B_sense_voltage(mod_id);

	  //display_prompt(" N6746B PS okay", true);

	  close_PS_N6746B(mod_id);

	  flush_commands(mod_id);



  /************************************************************/
  /* Load PS - make sense voltage measurement */
  //power supply for utility card

/* fikri06022023
	  display_prompt("Verifying 6038A Load PS ...", true);

	  open_ps_load(mod_id);

	  ps_sense_voltage = measure_ps_sense_voltage_load(mod_id);

	  display_prompt("6038A Load PS okay\n", true);

	  close_ps_load(mod_id);

	  flush_commands(mod_id);

	  display_prompt("Verifying N6754A Load PS ...", true);

	  //open_ps_load(mod_id);
	  open_PS_N6754A_load(mod_id);

	  verify_PS_N6754A_load(mod_id);

	  //ps_sense_voltage = measure_ps_sense_voltage_load(mod_id);
	  ps_sense_voltage = measure_PS_N6754A_sense_voltage_load(mod_id);

	  if(verify_PS_N6754A_load(mod_id) == true)
	  {
	  display_prompt("N6754A ps okay\n", true);
	  }
	  else
	  {
	  display_prompt("N6754A ps not connected\n", true);
	  }

	  //close_ps_load(mod_id);
	  close_PS_N6754A_load(mod_id);
*/  // fikri06022023
	  flush_commands(mod_id);

  /************************************************************/
  CloseResourceManager();

}  /* t9000 */



#define BLANK_LINE      ""

#define GEN_MODE        NORM

#define GEN_EXT_SLOPE   POS

#define AVERAGING       true

#define COUNT           5

#define SLEW_RATE       225/*v/uS*/

#define GEN_LOW         0.2e+00

#define GEN_HIGH        3.5e+00

#define GEN_PERIOD      1e-06

//------------------------------------------------------------------------------

void t9001(int mod_id, int)

{

  /*Measure AF2 delay*/

  int this_module;

  int current_position;

  int next_position;



  double transition_time;

  double sales_rack_delay_pos;

  double sales_rack_delay_neg;

  double total_delay_pos;

  double total_delay_neg;

  double neg_delay;

  double pos_delay;



  FILE *infile;

  FILE *outfile;



  char s[81];

  char buffer[81];

  test_result_type result;



  outfile = NULL;

  infile = NULL;

  OpenResourceManager();
  //open_mux(mod_id);
  open_34980A(mod_id);
  open_gen(mod_id);
  open_33250A(mod_id);

  /*Added by chuanho to select synthesizer model*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	  enable_33250A_out(mod_id);
	  setup_33250A_defaults(mod_id);
  }
  else
      open_syn(mod_id);
  /*--------------------------------------------*/

  open_osc(mod_id);
  break_test_for_function_step_compatability(mod_id);

  infile = fopen("AF2_delays", "r");

  if (infile == NULL)
  {
    display_prompt("The 'AF2_delays' file was not found.  Please have sys admin replace.", true);
    _EscIO(FileNotFound);
  }

  for (this_module = 0; this_module <= 3; this_module++)
  {
    fscanf(infile, "%lg%*[^\n]", &af2_system_delay[this_module]);
    getc(infile);
  }

  if (infile != NULL)
    fclose(infile);

  infile = NULL;

  transition_time = (GEN_HIGH - GEN_LOW) * 0.8 * 1e-06 / SLEW_RATE;

  setup_gen_mode(mod_id, GEN_MODE, GEN_EXT_SLOPE);
  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH);
  setup_gen_period(mod_id, GEN_PERIOD);
  setup_gen_transition_times(mod_id, transition_time);

  break_test_for_function_step_compatability(mod_id);

  setup_osc_channel(mod_id, 1, 50, 4.0, 1.75);
  setup_osc_channel(mod_id, 2, 50, 4.0, 1.75);
  setup_osc_trigger(mod_id, 2, POS, 1.5, AVERAGING);
  setup_osc_timebase(mod_id, AVERAGING, COUNT, 150e-09, 65e-09, AUTOMATIC);

  connect_gen_trg_osc_ch2(mod_id);
  connect_gen_out_af2(mod_id);
  connect_osc_ch1_cable_measure(mod_id);

  break_test_for_function_step_compatability(mod_id);

  enable_gen_out(mod_id);

  if (get_result_nolog(mod_id, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/

    display_prompt("\007", true);   /* '#7' should cause a beep */

    display_prompt(BLANK_LINE, true);

    display_prompt("Connect the Sales Measurement Cable directly to", true);

    *s = '\0';

    strcat(s, "the Module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, " AF2 port on Minerva.");

    display_prompt(s, true);

    display_prompt("Then press <Return> or <Enter>.", true);

    display_prompt(BLANK_LINE, false);

    get_user_answer(buffer, 80);

  }  /*else*/



  break_test_for_function_step_compatability(mod_id);

  trigger_osc(mod_id, 1, AVERAGING);

  trigger_osc(mod_id, 2, AVERAGING);

  setup_osc_ti_markers(mod_id, POS, POS);

  measure_osc(mod_id, DELTA_T, POS);



  sales_rack_delay_pos = 0.0;



  if (get_result_nolog(mod_id, &result))

    sales_rack_delay_pos = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected SCOPE reading)", true);



  complement_gen_out(mod_id);

  trigger_osc(mod_id, 1, AVERAGING);

  trigger_osc(mod_id, 2, AVERAGING);

  setup_osc_ti_markers(mod_id, POS, NEG);

  measure_osc(mod_id, DELTA_T, NEG);



  sales_rack_delay_neg = 0.0;



  if (get_result_nolog(mod_id, &result))

    sales_rack_delay_neg = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected SCOPE reading)", true);



  display_prompt("\007", true);   /* '#7' should cause a beep */

  display_prompt(BLANK_LINE, true);

  display_prompt("Connect the Sales Measurement Cable directly to the", true);

  *s = '\0';

  strcat(s, "end of the AF2 cable in Module ");

  current_position = mtd_strlen(s) + 1;

  sprintf(s + current_position - 1, "%d", mod_id);

  next_position = mtd_strlen(s) + 1;

  strcat(s, ". Re-connect the");

  display_prompt(s, true);

  display_prompt("Minerva AF2 port to the testhead cable AF2 for", true);

  *s = '\0';

  strcat(s, "Module ");

  current_position = mtd_strlen(s) + 1;

  sprintf(s + current_position - 1, "%d", mod_id);

  next_position = mtd_strlen(s) + 1;

  strcat(s, ". Then press <Return> or <Enter>.");

  display_prompt(s, true);

  display_prompt(BLANK_LINE, false);

  get_user_answer(buffer, 80);



  break_test_for_function_step_compatability(mod_id);

  no_complement_gen_out(mod_id);

  trigger_osc(mod_id, 1, AVERAGING);

  trigger_osc(mod_id, 2, AVERAGING);

  setup_osc_ti_markers(mod_id, POS, POS);

  measure_osc(mod_id, DELTA_T, POS);



  total_delay_pos = 0.0;



  if (get_result_nolog(mod_id, &result))

    total_delay_pos = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected SCOPE reading)", true);



  complement_gen_out(mod_id);

  trigger_osc(mod_id, 1, AVERAGING);

  trigger_osc(mod_id, 2, AVERAGING);

  setup_osc_ti_markers(mod_id, POS, NEG);

  measure_osc(mod_id, DELTA_T, NEG);



  total_delay_neg = 0.0;



  if (get_result_nolog(mod_id, &result))

    total_delay_neg = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected SCOPE reading)", true);



  display_prompt("\007", true);   /* '#7' should cause a beep */

  display_prompt(BLANK_LINE, true);

  display_prompt("Re-connect the testhead AF2 cable to the ASRU", true);

  *s = '\0';

  strcat(s, "card for Module ");

  current_position = mtd_strlen(s) + 1;

  sprintf(s + current_position - 1, "%d", mod_id);

  next_position = mtd_strlen(s) + 1;

  strcat(s, ". Then press <Return> or <Enter>.");

  display_prompt(s, false);

  get_user_answer(buffer, 80);



  disable_gen_out(mod_id);



  neg_delay = total_delay_neg - sales_rack_delay_neg;

  pos_delay = total_delay_pos - sales_rack_delay_pos;

  af2_system_delay[mod_id] = (pos_delay + neg_delay) / 2;

  result.UU.Real_result = af2_system_delay[mod_id];

  log_result(mod_id, result);



  outfile = fopen("AF2_delays", "w");



  if (outfile == NULL)

  {

    display_prompt("The 'AF2_delays' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (this_module = 0; this_module <= 3; this_module++)

    fprintf(outfile, "% .5E\n", af2_system_delay[this_module]);



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;



  close_34980A(mod_id);//close_mux(mod_id);

  close_gen(mod_id);

  close_osc(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  CloseResourceManager();

  if (infile != NULL)

    fclose(infile);



}

#undef BLANK_LINE

#undef GEN_MODE

#undef GEN_EXT_SLOPE

#undef AVERAGING

#undef COUNT

#undef SLEW_RATE

#undef GEN_LOW

#undef GEN_HIGH

#undef GEN_PERIOD



#define FIXTURE_ENABLED  5

#define ID_MIN          3776

#define ID_MAX          3779

#define FIXTURE_LOCK_TIME  1.0e+00

//------------------------------------------------------------------------------

void t9002(int mod_id, int)

{

  /* ANALOG - Read fixture enable and fixture ID */

  int fixture_id;



  char buffer[81];

  test_result_type result;

  int valid_cards;

  int pslot;
  int next;

  int current;
  int p2c_temp;

  //OpenResourceManager();
  open_mux(mod_id);
  //open_34980A(mod_id);//comment out on 22062022



  valid_cards = (1 << CP20) | (1 << PIN20);

  for (pslot = 2; pslot <= 11; pslot++)

  {

    if (pslot != 6)

    {  // CHECK EVERY SLOT EXCEPT THE MAC SLOT

      p2c_temp = get_testhead_actual_card(mod_id, pslot);

      if (((1 << p2c_temp) & valid_cards) != 0)

        vth_pgb_test_off(mod_id, pslot);

    }  // CHECK EVERY SLOT EXCEPT THE MAC SLOT

  }

  // added to open ground bounce relay KGB14A for t9020 & others

  // 9-1-92 Jim M. & Bengie A.



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result != FIXTURE_ENABLED)

    {

//     if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//      display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

      // FLUSH THE COMMANDS

      if (get_result_nolog(mod_id, &result))

        display_prompt("Unexpected result encountered", true);

      display_prompt("Please install the analog sales fixture.", true);

      display_prompt("Then press <Return> or <Enter>.  ", true);

      get_user_answer(buffer, 80);

    }

  }

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

//  if (get_result_log(mod_id, &result))

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result == FIXTURE_ENABLED)

    {  /*fixture found - check type*/

      fixture_id = get_fixture_id(mod_id);

//display_it(0, "Fixture ID= ", mod_id, fixture_id);

      if (fixture_id < ID_MIN || fixture_id > ID_MAX)

      {
          strcpy(buffer, "fixture id = ");

          current = mtd_strlen(buffer) + 1;

          sprintf(buffer + current - 1, "%12d", fixture_id);

          next = mtd_strlen(buffer) + 1;

          display_prompt(buffer, true);
        display_prompt("Incorrect Fixture Found", true);

        // Next routine causes the non-module failure to be set also

        add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);

      }

      result.UU.Integer_result = fixture_id;

//      log_result(mod_id, result);

    }  // fixture found - check type

    else

    {  // no fixture found

      display_prompt("No fixture found.", true);



//      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

    }  // no fixture found





  }



  check_dmm50_button(mod_id, DMM50_ANALOG_USAGE);



  //close_34980A(mod_id);
  close_mux(mod_id);
  //CloseResourceManager();
}  /*t9002*/

#undef FIXTURE_ENABLED

#undef ID_MIN

#undef ID_MAX

#undef FIXTURE_LOCK_TIME



#define FIXTURE_ENABLED  5

#define ID_MIN          3779

#define ID_MAX          3795

#define FIXTURE_LOCK_TIME  1.0e+00

//------------------------------------------------------------------------------

/*
 void t9003(int mod_id, int)

{

  // DIGITAL - Read fixture enable and fixture ID //

  int fixture_id;

  boolean correct_fixture_in_place;

  char buffer[81];

  int next;

  int current;

  test_result_type result;

  int valid_cards;

  int pslot;

  int p2c_temp;

  char str1[81];


  OpenResourceManager();
  //open_mux(mod_id);
  open_34980A(mod_id);  //fikri 22/4/2024



  valid_cards = (1 << CP20) | (1 << PIN20);

  for (pslot = 2; pslot <= 11; pslot++)

  {

    if (pslot != 6)

    {  // CHECK EVERY SLOT EXCEPT THE MAC SLOT ///

      p2c_temp = get_testhead_actual_card(mod_id, pslot);

      if (((1 << p2c_temp) & valid_cards) != 0)

        vth_pgb_test_off(mod_id, pslot);

    }  // CHECK EVERY SLOT EXCEPT THE MAC SLOT //

  }

  // added to open ground bounce relay KGB14A for t9020 & others //

  // 9-1-92 Jim M. & Bengie A.                             //



  correct_fixture_in_place = false;



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result != FIXTURE_ENABLED)

    {

      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

      // FLUSH THE COMMANDS //



      if (get_result_nolog(mod_id, &result))

        display_prompt("Unexpected result encountered", true);



      display_prompt("Please install the digital sales fixture.", true);

      display_prompt("Then press <Return> or <Enter>.  ", true);

      get_user_answer(buffer, 80);

    }

  }



  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result == FIXTURE_ENABLED)

    {

      fixture_id = get_fixture_id(mod_id);

//show_value(0, "Fixture ID= ", fixture_id);

      if (fixture_id >= ID_MIN && fixture_id <= ID_MAX)

      {

        correct_fixture_in_place = rack_and_fixture_compatible(

            get_sales_rack_serial_number(str1, mod_id), fixture_id);

        if (!correct_fixture_in_place)

        {

          strcpy(buffer, "MUX serial number = ");

          current = mtd_strlen(buffer) + 1;

          strcpy(buffer + current - 1,

                 get_sales_rack_serial_number(str1, mod_id));

          next = mtd_strlen(buffer) + 1;

          display_prompt(buffer, true);

          strcpy(buffer, "fixture id = ");

          current = mtd_strlen(buffer) + 1;

          sprintf(buffer + current - 1, "%12d", fixture_id);

          next = mtd_strlen(buffer) + 1;

          display_prompt(buffer, true);

          display_prompt("Digital Fixture Does NOT match Sales Rack.", true);

          display_prompt("Tests requiring Digital Fixture Will NOT Run", true);

          display_prompt("If MUX serial number seems wrong, reprogram ", true);

          display_prompt("with test 9007", true);

          fixture_id = 9999;   // Incompatible fixture causes failure /

          // Next routine causes the non-module failure to be set also //

          add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);

        }

     	 }

     	 else

     	 {

      	  display_prompt("Incorrect Fixture Found", true);

      	  // Next routine causes the non-module failure to be set also //

    	    add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);

   	   		}

      result.UU.Integer_result = fixture_id;

//      log_result(mod_id, result);



    }

    else

    {

      display_prompt("No fixture found.", true);



//      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

    }

  }



  check_dmm50_button(mod_id, DMM50_DIGITAL_USAGE);



  //close_mux(mod_id);
  close_34980A(mod_id); //22/4/2024
  CloseResourceManager();


}  //t9003//
*/

void t9003(int mod_id, int)

{

  /* Digital - Read fixture enable and fixture ID */

  int fixture_id;



  char buffer[81];

  test_result_type result;

  int valid_cards;

  int pslot;
  int next;

  int current;
  int p2c_temp;

  //OpenResourceManager();
  open_mux(mod_id);
  //open_34980A(mod_id);//comment out on 22062022



  valid_cards = (1 << CP20) | (1 << PIN20);

  for (pslot = 2; pslot <= 11; pslot++)

  {

    if (pslot != 6)

    {  // CHECK EVERY SLOT EXCEPT THE MAC SLOT

      p2c_temp = get_testhead_actual_card(mod_id, pslot);

      if (((1 << p2c_temp) & valid_cards) != 0)

        vth_pgb_test_off(mod_id, pslot);

    }  // CHECK EVERY SLOT EXCEPT THE MAC SLOT

  }

  // added to open ground bounce relay KGB14A for t9020 & others

  // 9-1-92 Jim M. & Bengie A.



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result != FIXTURE_ENABLED)

    {

//     if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//      display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

      // FLUSH THE COMMANDS

      if (get_result_nolog(mod_id, &result))

        display_prompt("Unexpected result encountered", true);

      display_prompt("Please install the analog sales fixture.", true);

      display_prompt("Then press <Return> or <Enter>.  ", true);

      get_user_answer(buffer, 80);

    }

  }

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

//  if (get_result_log(mod_id, &result))

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result == FIXTURE_ENABLED)

    {  /*fixture found - check type*/

      fixture_id = get_fixture_id(mod_id);

//display_it(0, "Fixture ID= ", mod_id, fixture_id);

      if (fixture_id < ID_MIN || fixture_id > ID_MAX)

      {

        display_prompt("Incorrect Fixture Found", true);

        // Next routine causes the non-module failure to be set also

        add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);

      }

      result.UU.Integer_result = fixture_id;

//      log_result(mod_id, result);

    }  // fixture found - check type

    else

    {  // no fixture found

          strcpy(buffer, "fixture id = ");

          current = mtd_strlen(buffer) + 1;

          sprintf(buffer + current - 1, "%12d", fixture_id);

          next = mtd_strlen(buffer) + 1;

          display_prompt(buffer, true);

          display_prompt("No fixture found.", true);



//      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

    }  // no fixture found


  }


  check_dmm50_button(mod_id, DMM50_ANALOG_USAGE);


  //close_34980A(mod_id);
  close_mux(mod_id);
  //CloseResourceManager();
}  /*t9003*/

#undef FIXTURE_ENABLED

#undef ID_MIN

#undef ID_MAX

#undef FIXTURE_LOCK_TIME



//------------------------------------------------------------------------------

void t9004(void)

{

  /*Autocal the dmm*/

  int mod_id;



  mod_id = any_module_present();



  //open_mux(mod_id);
  open_34980A(mod_id);

  open_dmm(mod_id);



  connect_dmm(mod_id); /*So we can int the terminals to discharge cap */

  connect_10k_load(mod_id);

  vth_mtmr_wait(mod_id, 10e-03);



  connect_lcr(mod_id);   /*This closes relays 201,202,204,and 205 in minerva*/

  vth_mtmr_wait(mod_id, 200e-03);



  autocal_dmm(mod_id);



  close_34980A(mod_id);//close_mux(mod_id);

  close_dmm(mod_id);



}  /*t9004*/



//------------------------------------------------------------------------------

void t9005(void)

{

  /*Read Delay Constants*/

  int this_module;

  int a_module;



  FILE *system_delays = NULL;

  FILE *rack_delays = NULL;

  FILE *measured_delays = NULL;



  char rack_serial_number[81];

  char filename[81];

  char buffer[81];



  int channel;

  int sschnl;

  int slot_no;



  sprintf(filename,"%sdelay_const", testwhere_path);

  sprintf(buffer,"%s", testwhere_path);

  system_delays = fopen(filename, "r");



  if (system_delays == NULL)

  {

    display_prompt("The 'delay_const' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (channel = 'A'; channel <= 'H'; channel++)

  {

    fscanf(system_delays, "%lg%*[^\n]", &channel_delay[channel - 'A']);

    getc(system_delays);

  }



  for (slot_no = 0; slot_no < NUM_SLOTS / 2; slot_no++)

  {

    for (int edge = RISING; edge <= FALLING; ++edge)

    {

      fscanf(system_delays, "%lg%*[^\n]", &slot_delay[slot_no][edge]);

      getc(system_delays);

    }

  }



  fscanf(system_delays, "%lg%*[^\n]", &rx_path_offset);

  getc(system_delays);



  if (system_delays != NULL)

    fclose(system_delays);



  system_delays = NULL;



  sprintf(filename,"%sconst_ss_slot", testwhere_path);

  system_delays = fopen(filename, "r");



  if (system_delays == NULL)

  {

    display_prompt("The 'const_ss_slot' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (slot_no = 0; slot_no < NUM_SLOTS / 2; slot_no++)

  {

    fscanf(system_delays, "%lg%*[^\n]", &ss_slot_const[slot_no]);

    getc(system_delays);

  }



  if (system_delays != NULL)

    fclose(system_delays);



  system_delays = NULL;



  sprintf(filename,"%sconst_ssd", testwhere_path);

  system_delays = fopen(filename, "r");



  if (system_delays == NULL)

  {

    display_prompt("The 'const_ssd' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (sschnl = 0; sschnl <= 23; sschnl++)

  {

    fscanf(system_delays, "%lg%*[^\n]", &ssdrvr_const[sschnl]);

    getc(system_delays);

  }



  fscanf(system_delays, "%lg%*[^\n]", &ssrecf);

  getc(system_delays);



  if (system_delays != NULL)

    fclose(system_delays);



  system_delays = NULL;



  sprintf(filename,"%sconst_ssr", testwhere_path);

  system_delays = fopen(filename, "r");



  if (system_delays == NULL)

  {

    display_prompt("The 'const_ssr' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (sschnl = 0; sschnl <= 23; sschnl++)

  {

    fscanf(system_delays, "%lg%*[^\n]", &ssrec_const[sschnl]);

    getc(system_delays);

  }



  fscanf(system_delays, "%lg%*[^\n]", &ssfdcf);

  getc(system_delays);



  if (system_delays != NULL)

    fclose(system_delays);



  system_delays = NULL;



  this_module = any_module_present();

  present_test[this_module - NO_TESTHEAD_NUMBER] = 9005;
    OpenResourceManager();

  //open_mux(this_module);
  open_34980A(this_module);

  get_sales_rack_serial_number(rack_serial_number, this_module);

  strcat(buffer, rack_serial_number);

  //display_prompt(buffer, true); //Mike 12/17/03: used to debug path/rack_serial_number probs

  if (strpos2("A", rack_serial_number, 1) > 0)

  {

    rack_delays = fopen(buffer, "r");



    if (rack_delays == NULL)

    {

      display_prompt("The sales rack serial number file was not found.  Please have sys admin replace.", true);

      _EscIO(FileNotFound);

    }



    for (a_module = 0; a_module <= 3; a_module++)

    {

      fscanf(rack_delays, "%lg%*[^\n]", &clkrb_delay[a_module]);

      getc(rack_delays);

    }



    for (a_module = 0; a_module <= 3; a_module++)

    {

      fscanf(rack_delays, "%lg%*[^\n]", &af2_start_delay[a_module]);

      getc(rack_delays);

    }



    for (a_module = 0; a_module <= 3; a_module++)

    {

      fscanf(rack_delays, "%lg%*[^\n]", &af2_clkrb_delay[a_module]);

      getc(rack_delays);

    }



    for (a_module = 0; a_module <= 3; a_module++)

    {

      fscanf(rack_delays, "%lg%*[^\n]", &probe_clkrb_delay[a_module]);

      getc(rack_delays);

    }



    if (rack_delays != NULL)

      fclose(rack_delays);



    rack_delays = NULL;

  }

  else

    display_prompt("Need to define sales rack serial number (T9007)", true);



  sprintf(filename,"%sAF2_delays", testwhere_path);

  measured_delays = fopen(filename, "r");



  if (measured_delays == NULL)

  {

    display_prompt("The 'AF2_delays' file was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  for (a_module = 0; a_module <= 3; a_module++)

  {

    fscanf(measured_delays, "%lg%*[^\n]", &af2_system_delay[a_module]);

    getc(measured_delays);

  }


 close_34980A(this_module);//close_mux(this_module);

    CloseResourceManager();


  if (measured_delays != NULL)

    fclose(measured_delays);



  measured_delays = NULL;






  if (system_delays != NULL)

    fclose(system_delays);



  system_delays = NULL;



  if (rack_delays != NULL)

    fclose(rack_delays);



  rack_delays = NULL;



}  /* t9005 */



//------------------------------------------------------------------------------

void t9006(int* /* ms_list */)

{

  int * debug_int_ptr;

  double * t9120_delay_ptr;

  double * t9120_res_ptr;

  double * t9120_af2_ptr;

  double * t9171_delay_ptr;

  double * t9171_af2_ptr;

  double * t9191_probe_ptr;

  FILE * infile = NULL;

  char buffer[81];

  debug_int_ptr = &dbg_int;

  t9120_delay_ptr = &t9120_delay;

  t9120_res_ptr = &t9120_res;

  t9120_af2_ptr = &t9120_af2;

  t9171_delay_ptr = &t9171_delay;

  t9171_af2_ptr = &t9171_af2;

  t9191_probe_ptr = &t9191_probe;



  display_prompt("Opening the debug_sales file...", true);

  sprintf(buffer, "%sdebug_sales", testwhere_path);

  infile = fopen(buffer, "r");



  if (infile == NULL)

  {

    display_prompt("The file   'debug_sales'   was not found.  Please create.", true);

    dbg_int = 0;

  }

  else

  {

    display_prompt("Scanning the debug_sales file for debug info...", true);

    fscanf(infile, "%d%*[^\n]", debug_int_ptr);

    fscanf(infile, "%lg%*[^\n]", t9120_delay_ptr);

    fscanf(infile, "%lg%*[^\n]", t9120_res_ptr);

    fscanf(infile, "%lg%*[^\n]", t9120_af2_ptr);

    fscanf(infile, "%lg%*[^\n]", t9171_delay_ptr);

    fscanf(infile, "%lg%*[^\n]", t9171_af2_ptr);

    fscanf(infile, "%lg%*[^\n]", t9191_probe_ptr);



  }



  if (infile != NULL)

    fclose(infile);

  infile = NULL;



  display_prompt("Displaying the info from the debug_sales file...", true);

  display_it(2, "debug integer = ", dbg_int, 99.99);

  display_it(2, "t9120_delay   = ", 0, t9120_delay);

  display_it(2, "t9120_res     = ", 0, t9120_res);

  display_it(2, "t9120_af2     = ", 0, t9120_af2);

  display_it(2, "t9171_delay   = ", 0, t9171_delay);

  display_it(2, "t9171_af2     = ", 0, t9171_af2);

  display_it(2, "t9191_probe   = ", 0, t9191_probe);

  /*Multimodule multislot test that does nothing*/

}



#define BLANK_LINE      ""

//------------------------------------------------------------------------------

void t9007(void)

{

  /*Enter and store the Minerva serial number*/

  int this_module;



  char buffer[81];

  test_result_type result;





  this_module = any_module_present();
  OpenResourceManager();
  //open_mux(this_module);
  open_34980A(this_module);



  if (get_result_nolog(this_module, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/

    display_prompt(BLANK_LINE, true);

    display_prompt("Enter the serial number of the 3235A (Minerva)", true);

    display_prompt("Then press <Return> or <Enter>.", true);

    display_prompt(BLANK_LINE, true);

    get_user_answer(buffer, 80);

  }  /*else*/



  store_mux_serial_number(this_module, buffer);



  close_34980A(this_module);//close_mux(this_module);
   CloseResourceManager();


}  /* t9007 */

#undef BLANK_LINE



#define BLANK_LINE      ""

#define OSC_CHANNEL     2

#define COUNT           5

#define COUPLING        50

#define SYN_FREQ        40000000

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  1.75e+00

#define TRIGGER_LEVEL   0.75e+00

#define TIMEBASE_RANGE  50e-09

#define TIMEBASE_OFFSET  0.0e+00

#define TIMEBASE_MODE   AUTOMATIC

//------------------------------------------------------------------------------

void t9008(void)

{

  /*MEASURE THE GENERATOR EXTERNAL INPUT TRIGGER THRESHOLD*/



  if (new_generator)

  {

    display_prompt("Test 9008 is not run with the new generator.  This is OK.  mjs", true);

  }

  else

  {//beginning of test 9008

  int this_module;



  double trig_duty_cycle;



  boolean averaging;



  char buffer[81];

  test_result_type result;





  this_module = any_module_present();

  present_test[this_module - NO_TESTHEAD_NUMBER] = 9008;

  present_test_type[this_module - NO_TESTHEAD_NUMBER] = SINGLE_MODULE_SINGLE_SLOT;

  present_subtest[this_module - NO_TESTHEAD_NUMBER] = 0;

  present_slot[this_module - NO_TESTHEAD_NUMBER] = 1;

  OpenResourceManager();
  //open_mux(this_module);
  open_34980A(this_module);
  open_33250A(this_module);
  open_gen(this_module);
  open_osc(this_module);
  if(check_syn_model())
  {
  enable_33250A_out(this_module);

  setup_33250A_defaults(this_module);

  connect_syn_out_gen_ext(this_module);

  connect_gen_trg_osc_ch2(this_module);

  setup_33250A_freq(this_module, SYN_FREQ);

  averaging = true;

  setup_osc_channel(this_module, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);

  setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);

  trigger_osc(this_module, OSC_CHANNEL, averaging);

  measure_osc(this_module, DUTY_CYCLE, POS);

  if (get_result_nolog(this_module, &result))

    trig_duty_cycle = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected osc reading)", true);



  if (trig_duty_cycle < 30 || trig_duty_cycle > 40)

  {

    averaging = false;

    setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                       TIMEBASE_OFFSET, TIMEBASE_MODE);

    setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);



    if (get_result_nolog(this_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Adjust generator external trigger input threshold",

                     true);

      display_prompt("level until the duty cycle is approximately 35%.", true);

      display_prompt("Follow the steps below:", true);

      display_prompt("1. Press the local key on the 54111 oscilliscope", true);

      display_prompt(

        "2. Press the \"more\" row key on the scope until \"meausure\" is displayed.",

        true);

      display_prompt("3. Press the \"measure\" row key on the scope.", true);

      display_prompt(

        "4. Press the \"more\" column key on the scope until \"DUTY CYCLE\" is displayed.",

        true);

      display_prompt("5. Press the \"DUTY CYCLE\" column key on the scope.",

                     true);

      display_prompt("6. Read the result as displayed on the screen of the scope.",

                     true);

      display_prompt(

        "7. Adjust the \"level\" control on the 8112A generator until the waveform is",

        true);

      display_prompt("   high approximately 35% of the time.", true);

      display_prompt(

        "8. Repeat steps 5, 6, and 7 until the scope measures between 33% and 37%.",

        true);

      display_prompt(

        "   NOTE: THE \"LEVEL\" ADJUSTMENT IS VERY SENSITIVE, IF THE ADJUSTMENT IS OFF",

        true);

      display_prompt(

        "         SLIGHTLY, THE WAVEFORM MAY BE EITHER ALWAYS HIGH OR ALWAYS LOW.",

        true);

      display_prompt("9. Then press <Return> or <Enter> on the computer.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    averaging = true;

    setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                       TIMEBASE_OFFSET, TIMEBASE_MODE);

    setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);

    trigger_osc(this_module, OSC_CHANNEL, averaging);

    measure_osc(this_module, DUTY_CYCLE, POS);



    if (get_result_nolog(this_module, &result))

      trig_duty_cycle = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected DTY Cycle)", true);



  }



  result.UU.Real_result = trig_duty_cycle;

  log_result(CAP_NUMBER, result);

  close_33250A(this_module);
}

  else
  {
  open_syn(this_module);

  connect_syn_aux_gen_ext(this_module);

  connect_gen_trg_osc_ch2(this_module);

  setup_syn_freq(this_module, SYN_FREQ);

  averaging = true;

  setup_osc_channel(this_module, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);

  setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);

  trigger_osc(this_module, OSC_CHANNEL, averaging);

  measure_osc(this_module, DUTY_CYCLE, POS);

  if (get_result_nolog(this_module, &result))

    trig_duty_cycle = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected osc reading)", true);



  if (trig_duty_cycle < 30 || trig_duty_cycle > 40)

  {

    averaging = false;

    setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                       TIMEBASE_OFFSET, TIMEBASE_MODE);

    setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);



    if (get_result_nolog(this_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Adjust generator external trigger input threshold",

                     true);

      display_prompt("level until the duty cycle is approximately 35%.", true);

      display_prompt("Follow the steps below:", true);

      display_prompt("1. Press the local key on the 54111 oscilliscope", true);

      display_prompt(

        "2. Press the \"more\" row key on the scope until \"meausure\" is displayed.",

        true);

      display_prompt("3. Press the \"measure\" row key on the scope.", true);

      display_prompt(

        "4. Press the \"more\" column key on the scope until \"DUTY CYCLE\" is displayed.",

        true);

      display_prompt("5. Press the \"DUTY CYCLE\" column key on the scope.",

                     true);

      display_prompt("6. Read the result as displayed on the screen of the scope.",

                     true);

      display_prompt(

        "7. Adjust the \"level\" control on the 8112A generator until the waveform is",

        true);

      display_prompt("   high approximately 35% of the time.", true);

      display_prompt(

        "8. Repeat steps 5, 6, and 7 until the scope measures between 33% and 37%.",

        true);

      display_prompt(

        "   NOTE: THE \"LEVEL\" ADJUSTMENT IS VERY SENSITIVE, IF THE ADJUSTMENT IS OFF",

        true);

      display_prompt(

        "         SLIGHTLY, THE WAVEFORM MAY BE EITHER ALWAYS HIGH OR ALWAYS LOW.",

        true);

      display_prompt("9. Then press <Return> or <Enter> on the computer.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    averaging = true;

    setup_osc_timebase(this_module, averaging, COUNT, TIMEBASE_RANGE,

                       TIMEBASE_OFFSET, TIMEBASE_MODE);

    setup_osc_trigger(this_module, OSC_CHANNEL, POS, TRIGGER_LEVEL, averaging);

    trigger_osc(this_module, OSC_CHANNEL, averaging);

    measure_osc(this_module, DUTY_CYCLE, POS);



    if (get_result_nolog(this_module, &result))

      trig_duty_cycle = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected DTY Cycle)", true);



  }



  result.UU.Real_result = trig_duty_cycle;

  log_result(CAP_NUMBER, result);

  close_syn(this_module);
  }



  close_gen(this_module);
  close_osc(this_module);
  close_34980A(this_module);//close_mux(this_module);
  CloseResourceManager();

} //end of test 9008

}  /*t9008*/





#undef BLANK_LINE

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef SYN_FREQ

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TIMEBASE_MODE



#define LCR_MULT        5

#define LCR_FREQ        100e+03

#define WAIT_TIME       500e-03

#define LCR_DISPLAY     Q

#define LCR_FUNCTION    CAPACITANCE

#define LCR_CKT_MODE    PARALLEL

//------------------------------------------------------------------------------

void t9010(int mod_id, int /* slot */)

{

  /* Parallel Xn Bus Capacitance Offset */

  int next;

  int start;



  double farads;



  int channel;

  test_result_type result;

  char *s_ptr;

  char s[MAX_S_LENGTH + 1];

  char *str1;



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock(); //added this in to insure that the fixture is locked down

  //to pass subtest 8

  vth_mtmr_wait(mod_id, 1.0);



  OpenResourceManager();//chun 08032022

  //open_mux(mod_id);
  open_34980A(mod_id);
  open_lcr(mod_id);
  //open_E4980AL_LCR(mod_id);



  setup_lcr(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ,LCR_MULT);
  //setup_E4980AL_LCR(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);


  vth_aopen_all_rlys(mod_id);


  if (get_34980A_IDN == false)//chun 09032022
  {
	  connect_dg(mod_id, true);
  }

  connect_lcr(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    connect_plus_xn(mod_id, channel, true);//chun temp comment out due to fail 9010

    connect_minus_xn_plus_1(mod_id, channel, true);   /* 'H'  Xn + 1 = 'A' */



    vth_mtmr_wait(mod_id, WAIT_TIME);

    measure_lcr(mod_id);
	//measure_E4980AL_LCR(mod_id);

    result.Measurement_class = CLASS_PSTRING_PTR;

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      s_ptr = static_cast(char*,result.UU.Pstring_ptr);

      strcpy(s, s_ptr);

//  Debug

//    start = strpos2("C", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
    start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

      farads = strtod(s + start - 1, &str1);

      next = str1 - s + 1;

      if (mod_id == 0 || mod_id == 3)

        sales_rack_offset_cap[0][channel - 'A'] = farads;

      else

        sales_rack_offset_cap[1][channel - 'A'] = farads;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = farads - 3.0e-10;  //fikri simulation
//      result.UU.Real_result = farads;  //Original
      log_result(mod_id, result);

    }  /*if*/

    else

      display_prompt("No result in result log (Expected LCR Reading)", true);



    connect_plus_xn(mod_id, channel, false);//chun temp comment out due to fail 9010

    connect_minus_xn_plus_1(mod_id, channel, false);   /* 'H'  Xn + 1 = 'A' */

  }  /*for*/



  channel = 'H';

  connect_plus_gout(mod_id);

  connect_minus_xn_plus_1(mod_id, channel, true);   /* 'H'  Xn + 1 = 'A' */

  vth_mtmr_wait(mod_id, WAIT_TIME);

  measure_lcr(mod_id);
  //measure_E4980AL_LCR(mod_id);

  result.Measurement_class = CLASS_PSTRING_PTR;

  if (get_result_nolog(mod_id, &result))

  {

    s_ptr = static_cast(char*,result.UU.Pstring_ptr);

    strcpy(s, s_ptr);

//  Debug

//  start = strpos2("C", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
    start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

    farads = strtod(s + start - 1, &str1);

    next = str1 - s + 1;

    if (mod_id == 0 || mod_id == 3)

      sales_rack_offset_xg_cap[0] = farads;

    else

      sales_rack_offset_xg_cap[1] = farads;

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = farads;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected LCR Reading)", true);





  close_34980A(mod_id);//close_mux(mod_id);

  close_lcr(mod_id);
  //close_E4980AL_LCR(mod_id);

  CloseResourceManager();//chun 08032022

}  /*t9010*/















  //########### Sri added the new test 9011 and 9012 = Utility Load Test ########################################



  //Load test for the Utility card-Channel 7, relays involved:

  //Each relay package has pair of hi and lo conenction

  //Relay Hi/Lo Pair: KU601,KU602,KU603,KU604,KU607, KU608 total produce 6x3 Amps = 18Amps at 30V

   //2 types of sensing: Local and Remote Sensing

  //Local sensing(both hi and lo on the same relay) :KU605,

  //Remote sensing(both hi and lo on the same relay):KU606



  //Load test for the Utility card-Channel 8, relays involved:

  //Each relay package has pair of hi and lo conenction

  //Relay Hi/Lo Pair: KU701,KU702,KU703,KU704,KU707, KU708 total produce 6x3 Amps = 18Amps at 30V

   //2 types of sensing: Local and Remote Sensing

  //Local sensing(both hi and lo on the same relay) :KU705

  //Remote sensing(both hi and lo on the same relay):KU706



#define LOAD_RELAY_DELAY     300       //Fong's experiment

#define DIFF1           5e-03 //need to undefine

#define RAMP_TIME       10e+00//need to undefine

#define PS_CURRENT      500e-03

#define PS_CURRENT_LOAD  3.0



  //SLOT 3 for the MODULE 1 AND 2

  //SLOT 10 for the MODULE 0 AND 3

  //------------------------------------------------------------------------------

void t9011(int mod_id, int slot)//Channel 7 DUT PS Load Test/

{



  int dutps_chan7[6] = { KU601,KU602,KU603,KU604,KU607,KU608}; //BASED ON P2 SUB CARD RELAY NAMING!

  int dutps_chan7_sense[1] = {KU606};

  int ps_voltage = 6.0;

  int ps_voltage_load = 30; //Load test voltage



  double load_measured_current;



  test_result_type result;



  //open_mux(mod_id);
  open_34980A(mod_id);

  //open_ps(mod_id);
  open_PS_N6746B(mod_id);

  //open_ps_load(mod_id);//create all the related functions in the mtglobal file
  open_PS_N6754A_load(mod_id);

  aconnect_ps_20_ohm_load(mod_id, true);// power to turn on load relay

  connect_load_test_relay(mod_id, true);		  //turn on GP Relay in Slot 2 minerva interface

  vth_aopen_all_rlys(mod_id);



  //check for Relay Stuck Test



		for (int n1=0; n1<6; n1++)

		{

		vth_uopen_rly(mod_id, slot, dutps_chan7[n1]);

		}



    /*

  //open all pin card relays

		for (int count=2; count<=5;count++)

		{

		vth_popen_all_rlys(mod_id, count);

		}



        for (int count1=7; count1<=9;count1++)

		{

		vth_popen_all_rlys(mod_id, count1);

		}



        vth_popen_all_rlys(mod_id, 11);

*/



    if ((mod_id==0) || (mod_id==3)) // sub card at slot 10

	{

	vth_popen_all_rlys(mod_id, 2);

    vth_popen_all_rlys(mod_id, 3);

	vth_popen_all_rlys(mod_id, 4);

	vth_popen_all_rlys(mod_id, 5);

	vth_popen_all_rlys(mod_id, 7);

	vth_popen_all_rlys(mod_id, 8);

	vth_popen_all_rlys(mod_id, 9);

	vth_popen_all_rlys(mod_id, 11);

	}

	else                            //sub card at slot 3

	{

    vth_popen_all_rlys(mod_id, 2);

    vth_popen_all_rlys(mod_id, 10);

	vth_popen_all_rlys(mod_id, 4);

	vth_popen_all_rlys(mod_id, 5);

	vth_popen_all_rlys(mod_id, 7);

	vth_popen_all_rlys(mod_id, 8);

	vth_popen_all_rlys(mod_id, 9);

	vth_popen_all_rlys(mod_id, 11);

    }







	vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

	//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
	setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

    //verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
	verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

	vth_mtmr_wait(mod_id, 2);

	//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
	setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

    //verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
	verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

	//display_prompt("WAIT FOR 5 MINS", true);

	//vth_mtmr_wait(mod_id, LOAD_RELAY_DELAY);

	vth_mtmr_wait(mod_id, 2);

	//load_measured_current = measure_ps_load_current(mod_id);
	load_measured_current = measure_PS_N6754A_load_current(mod_id);

	//disable_ps_out_load(mod_id);
	setup_N6754A_ch1_output(0);

	vth_mtmr_wait(mod_id, 2);

	//disable_ps_out(mod_id);
	setup_N6746B_ch2_output(0);

	result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

    result.UU.Real_result = load_measured_current;// expecting ~0 Amps current flow thru relays

    log_result(mod_id, result);

  	//close Relay Stuck Test





		//check for normal function of POWER RELAYS load test 30V 3Amps

		for (int n=0; n<6; n++) // This portion ensures no hot switch for the power relays,

	{

		vth_mtmr_wait(mod_id, 2);//to prevent hot swicth while PS

		vth_uclose_rly(mod_id, slot, KU606);

		vth_uclose_rly(mod_id, slot, dutps_chan7[n]);//close the particular power relays

		//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
		setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

		//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
		verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

		vth_mtmr_wait(mod_id, 2);

		//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
		setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

		//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
		verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

		//display_prompt("WAIT FOR 5 MINS", true);

	    //vth_mtmr_wait(mod_id, LOAD_RELAY_DELAY);

		vth_mtmr_wait(mod_id, 2);

		//load_measured_current = measure_ps_load_current(mod_id);
		load_measured_current = measure_PS_N6754A_load_current(mod_id);

		//disable_ps_out_load(mod_id);
		setup_N6754A_ch1_output(0);

		vth_mtmr_wait(mod_id, 2);

		//disable_ps_out(mod_id);
		setup_N6746B_ch2_output(0);

		vth_mtmr_wait(mod_id, 2);//to prevent hot swicth while PS ramping down

		vth_uopen_rly(mod_id, slot, KU606);

		vth_uopen_rly(mod_id, slot, dutps_chan7[n]);//open the particular power relays

		vth_mtmr_wait(mod_id, 2);

		vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

		result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

		result.UU.Real_result = load_measured_current;

		log_result(mod_id, result);

  	}

		//close check for normal function of POWER RELAYS load test 30V 3Amps





			//check for Relay Stuck after turned on

			//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
			setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

			//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
			verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

			vth_mtmr_wait(mod_id, 2);

			//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
			setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

			//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
			verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

			//display_prompt("WAIT FOR 5 MINS", true);

	        //vth_mtmr_wait(mod_id, LOAD_RELAY_DELAY);

			vth_mtmr_wait(mod_id, 2);

			//load_measured_current = measure_ps_load_current(mod_id);
			load_measured_current = measure_PS_N6754A_load_current(mod_id);

			//disable_ps_out_load(mod_id);
			setup_N6754A_ch1_output(0);

			vth_mtmr_wait(mod_id, 2);

			//disable_ps_out(mod_id);
			setup_N6746B_ch2_output(0);

			result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

			result.UU.Real_result = load_measured_current;

			log_result(mod_id, result);

  			//close Relay Stuck test after turned on





  //close_ps(mod_id);
  close_PS_N6746B(mod_id);

  //close_ps_load(mod_id);
  close_PS_N6754A_load(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}//end of test 9011

  /*t9011*/





// ############################## end of new test 9011 added ##########################################







void t9012(int mod_id, int slot)//Channel 8 DUT PS Load Test/
{



  int dutps_chan8[6] = { KU701,KU702,KU703,KU704,KU707, KU708};

  int dutps_chan8_sense[1] = {KU706};//chnaged from 124

  int ps_voltage = 6;

  int ps_voltage_load = 30; //Load test voltage



  double load_measured_current;



  test_result_type result;



  //open_mux(mod_id);
  open_34980A(mod_id);

  //open_ps(mod_id);
  open_PS_N6746B(mod_id);

  //open_ps_load(mod_id);//create all the related functions in the mtglobal file
  open_PS_N6754A_load(mod_id);

  aconnect_ps_20_ohm_load(mod_id, true);// power to turn on load relay

  connect_load_test_relay(mod_id, true);		  //turn on GP Relay in Slot 2 minerva interface

  vth_aopen_all_rlys(mod_id);



   //check for Relay Stuck Test



		for (int n2=0; n2<6; n2++)

		{

		vth_uopen_rly(mod_id, slot, dutps_chan8[n2]);//

		}

/*

  //open all pin card relays

		for (int count2=2; count2<=5;count2++)

		{

		vth_popen_all_rlys(mod_id, count2);

		}



        for (int count3=7; count3<=9;count3++)

		{

		vth_popen_all_rlys(mod_id, count3);

		}



        vth_popen_all_rlys(mod_id, 11);

*/



if ((mod_id==0) || (mod_id==3)) // sub card at slot 10

	{

	vth_popen_all_rlys(mod_id, 2);

    vth_popen_all_rlys(mod_id, 3);

	vth_popen_all_rlys(mod_id, 4);

	vth_popen_all_rlys(mod_id, 5);

	vth_popen_all_rlys(mod_id, 7);

	vth_popen_all_rlys(mod_id, 8);

	vth_popen_all_rlys(mod_id, 9);

	vth_popen_all_rlys(mod_id, 11);

	}

	else                            //sub card at slot 3
	{

    vth_popen_all_rlys(mod_id, 2);

    vth_popen_all_rlys(mod_id, 10);

	vth_popen_all_rlys(mod_id, 4);

	vth_popen_all_rlys(mod_id, 5);

	vth_popen_all_rlys(mod_id, 7);

	vth_popen_all_rlys(mod_id, 8);

	vth_popen_all_rlys(mod_id, 9);

	vth_popen_all_rlys(mod_id, 11);

    }



  //check for Relay Stuck Test

	vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

    //setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
	setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

    //verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
	verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

	vth_mtmr_wait(mod_id, 2);

	//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
	setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

    //verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
	verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

	vth_mtmr_wait(mod_id, 2);

	//load_measured_current = measure_ps_load_current(mod_id);
	load_measured_current = measure_PS_N6754A_load_current(mod_id);

	//disable_ps_out_load(mod_id);
	disable_ps_N6754A_out_load(mod_id);

	vth_mtmr_wait(mod_id, 2);

	//disable_ps_out(mod_id);
	disable_ps_N6746B_out(mod_id);

	result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

    result.UU.Real_result = load_measured_current;// expecting ~0 Amps current flow thru relays

    log_result(mod_id, result);

  	//close Relay Stuck Test





		//check for normal function of POWER RELAYS load test 30V 3Amps

	for (int n=0; n<6; n++) // This portion ensures no hot switch for the power relays,
	{

		vth_uclose_rly(mod_id, slot, KU706);

		vth_uclose_rly(mod_id, slot, dutps_chan8[n]);//close the particular power relays

		//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
		setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

		//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
		verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

		vth_mtmr_wait(mod_id, 2);

		//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
		setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

		//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
		verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

		vth_mtmr_wait(mod_id, 2);

		//load_measured_current = measure_ps_load_current(mod_id);
		load_measured_current = measure_PS_N6754A_load_current(mod_id);

		//disable_ps_out_load(mod_id);
		disable_ps_N6754A_out_load(mod_id);

		vth_mtmr_wait(mod_id, 2);

		//disable_ps_out(mod_id);
		disable_ps_N6746B_out(mod_id);

		vth_mtmr_wait(mod_id, 2);//to prevent hot swicth while PS ramping down

		vth_uopen_rly(mod_id, slot, KU706);

		vth_uopen_rly(mod_id, slot, dutps_chan8[n]);//open the particular power relays

		vth_mtmr_wait(mod_id, 2);

		vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

		result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

		result.UU.Real_result = load_measured_current;

		log_result(mod_id, result);

  	}

		//close check for normal function of POWER RELAYS load test 30V 3Amps





			//check for Relay Stuck after turned on

			//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
			setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

			//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
			verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

			vth_mtmr_wait(mod_id, 2);

			//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
			setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

			//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
			verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

			vth_mtmr_wait(mod_id, 2);

			//load_measured_current = measure_ps_load_current(mod_id);
			load_measured_current = measure_PS_N6754A_load_current(mod_id);

			//disable_ps_out_load(mod_id);
			disable_ps_N6754A_out_load(mod_id);

			vth_mtmr_wait(mod_id, 2);

			//disable_ps_out(mod_id);
			disable_ps_N6746B_out(mod_id);

			result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

			result.UU.Real_result = load_measured_current;

			log_result(mod_id, result);

  			//close Relay Stuck test after turned on





  //close_ps(mod_id);
  close_PS_N6746B(mod_id);

  //close_ps_load(mod_id);
  close_PS_N6754A_load(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

//##################################################################################



}//end of test 9012

  /*t9012*/







// ############################## end of new test 9012 added ##########################################







void t9016(int mod_id, int slot)//Channel 8 DUT PS Load Test/
{

//dummy test for debugging purposes!

}









//########### Sri added the new test 9013 and 9014 = NASRU Load Test ########################################



  //Load test for the NAsru card-Channel 3, relays involved:

  //Each relay package has pair of hi and lo conenction

  //Relay Hi/Lo Pair: K126, K127, K128, K129, K130, K123, total produce 2x3 Amps = 6Amps at 30V(PARTIAL)

   //2 types of sensing: Local and Remote Sensing

  //Local sensing(both hi and lo on the same relay) :K125,

  //Remote sensing(both hi and lo on the same relay):K124





  //Load test for the NAsru card-Channel 4, relays involved:

  //Each relay package has pair of hi and lo conenction

  //Relay Hi/Lo Pair: K118, K119, K120, K121, K122, K115, total produce 2x3 Amps = 6Amps at 30V(PARTIAL)

   //2 types of sensing: Local and Remote Sensing

  //Local sensing(both hi and lo on the same relay) :K117

  //Remote sensing(both hi and lo on the same relay):K116



#define		 K118		64L      /* PS_CH7_1 */    /* 64 */

#define		 K119		65L      /* PS_CH7_2 */

#define		 K120		66L      /* PS_CH7_3 */

#define		 K121		67L      /* PS_CH7_4 */

#define		 K122		68L      /* PS_CH7_5 */

#define		 K115		69L      /* PS_CH7_6 */

#define		 K35		70L      /* PS_DGN_1 */

#define		 K33		71L      /* PS_DGN_2 */

#define		 K34		72L      /* PS_DGN_3 */



#define		 K117		76L      /* PS_CH7_Remote_S */

#define		 K116		77L      /* PS_CH7_Direct_S */





#define		 K126		80L      /* PS_CH8_1 */    /* 80 */

#define		 K127		81L      /* PS_CH8_2 */

#define		 K128		82L      /* PS_CH8_3 */

#define		 K129		83L      /* PS_CH8_4 */

#define		 K130		84L      /* PS_CH8_5e */

#define		 K123		85L      /* PS_CH8_6 */

#define		 K38		86L      /* PS_DGN_4 */

#define		 K36		87L      /* PS_DGN_5 */

#define		 K37		88L      /* PS_DGN_6 */



#define		 K125		92L      /* PS_CH8_Remote_S */

#define		 K124		93L      /* PS_CH8_Direct_S */



#define DIFF1           5e-03 //need to undefine

#define RAMP_TIME       10e+00//need to undefine

#define PS_CURRENT      500e-03

//#define PS_CURRENT_LOAD      3.00

//#define PIN_SLOT 4

  //------------------------------------------------------------------------------

void t9013(int mod_id, int slot)//Channel 3 DUT PS Load Test/

{



  int dutps_chan7[6] = { K118, K119, K120, K121, K122, K115};

  int dutps_chan7_sense[1] = {K117};//chnaged from 116

  int ps_voltage = 5.0;

  int ps_voltage_load = 30; //Load test voltage



  double load_measured_current;



  test_result_type result;



  //open_mux(mod_id);
  open_34980A(mod_id);

  //open_ps(mod_id);
  open_PS_N6746B(mod_id);

  //open_ps_load(mod_id);//create all the related functions in the mtglobal file
  open_PS_N6754A_load(mod_id);//create all the related functions in the mtglobal file

  aconnect_ps_20_ohm_load(mod_id, true);// power to turn on load relay

  connect_load_test_relay(mod_id, true);		  //turn on GP Relay in Slot 2 minerva interface

  vth_aopen_all_rlys(mod_id);



  //check for Relay Stuck Test

	vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

    //setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
	setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

    //verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
	verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

	vth_mtmr_wait(mod_id, 2);

	//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
	setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

    //verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
	verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

	vth_mtmr_wait(mod_id, 2);

	//load_measured_current = measure_ps_load_current(mod_id);
	load_measured_current = measure_PS_N6754A_load_current(mod_id);

	//disable_ps_out_load(mod_id);
	disable_ps_N6754A_out_load(mod_id);

	//disable_ps_out(mod_id);
	disable_ps_N6746B_out(mod_id);

	result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

    result.UU.Real_result = load_measured_current;// expecting ~0 Amps current flow thru relays

    log_result(mod_id, result);

  	//close Relay Stuck Test





	//check for normal function of POWER RELAYS load test 30V 3Amps

	for (int n=0; n<6; n++) // This portion ensures no hot switch for the power relays,
	{

		vth_uclose_rly(mod_id, slot, K117);

		vth_uclose_rly(mod_id, slot, dutps_chan7[n]);//close the particular power relays

		//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
		setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

		//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
		verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

		vth_mtmr_wait(mod_id, 2);

		//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
		setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

		//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
		verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

		vth_mtmr_wait(mod_id, 2);

		//load_measured_current = measure_ps_load_current(mod_id);
		load_measured_current = measure_PS_N6754A_load_current(mod_id);

		//disable_ps_out_load(mod_id);
		disable_ps_N6754A_out_load(mod_id);

		//disable_ps_out(mod_id);
		disable_ps_N6746B_out(mod_id);

		vth_uopen_rly(mod_id, slot, K117);

		vth_uopen_rly(mod_id, slot, dutps_chan7[n]);//open the particular power relays

		vth_mtmr_wait(mod_id, 2);

		vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

		result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

		result.UU.Real_result = load_measured_current;

		log_result(mod_id, result);

  	}

		//close check for normal function of POWER RELAYS load test 30V 3Amps





			//check for Relay Stuck after turned on

			//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
			setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

			//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
			verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

			vth_mtmr_wait(mod_id, 2);

			//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
			setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

			//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
			verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

			vth_mtmr_wait(mod_id, 2);

			//load_measured_current = measure_ps_load_current(mod_id);
			load_measured_current = measure_PS_N6754A_load_current(mod_id);

			//disable_ps_out_load(mod_id);
			disable_ps_N6754A_out_load(mod_id);

			//disable_ps_out(mod_id);
			disable_ps_N6746B_out(mod_id);

			result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

			result.UU.Real_result = load_measured_current;

			log_result(mod_id, result);

  			//close Relay Stuck test after turned on





  //close_ps(mod_id);
  close_PS_N6746B(mod_id);

  //close_ps_load(mod_id);
  close_PS_N6754A_load(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}//end of test 9013

  /*t9013*/









#define		 K118		64L      /* PS_CH7_1 */    /* 64 */

#define		 K119		65L      /* PS_CH7_2 */

#define		 K120		66L      /* PS_CH7_3 */

#define		 K121		67L      /* PS_CH7_4 */

#define		 K122		68L      /* PS_CH7_5 */

#define		 K115		69L      /* PS_CH7_6 */

#define		 K35		70L      /* PS_DGN_1 */

#define		 K33		71L      /* PS_DGN_2 */

#define		 K34		72L      /* PS_DGN_3 */



#define		 K117		76L      /* PS_CH7_Remote_S */

#define		 K116		77L      /* PS_CH7_Direct_S */





#define		 K126		80L      /* PS_CH8_1 */    /* 80 */

#define		 K127		81L      /* PS_CH8_2 */

#define		 K128		82L      /* PS_CH8_3 */

#define		 K129		83L      /* PS_CH8_4 */

#define		 K130		84L      /* PS_CH8_5e */

#define		 K123		85L      /* PS_CH8_6 */

#define		 K38		86L      /* PS_DGN_4 */

#define		 K36		87L      /* PS_DGN_5 */

#define		 K37		88L      /* PS_DGN_6 */



#define		 K125		92L      /* PS_CH8_Remote_S */

#define		 K124		93L      /* PS_CH8_Direct_S */



#define DIFF1           5e-03 //need to undefine

#define RAMP_TIME       10e+00//need to undefine

#define PS_CURRENT      500e-03

//#define PS_CURRENT_LOAD      3.00

//#define PIN_SLOT 4

  //------------------------------------------------------------------------------

void t9014(int mod_id, int slot)//Channel 4 DUT PS Load Test/
{



  int dutps_chan7[6] = { K118, K119, K120, K121, K122, K115};

  int dutps_chan7_sense[1] = {K117};//chnaged from 116

  int ps_voltage = 5.0;

  int ps_voltage_load = 30; //Load test voltage



  double load_measured_current;



  test_result_type result;



  //open_mux(mod_id);
  open_34980A(mod_id);

  //open_ps(mod_id);
  open_PS_N6746B(mod_id);

  //open_ps_load(mod_id);//create all the related functions in the mtglobal file
  open_PS_N6754A_load(mod_id);//create all the related functions in the mtglobal file

  aconnect_ps_20_ohm_load(mod_id, true);// power to turn on load relay

  connect_load_test_relay(mod_id, true);		  //turn on GP Relay in Slot 2 minerva interface

  vth_aopen_all_rlys(mod_id);



  //check for Relay Stuck Test

	vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

    //setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
	setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

    //verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
	verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

	vth_mtmr_wait(mod_id, 2);

	//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
	setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

    //verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
	verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

	vth_mtmr_wait(mod_id, 2);

	//load_measured_current = measure_ps_load_current(mod_id);
	load_measured_current = measure_PS_N6754A_load_current(mod_id);

	//disable_ps_out_load(mod_id);
	disable_ps_N6754A_out_load(mod_id);

	//disable_ps_out(mod_id);
	disable_ps_N6746B_out(mod_id);

	result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

    result.UU.Real_result = load_measured_current;// expecting ~0 Amps current flow thru relays

    log_result(mod_id, result);

  	//close Relay Stuck Test





		//check for normal function of POWER RELAYS load test 30V 3Amps

	for (int n=0; n<6; n++) // This portion ensures no hot switch for the power relays,
	{

		vth_uclose_rly(mod_id, slot, K117);

		vth_uclose_rly(mod_id, slot, dutps_chan7[n]);//close the particular power relays

		//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
		setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

		//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
		verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

		vth_mtmr_wait(mod_id, 2);

		//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
		setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

		//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
		verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

		vth_mtmr_wait(mod_id, 2);

		//load_measured_current = measure_ps_load_current(mod_id);
		load_measured_current = measure_PS_N6754A_load_current(mod_id);

		//disable_ps_out_load(mod_id);
		disable_ps_N6754A_out_load(mod_id);

		//disable_ps_out(mod_id);
		disable_ps_N6746B_out(mod_id);

		vth_uopen_rly(mod_id, slot, K117);

		vth_uopen_rly(mod_id, slot, dutps_chan7[n]);//open the particular power relays

		vth_mtmr_wait(mod_id, 2);

		vth_uopen_all_rlys(mod_id, slot); // open all relays on UTILITY CARD

		result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

		result.UU.Real_result = load_measured_current;

		log_result(mod_id, result);

  	}

		//close check for normal function of POWER RELAYS load test 30V 3Amps





			//check for Relay Stuck after turned on

			//setup_ps(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current
			setup_PS_N6746B(mod_id, ps_voltage, PS_CURRENT);//Load PS setup voltage and current

			//verify_ps_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));
			verify_PS_N6746B_output(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage));

			vth_mtmr_wait(mod_id, 2);

			//setup_ps_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current
			setup_PS_N6754A_load(mod_id, ps_voltage_load, PS_CURRENT_LOAD);//Load PS setup voltage and current

			//verify_ps_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));
			verify_PS_N6754A_output_load(mod_id, DIFF1, RAMP_TIME, fabs(ps_voltage_load));

			vth_mtmr_wait(mod_id, 2);

			//load_measured_current = measure_ps_load_current(mod_id);
			load_measured_current = measure_PS_N6754A_load_current(mod_id);

			//disable_ps_out_load(mod_id);
			disable_ps_N6754A_out_load(mod_id);

			//disable_ps_out(mod_id);
			disable_ps_N6746B_out(mod_id);

			result.Measurement_class = CLASS_REAL; //type of result, can be integer or character also.

			result.UU.Real_result = load_measured_current;

			log_result(mod_id, result);

  			//close Relay Stuck test after turned on





  //close_ps(mod_id);
  close_PS_N6746B(mod_id);

  //close_ps_load(mod_id);
  close_PS_N6754A_load(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}//end of test 9014

  /*t9014*/







//#################################### end test 9013 and 9014###########################################//

















/////////////////////////////////////////////////////////////////////////////////////////////////////////





#undef DIFF1

#undef RAMP_TIME

#undef PS_CURRENT

#undef PS_CURRENT_LOAD

#undef LCR_MULT

#undef LCR_FREQ

#undef WAIT_TIME

#undef LCR_DISPLAY

#undef LCR_FUNCTION

#undef LCR_CKT_MODE







#define LIMITS_PER_DOT  120

#define LOW_1060_STD_DEV  5.00000e-11   /* Non-alternate limit */

#define LOW_1060_F86_DELAY  1.50000e-09   /* Non-alternate limit */

#define LOW_1256_HALT   8200000   /* Non-alternate limit */

#define ADJUSTED_LOW_STD_DEV  7.00000e-11   /* Mean - 5 std dev */

#define ADJUSTED_HIGH_STD_DEV  9.52500e-10   /* High limit = 5% */

#define ADJUSTED_LOW_F86_DELAY  1.70000e-09   /* Low +200pS repeatability */

#define ADJUSTED_HIGH_F86_DELAY  7.67500e-09   /* High limit = 5% */

#define ADJUSTED_LOW_HALT  8300000   /* All data is 8388609 or */

#define ADJUSTED_HIGH_HALT  8389000   /* or 8388610 */



/* static variables for t9015: */

struct LOC_t9015

{

  double        alternate;

  a_limit_rec** next_ptr[LAST_TEST - FIRST_TEST + 1];

};



static void free_limits(struct LOC_t9015 *LINK)

{

  int          loop;

  a_limit_rec* hold;

  a_limit_rec* limit_ptr;



  for (loop = FIRST_TEST; loop <= LAST_TEST; loop++)

  {  /* init */

    if (all_limits[loop - FIRST_TEST] != NULL)

    {  /* free the data */

      limit_ptr = all_limits[loop - FIRST_TEST];

      while (limit_ptr != NULL)

      {  /* free the limit */

        hold = limit_ptr;

        limit_ptr = limit_ptr->next;

        Free(hold);

      }  /* free the limit */

    }  /* free the data */



    all_limits[loop - FIRST_TEST] = NULL;

    LINK->next_ptr[loop - FIRST_TEST] = &all_limits[loop - FIRST_TEST];

  }  /*  init  */

}  /*  free_limits  */



static void add_sorted_limit(a_limit_rec *limit_ptr, struct LOC_t9015 *LINK)

{

  int test_number;



  test_number = limit_ptr->test_number;

  *LINK->next_ptr[test_number - FIRST_TEST] = limit_ptr;

  limit_ptr->next = NULL;

  LINK->next_ptr[test_number - FIRST_TEST] = &limit_ptr->next;

}  /*  add_sorted_limit  */



/* ------------------------------------------------------------------------- */

/* Determine if the real limit is bound to infinity or 0.0 ----------------- */

/* ------------------------------------------------------------------------- */

static boolean r_bound(double data, struct LOC_t9015* /* LINK */)

{

  boolean result;



  result = false;

  if (r_infinity(data))

    return true;

  if (data == 0.0e0)

  {

    return true;

    /* the case below was added because DGN uses 1E30 as an upper bound for relay */

    /* tests (as opposed to using DGN_infinity which is 1E31).                    */

  }

  if ( number_equal(data,1.0e30) )

  {

    return true;

    /* the case below was added because DGN uses -1E30 as a lower bound for p.s.  */

    /* lead resistance test T2341.                                                */

  }

  if ( number_equal(data, -1.0e30) )

  {

    return true;

    /* the case below was added for T5820, SS driver slew rate */

  }

  if (data == 1.0e10)

    return true;

  return result;

}  /* r_bound */



/* ------------------------------------------------------------------------- */

/* Determine if the integer limit is bound to infinity or 0 ---------------- */

/* ------------------------------------------------------------------------- */

static boolean i_bound(int data, struct LOC_t9015* /* LINK */)

{

  boolean result;



  result = false;

  if (i_infinity(data))

    return true;

  if (data == 0)

    return true;

  return result;

}  /* i_bound */



/* ------------------------------------------------------------------------- */

/* Convert the limit to an alternate limit --------------------------------- */

/* ------------------------------------------------------------------------- */

static void calculate_alternate_limit(a_limit_rec *limit, struct LOC_t9015 *LINK)

{

  double roffset;

  int ioffset;





  switch (limit->result_type)

  {



  case CLASS_REAL:  /* real result */

    if (!r_bound(limit->UU.U3.low_real_limit, LINK) &&

        !r_bound(limit->UU.U3.high_real_limit, LINK))

    {

      switch (limit->num_limits)

      {



      case 3:  /* three numbers */

        roffset = (limit->UU.U3.high_real_limit - limit->

                     UU.U3.nominal_real_limit) * LINK->alternate * 2;

        limit->UU.U3.high_real_limit -= roffset;

        roffset = (limit->UU.U3.nominal_real_limit - limit->

                     UU.U3.low_real_limit) * LINK->alternate * 2;

        limit->UU.U3.low_real_limit += roffset;

        break;

        /* three numbers */



      case 2:  /* two numbers */

        roffset = (limit->UU.U3.high_real_limit - limit->UU.U3.low_real_limit) *

                  LINK->alternate;

        limit->UU.U3.low_real_limit += roffset;

        limit->UU.U3.high_real_limit -= roffset;

        break;

        /* two numbers */

        /* no case of one number limits */

      default:

        assert(false);

        break;



      }/* case regular numbers */



    }

    else if (!r_bound(limit->UU.U3.low_real_limit, LINK) &&

             r_bound(limit->UU.U3.high_real_limit, LINK))

      limit->UU.U3.low_real_limit += LINK->alternate *

                                     fabs(limit->UU.U3.low_real_limit);

    else if (r_bound(limit->UU.U3.low_real_limit, LINK) &&

             !r_bound(limit->UU.U3.high_real_limit, LINK))

      limit->UU.U3.high_real_limit -= LINK->alternate *

                                      fabs(limit->UU.U3.high_real_limit);



    break;

    /* real result */



  case CLASS_INTEGER:  /*  integer result  */

    if (!i_bound(limit->UU.U4.low_integer_limit, LINK) &&

        !i_bound(limit->UU.U4.high_integer_limit, LINK))

    {

      switch (limit->num_limits)

      {



      case 3:  /* three limits */

        ioffset = static_cast<int>((limit->UU.U4.high_integer_limit - limit->UU.U4.nominal_integer_limit) * LINK->alternate * 2);

        limit->UU.U4.high_integer_limit -= ioffset;

        ioffset = static_cast<int>((limit->UU.U4.nominal_integer_limit - limit->UU.U4.low_integer_limit) * LINK->alternate * 2);

        limit->UU.U4.low_integer_limit += ioffset;

        break;

      case 2:  /* two limits */

        ioffset = static_cast<int>((limit->UU.U4.high_integer_limit - limit->UU.U4.low_integer_limit) * LINK->alternate);

        limit->UU.U4.low_integer_limit += ioffset;

        limit->UU.U4.high_integer_limit -= ioffset;

        break;

      case 1:  /* one limit */

        // do nothing

        break;

      default:

        // cause an abort if execution gets here since this should not happen

        assert(false);

        break;

      }/* case regular numbers */



    }

    else if (!i_bound(limit->UU.U4.low_integer_limit, LINK) &&

             i_bound(limit->UU.U4.high_integer_limit, LINK))

      limit->UU.U4.low_integer_limit +=

        (int)(LINK->alternate * abs(limit->UU.U4.low_integer_limit));

    else if (i_bound(limit->UU.U4.low_integer_limit, LINK) &&

             !i_bound(limit->UU.U4.high_integer_limit, LINK))

      limit->UU.U4.high_integer_limit -=

        (int)(LINK->alternate * abs(limit->UU.U4.high_integer_limit));

    break;

    /* integer result */





    default:

      assert(false);

      break;



  }/* measurement_class of */



  /* result > some number */

  /*  result > some number  */

  /* result < some number */

  /*  result < some number  */

  /* result > some number */

  /* result > some number */



  /*  result < some number  */

  /* result < some number */

}  /* calculate_alternate_limit */



//------------------------------------------------------------------------------

void t9015(void)

{

  /* Generate an alternate limits file */

  struct LOC_t9015 V;

  int              mod_id;

  char             buffer[81];

  int              next;

  char             modified_limit_file_name[81];

  a_limit_rec*     temp;

  FILE*            limit_file;

  int              loop;

  a_limit_rec*     limit_ptr;

  int              counter;

  char*            str1;



  limit_file = NULL;

  /* ------------------------------------------------------------------------- */

  /* Read in the limits from the limit file. --------------------------------- */

  /* ------------------------------------------------------------------------- */

  display_prompt("Reading Limits ", false);

  counter = 0;

  /* Initialize the limits structure and free any previously read limits */

  free_limits(&V);



  limit_file = fopen(GetAssociatedNameForFileType(LimitsFile), "r+b");



  if (limit_file == NULL)

    limit_file = fopen(GetAssociatedNameForFileType(LimitsFile), "w+");



  if (limit_file == NULL)

  {

    display_prompt("The 'limit_file' was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  while (!P_eof(limit_file))

  {  /* read */

    limit_ptr = static_cast(a_limit_rec*, malloc(sizeof(a_limit_rec)));

    fread(limit_ptr, sizeof(a_limit_rec), 1, limit_file);

    add_sorted_limit(limit_ptr, &V);

    counter++;



    if (counter % LIMITS_PER_DOT == 0)

      prompt_char('.');

  }  /* read */



  if (limit_file != NULL)

    fclose(limit_file);



  limit_file = NULL;



  mod_id = any_module_present();

  flush_commands(mod_id);



  display_prompt("Enter alternate limit value: ", false);

  get_user_answer(buffer, 80);

  V.alternate = strtod(buffer, &str1);

  next = str1 - buffer + 1;



  /* ------------------------------------------------------------------------- */

  /* Write out the limits to the new file. ----------------------------------- */

  /* ------------------------------------------------------------------------- */

  strcpy(modified_limit_file_name, "modified_limit_file");

  limit_file = fopen(modified_limit_file_name, "wb");



  if (limit_file == NULL)

  {

    display_prompt("The 'modified_limit_file' was not found.  Please have sys admin replace.", true);

    _EscIO(FileNotFound);

  }



  force_write("Writing Limits ");

  counter = 0;



  for (loop = FIRST_TEST; loop <= LAST_TEST; loop++)

  {  /*  write  */

    temp = all_limits[loop - FIRST_TEST];



    while (temp != NULL)

    {  /*  to file  */

      switch (temp->test_number)

      {



      case 2101:

        break;



      /* Null case because "makemyver" modifies these limits */

      case 1256:

        if (temp->UU.U4.low_integer_limit == LOW_1256_HALT)

        {

          temp->UU.U4.low_integer_limit = ADJUSTED_LOW_HALT;

          temp->UU.U4.high_integer_limit = ADJUSTED_HIGH_HALT;

        }

        else

          calculate_alternate_limit(temp, &V);

        break;



      case 1060:

        /* Special case because of limit values */

        if ( number_equal(temp->UU.U3.low_real_limit, LOW_1060_STD_DEV) )

        {

          temp->UU.U3.low_real_limit = ADJUSTED_LOW_STD_DEV;

          temp->UU.U3.high_real_limit = ADJUSTED_HIGH_STD_DEV;

        }

        else if ( number_equal(temp->UU.U3.low_real_limit, LOW_1060_F86_DELAY) )

        {

          temp->UU.U3.low_real_limit = ADJUSTED_LOW_F86_DELAY;

          temp->UU.U3.high_real_limit = ADJUSTED_HIGH_F86_DELAY;

        }

        else

          calculate_alternate_limit(temp, &V);

        break;



      default:

        calculate_alternate_limit(temp, &V);

        break;

      }/* case */



      fwrite(temp, sizeof(a_limit_rec), 1, limit_file);

      temp = temp->next;

      counter++;



      if (counter % LIMITS_PER_DOT == 0)

        prompt_char('.');



    }  /*  to file  */

  }  /*  write  */



  if (limit_file != NULL)

    fclose(limit_file);



  limit_file = NULL;

}  /*t9015*/

#undef LIMITS_PER_DOT

#undef LOW_1060_STD_DEV

#undef LOW_1060_F86_DELAY

#undef LOW_1256_HALT

#undef ADJUSTED_LOW_STD_DEV

#undef ADJUSTED_HIGH_STD_DEV

#undef ADJUSTED_LOW_F86_DELAY

#undef ADJUSTED_HIGH_F86_DELAY

#undef ADJUSTED_LOW_HALT

#undef ADJUSTED_HIGH_HALT



/* 2 of 0-8 */

#define MUX_NODE_PIN    2

#define DMM_RANGE       2/* volts */

#define SOURCE_VOLTAGE  0.8e+00

#define DMM_RESOLUTION  1.0e-03

#define WAIT_TIME       10e-03

#define DMM_FUNCTION    DCV

// 150 milliohm correction factor needed to maintain consistency between the

// "5ohm" measurement measured here and the "5ohm load" used in tests

// 9835,9836,9840,9841

// 150mil is approximate value measured on a Fezziwig pincard.  it includes

// 2 relays (KGLx & K3x) and trace resistance

// mjs 9/28/99

//

// Changed to 300 MilliOhm based on initial calculations

// gpm 12/7/99

//

#define RESISTANCE_CORRECTION .300

//------------------------------------------------------------------------------

void t9020(int mod_id, int slot)

{

  // MEASURE/CALCULATE ACTUAL LOAD R FOR AIM 5 OHM LOAD

  double rsource;

  double vsource;

  double vdmm_1;

  double vdmm_2;

  double rload;

  test_result_type result;

  int channel;

  int card_type=0;


  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  card_type = get_testhead_actual_card(mod_id, slot);

  /* determine if card is caribou and put in compatibility mode */

  if ((card_type == CDDP) || (card_type == CDD20) ||

      (card_type == CDD6) || (card_type == CDDJB) ||

      (card_type == CDDU))

  {

    vth_pen_32chan(mod_id, slot);

    vth_pmap_rly(mod_id, slot, 0);

  }



  measure_47_ohm_aim_delta(mod_id, &rsource);

  flush_commands(mod_id); //added fikri 15/5/2024


  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(DMM_RANGE), DMM_RESOLUTION);
  flush_commands(mod_id); //added fikri 15/5/2024

  connect_dmm_pin(mod_id, slot);

  flush_commands(mod_id); //added fikri 15/5/2024


  for (channel = 'A'; channel <= 'H'; channel++)

  {  // for each channel

    vth_asrc_dis_30ma_ilim(mod_id);

    vth_asrc_set_dc_ampl(mod_id, SOURCE_VOLTAGE);



    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

	//vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[0][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[2][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[3][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[4][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[5][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[6][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[8][channel - 'A']);

    close_pin_gnd_relays(mod_id, slot);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, K806);   // SOURCE TO S BUS RELAY



    vth_afc_en_src_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);

    flush_commands(mod_id); //added fikri 15/5/2024
    measure_dmm(mod_id);     // make unloaded measurement of source

    if (get_result_nolog(mod_id, &result))

      vsource = result.UU.Real_result;

    else

    {

      display_prompt("No result in result log (Expected DMM reading)", true);

      vsource = 0.1;

    }



    vth_afc_dis_src_out(mod_id);

	//vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[0][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[2][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[3][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[4][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[5][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[6][channel - 'A']);

    //vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[8][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, KDCG);

    vth_aclose_rly(mod_id, K756);   // 5 ohm load

    vth_aclose_trp_chg_rly(mod_id);   // Aim load common

    vth_afc_en_src_out(mod_id);



    vth_mtmr_wait(mod_id, WAIT_TIME);

    flush_commands(mod_id); //added fikri 15/5/2024
    measure_dmm(mod_id);   // make a 5 ohm loaded measurement

    if (get_result_nolog(mod_id, &result))

      vdmm_1 = result.UU.Real_result;

    else

    {

      display_prompt("No result in result log (Expected DMM reading)", true);

      vdmm_1 = 0.5;

    }



    vth_afc_dis_src_out(mod_id);

    vth_aopen_rly(mod_id, K806);

    vth_aclose_rly(mod_id, K829);   // 47 ohms series source resistor

    vth_afc_en_src_out(mod_id);



    vth_mtmr_wait(mod_id, WAIT_TIME);

    flush_commands(mod_id); //added fikri 15/5/2024
    measure_dmm(mod_id);             // make a 5 ohm loaded measurement with 47 ohm in series

    if (get_result_nolog(mod_id, &result))

      vdmm_2 = result.UU.Real_result;

    else

    {

      display_prompt("No result in result log (Expected DMM reading)", true);

      vdmm_2 = 0.6;

    }



    rload = vdmm_1 * vdmm_2 / vsource * rsource / (vdmm_1 - vdmm_2);

    rload = rload - RESISTANCE_CORRECTION;  //see comment at top -- mjs



    //##### added by SRI for debugging purposes only!Sep 2nd 2009########



	//printf("\nFor channel : %d\n", channel);

	//printf("\nActual VDMM_1 is  :  %e\n", vdmm_1);

	//printf("\nActual VDMM_2 is  :  %e\n", vdmm_2);

	//printf("\nActual VSOURCE is :  %e\n", vsource);

	//printf("\nActual RSOURCE is :  %e\n", rsource);



	///////////////////////



    load_5_ohm_resistance[mod_id][slot - 1][channel - 'A'] = rload;

    flush_commands(mod_id);  //added fikri 15/5/2024
    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = rload;

    log_result(mod_id, result);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_popen_rly(mod_id, slot, KDCG);

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, K829);   // 47 ohms series source resistor



  }  // for each channel





  for (channel = 'A'; channel <= 'H'; channel++)

  {  // for each channel

    // inserted a value to make these subtests pass-  ratio is not

    // measured with the non-scope version -- mjs

    result.UU.Real_result = 1.01;

       //    result.UU.Real_result = load_5_ohm_ratio[mod_id][slot - 1][channel - 'A'];

    log_result(mod_id, result);

  }  // for each channel

  flush_commands(mod_id); //added fikri 15/5/2024


  for (channel = 'A'; channel <= 'H'; channel++)

  {  // for each channel

    // inserted a value to make these subtests pass-  ratio is not

    // measured with the non-scope version -- mjs

    result.UU.Real_result = 1.01;

       //    result.UU.Real_result = no_load_5_ohm_ratio[mod_id][slot - 1][channel - 'A'];

    log_result(mod_id, result);

  }  // for each channel



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  // t9020

#undef MUX_NODE_PIN

#undef DMM_RANGE

#undef SOURCE_VOLTAGE

#undef DMM_RESOLUTION

#undef WAIT_TIME

#undef DMM_FUNCTION



#define MUX_NODE_PIN    2

#define DMM_RANGE       2/* volts */

#define SOURCE_VOLTAGE  2.4e+00

#define DMM_RESOLUTION  1.0e-03

#define WAIT_TIME       10e-03

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9021(int mod_id, int slot)

{

  /*MEASURE/CALCULATE ACTUAL LOAD R FOR AIM 24 OHM LOAD*/

  double rsource;

  double vsource;

  double vdmm_1;

  double vdmm_2;

  double rload;



  test_result_type result;

  int channel;



  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  measure_47_ohm_aim_delta(mod_id, &rsource);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(DMM_RANGE), DMM_RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for each channel*/

    vth_asrc_dis_30ma_ilim(mod_id);

    vth_asrc_set_dc_ampl(mod_id, SOURCE_VOLTAGE);



    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    close_pin_gnd_relays(mod_id, slot);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, K806);   /*SOURCE TO S BUS RELAY*/



    vth_afc_en_src_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      vsource = result.UU.Real_result;

    else

    {  /*else*/

      display_prompt("No result in result log (Expected DMM reading)", true);

      vsource = 0.1;

    }  /*else*/



    vth_afc_dis_src_out(mod_id);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, KDCG);

    vth_aclose_rly(mod_id, K755);   /* 24 ohm load */

    vth_aclose_trp_chg_rly(mod_id);   /* Aim load common */

    vth_afc_en_src_out(mod_id);



    vth_mtmr_wait(mod_id, WAIT_TIME);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      vdmm_1 = result.UU.Real_result;

    else

    {  /*else*/

      display_prompt("No result in result log (Expected DMM reading)", true);

      vdmm_1 = 0.5;

    }  /*else*/



    vth_afc_dis_src_out(mod_id);

    vth_aopen_rly(mod_id, K806);

    vth_aclose_rly(mod_id, K829);   /* 47 ohms series source resistor */

    vth_afc_en_src_out(mod_id);



    vth_mtmr_wait(mod_id, WAIT_TIME);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      vdmm_2 = result.UU.Real_result;

    else

    {  /*else*/

      display_prompt("No result in result log (Expected DMM reading)", true);

      vdmm_2 = 0.6;

    }  /*else*/



    vth_afc_dis_src_out(mod_id);



    rload = vdmm_1 * vdmm_2 / vsource * rsource / (vdmm_1 - vdmm_2);

    load_24_ohm_resistance[mod_id][slot - 1][channel - 'A'] = rload;

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = rload;

    log_result(mod_id, result);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, K829);   /* 47 ohms series source resistor */



  }  /*for each channel*/





  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9021*/

#undef MUX_NODE_PIN

#undef DMM_RANGE

#undef SOURCE_VOLTAGE

#undef DMM_RESOLUTION

#undef WAIT_TIME

#undef DMM_FUNCTION



#define BLANK_LINE      ""

#define TIMEOUT         1.00e-03

#define GATE_TIME       0.1e+00

#define START_LEVEL     0.6e+00

#define STOP_LEVEL      0.6e+00

//------------------------------------------------------------------------------

void t9030(int mod_id, int slot)

{

  /*Debug Port 2 Verification*/

  double           cntr_actual_frequency;

  char             buffer[81];

  test_result_type result;

  int              debug_connect_module;

  int              temp_debug_connect_module;



  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();

    OpenResourceManager();
    open_33250A(debug_connect_module);
    //open_mux(debug_connect_module);
	open_34980A(debug_connect_module);

 /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
 	  enable_33250A_out(debug_connect_module);
	  setup_33250A_defaults(debug_connect_module);
  }
  else
      open_syn(debug_connect_module);
  /*--------------------------------------------*/

    open_gen(debug_connect_module);

    open_cntr(debug_connect_module);

    break_test_for_function_step_compatability(debug_connect_module);



    if (get_result_nolog(debug_connect_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Connect the BNC cable from the minerva fixture to", true);

      display_prompt("the DATA debug port (J152C).  Then press <Return> or <Enter>.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    setup_cntr_trg_levels(debug_connect_module, START_LEVEL, STOP_LEVEL);



    connect_gen_trg_clkrb(debug_connect_module);

    connect_cntr_stop_db1(debug_connect_module);

    vth_mmbd_en_arcv(mod_id);

    vth_pen_arcv0(mod_id, slot);



    break_test_for_function_step_compatability(debug_connect_module);



    vth_mseq_stop(debug_connect_module, TIMEOUT);



    vth_pclose_rly(debug_connect_module, slot, KDA);

    vth_pclose_rly(debug_connect_module, slot, KRA);

    vth_pclose_rly(debug_connect_module, slot, K1A);

    vth_pclose_rly(debug_connect_module, slot, K10A);

    vth_mclose_rly(debug_connect_module, MK2306);

        /* DBG2 to Mother Board relay */

    vth_mclose_rly(debug_connect_module, MK2902);

        /* CLKRB to Mint pins relay   */

    vth_mclose_rly(debug_connect_module, MK2903);

        /* CLKRSG to Mint pins relay  */



    vth_mtclk_clkrb_mux(debug_connect_module);

    vth_mdbg_2_arcv0_mux(debug_connect_module);

    vth_mtclk_sel_ris_edge(debug_connect_module);

    break_test_for_function_step_compatability(debug_connect_module);

    /*Added by chuanho to select syn model,14jun2012*/
	/*----------------------------------------------------*/
	if(check_syn_model())
		setup_33250A_freq(debug_connect_module, 5000000);
	else
		setup_syn_freq(debug_connect_module, 5000000);
    /*----------------------------------------------------*/

    enable_gen_out(debug_connect_module);

    connect_syn_out_gen_ext(debug_connect_module);

    vth_mtclk_set_freq(debug_connect_module, 5000000.0, 5000000.0);

    setup_cntr_function(debug_connect_module, FREQUENCY);

    setup_cntr_gate_time(debug_connect_module, GATE_TIME);

    vth_mtmr_wait(debug_connect_module, 0.100);



    sales_reset_sequencer(mod_id, slot);



    break_test_for_function_step_compatability(debug_connect_module);



#include "t9030_vml.cmd"



    break_test_for_function_step_compatability(debug_connect_module);



    vth_pfc_sel_arcv0(mod_id, slot, 0, 1);   /* ARCV0 = GTH */

    sales_start_sequencer(mod_id, slot);

    vth_mtmr_wait(debug_connect_module, 0.100);



    trigger_cntr(debug_connect_module);

    cntr_actual_frequency = read_cntr_mean(debug_connect_module);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_actual_frequency;

    log_result(debug_connect_module, result);



    if (get_result_nolog(debug_connect_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Re-connect BNC cable from the Minerva fixture to", true);

      display_prompt("the CLOCK debug port (J152B). Then press <Return> or <Enter>.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    vth_minit(debug_connect_module);

    vth_pinit(debug_connect_module, slot);



    //close_mux(debug_connect_module);
	close_34980A(debug_connect_module);

	if(check_syn_model())
		close_33250A(debug_connect_module);
	else
        close_syn(debug_connect_module);

    close_gen(debug_connect_module);

    close_cntr(debug_connect_module);

    CloseResourceManager();

  }  /*has debug ports*/



}  /*t9030*/

#undef HIGH

#undef LOW

#undef BLANK_LINE

#undef TIMEOUT

#undef GATE_TIME

#undef START_LEVEL

#undef STOP_LEVEL



#define BLANK_LINE      ""

#define TIMEOUT         1.00e-03

#define GATE_TIME       0.1e+00

#define START_LEVEL     0.6e+00

#define STOP_LEVEL      0.6e+00

//------------------------------------------------------------------------------

void t9031(int mod_id, int slot)

{

  /*Debug Port 0 Verification*/

  double cntr_actual_frequency;



  char buffer[81];

  test_result_type result;

  int debug_connect_module;

  int temp_debug_connect_module;





  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();

    OpenResourceManager(); //added by chuanho, 18jul2011
    open_33250A(debug_connect_module);
    //open_mux(debug_connect_module);
	open_34980A(debug_connect_module);

	/*Added by chuanho to select syn model, 14jun2012*/
	/*--------------------------------------------*/
    if(check_syn_model())
	{
 	    enable_33250A_out(debug_connect_module);
		setup_33250A_defaults(debug_connect_module);
	}
    else
        open_syn(debug_connect_module);
    /*--------------------------------------------*/

    open_gen(debug_connect_module);

    open_cntr(debug_connect_module);

    break_test_for_function_step_compatability(debug_connect_module);



    if (get_result_nolog(debug_connect_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Connect the BNC cable from the Minerva fixture to", true);

      display_prompt("the SYNC debug port (J152A).  Then press <Return> or <Enter>.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    setup_cntr_trg_levels(debug_connect_module, START_LEVEL, STOP_LEVEL);



    connect_gen_trg_clkrb(debug_connect_module);

    connect_cntr_stop_db1(debug_connect_module);

    vth_mmbd_en_arcv(mod_id);

    vth_pen_arcv0(mod_id, slot);



    break_test_for_function_step_compatability(debug_connect_module);



    vth_mseq_stop(debug_connect_module, TIMEOUT);



    vth_pclose_rly(debug_connect_module, slot, KDA);

    vth_pclose_rly(debug_connect_module, slot, KRA);

    vth_pclose_rly(debug_connect_module, slot, K1A);

    vth_pclose_rly(debug_connect_module, slot, K10A);

    vth_mclose_rly(debug_connect_module, MK2304);

        /* DBG0 to Mother Board relay */

    vth_mclose_rly(debug_connect_module, MK2902);

        /* CLKRB to Mint pins relay   */

    vth_mclose_rly(debug_connect_module, MK2903);

        /* CLKRSG to Mint pins relay  */



    vth_mtclk_clkrb_mux(debug_connect_module);

    vth_mdbg_0_sclk_mux(debug_connect_module);

    vth_mtclk_sel_ris_edge(debug_connect_module);

    break_test_for_function_step_compatability(debug_connect_module);

    /*Added by chuanho to select syn model*/
	/*----------------------------------------------------*/
	if(check_syn_model())
		setup_33250A_freq(debug_connect_module, 5000000);
	else
		setup_syn_freq(debug_connect_module, 5000000);
    /*----------------------------------------------------*/

    connect_syn_out_gen_ext(debug_connect_module);

    vth_mtclk_set_freq(debug_connect_module, 5000000.0, 5000000.0);

    setup_cntr_function(debug_connect_module, FREQUENCY);

    setup_cntr_gate_time(debug_connect_module, GATE_TIME);

    vth_mtmr_wait(debug_connect_module, 0.100);



    sales_reset_sequencer(mod_id, slot);



    break_test_for_function_step_compatability(debug_connect_module);



#include "t9030_vml.cmd"



    break_test_for_function_step_compatability(debug_connect_module);



    vth_pfc_sel_arcv0(mod_id, slot, 0, 1);   /* ARCV0 = GTH */

    sales_start_sequencer(mod_id, slot);

    vth_mtmr_wait(debug_connect_module, 0.100);



    trigger_cntr(debug_connect_module);

    cntr_actual_frequency = read_cntr_mean(debug_connect_module);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_actual_frequency;

    log_result(debug_connect_module, result);



    if (get_result_nolog(debug_connect_module, &result))

      display_prompt("Unexpected result encountered!", true);

    else

    {  /*else*/

      display_prompt(BLANK_LINE, true);

      display_prompt("Re-connect BNC cable from the minerva fixture to", true);

      display_prompt("the CLOCK debug port(J152A).  Then press <Return> or <Enter>.", true);

      display_prompt(BLANK_LINE, true);

      get_user_answer(buffer, 80);

    }  /*else*/



    vth_minit(debug_connect_module);

    vth_pinit(debug_connect_module, slot);



    //close_mux(debug_connect_module);
	close_34980A(debug_connect_module);

	if(check_syn_model())
		close_33250A(debug_connect_module);
	else
		close_syn(debug_connect_module);

    close_gen(debug_connect_module);

    close_cntr(debug_connect_module);

    CloseResourceManager();

  }  /*has debug ports*/



}  /*t9031*/

#undef BLANK_LINE

#undef TIMEOUT

#undef GATE_TIME

#undef START_LEVEL

#undef STOP_LEVEL



#define BLANK_LINE      ""

/* No 30mA current compliance */

#define SRC_I_COMPLIANCE  1

/* No additional ouput R */

#define SRC_R_OUT       0

/* Source enabled */

#define SRC_ON          1

/* SRC controlled by processor */

#define SRC_CONTROL     0

#define SAMPLE_SIZE     10

#define FREQ_A          20000

/* filter no. 7 for 8192Hz */

#define PEAK_VOLTS      4.0e+00

#define DC_OFFSET       0.0e+00

#define TRIGGER_LEVEL   0.0e+00

/*seconds*/

#define SOURCE_WAIT_TIME  1.0e-03

//------------------------------------------------------------------------------

void t9032(int mod_id, int /* slot */)

{

  /* AF1 PORT VERIFICATION */



  /* This test uses the setup for test 9393 to verify the AF1 cable         */

  /* continuity.  The test uses the counter to measure the ARB Source Freq. */

  /* For path and test descriptions, see the documentation for test: 9032   */

  int current;

  int next;

  double cntr_actual_freq;

  char s[81];

  char buffer[81];

  test_result_type result;





  open_cntr(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);


//mjs -- added this to make sure that the analog fixture is in place for this test

  /* Lock fixture in place */

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();



  /* Even though it's really AF1, the same minerva relays will be closed. */

  aconnect_cntr_stop_af2(mod_id);



  break_test_for_function_step_compatability(mod_id);



  if (get_result_nolog(mod_id, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/

    display_prompt(BLANK_LINE, true);



    /* Build the module number string for display */

    *s = '\0';

    strcat(s, "For Module: ");

    current = mtd_strlen(s) + 1;

    sprintf(s + current - 1, "%d", mod_id);

    next = mtd_strlen(s) + 1;

    strcat(s, ":");



    display_prompt("\007", true);   /* '#7' should cause a beep */

    display_prompt(s, true);

    display_prompt("Connect the BNC end of the AF1 cable to", true);

    display_prompt("the minerva BNC for that module.", true);

    display_prompt(BLANK_LINE, true);

    display_prompt("Then press <Return> or <Enter>...", true);

    display_prompt(BLANK_LINE, true);

    get_user_answer(buffer, 80);

  }  /*else*/



  vth_aclose_rly(mod_id, K806);   /* SRCOUT to S bus relay */

  vth_aclose_rly(mod_id, K751);   /* S bus to A_XL relay */

  vth_aclose_rly(mod_id, K764);   /* A_XL to AF2 relay */

  vth_aclose_rly(mod_id, K757);   /* AF2 to TRIGIN relay */

  vth_aclose_rly(mod_id, K763);   /* TRIGIN AF1 relay */



  setup_cntr_trg_levels(mod_id, TRIGGER_LEVEL, TRIGGER_LEVEL);

  setup_cntr_function(mod_id, FREQUENCY);

  setup_cntr_sample_size(mod_id, SAMPLE_SIZE);



  vth_src_sqr_setup(mod_id, FREQ_A, PEAK_VOLTS, DC_OFFSET, SRC_I_COMPLIANCE,

                SRC_R_OUT, SRC_ON, SRC_CONTROL);

  vth_mtmr_wait(mod_id, SOURCE_WAIT_TIME);

  trigger_cntr(mod_id);

  break_test_for_function_step_compatability(mod_id);

  cntr_actual_freq = read_cntr_mean(mod_id);

  result.Measurement_class = CLASS_REAL;

  result.UU.Real_result = cntr_actual_freq;

  log_result(mod_id, result);



  vth_afc_dis_src_out(mod_id);



  vth_ainit(mod_id);



  if (get_result_nolog(mod_id, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/

    display_prompt(BLANK_LINE, true);



    /* Build the module number string for display */

    *s = '\0';

    strcat(s, "For Module: ");

    current = mtd_strlen(s) + 1;

    sprintf(s + current - 1, "%d", mod_id);

    next = mtd_strlen(s) + 1;

    strcat(s, ":");



    display_prompt("\007", true);   /* '#7' should cause a beep */

    display_prompt(s, true);

    display_prompt("Re-connect the BNC end of the AF2 cable to", true);

    display_prompt("the minerva BNC for that module.", true);

    display_prompt(BLANK_LINE, true);

    display_prompt("Then press <Return> or <Enter>...", true);

    display_prompt(BLANK_LINE, true);

    get_user_answer(buffer, 80);

  }  /*else*/



  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9032 */

#undef BLANK_LINE

#undef SRC_I_COMPLIANCE

#undef SRC_R_OUT

#undef SRC_ON

#undef SRC_CONTROL

#undef SAMPLE_SIZE

#undef FREQ_A

#undef PEAK_VOLTS

#undef DC_OFFSET

#undef TRIGGER_LEVEL

#undef SOURCE_WAIT_TIME



#define DCLK_FREQUENCY  2000000

#define WAIT_TIME       0.5e+00

/* Parameter for atrig_out_sel */

#define ADRV0           1

/* Parameter for afc_sel_ft0 */

#define PDTRGIN         1

/* Select channel 0 */

#define AFC_CHANNEL     0

#define AFC_SIGNAL      0

/* Readings to average */

#define AVERAGES        1

/* Type 6 = frequency */

#define DET_TYPE        6

//------------------------------------------------------------------------------

void t9033(int mod_id, int /* slot */)

{

  /*ASRU DTRIG PORT(S) VERIFICATION*/

  test_result_type result;





  break_test_for_function_step_compatability(mod_id);



  if (get_result_nolog(mod_id, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/

    /* Setup DUTCLK and soute signal to MAC din connector */

    vth_mmbd_en_adrv(mod_id);

    vth_mdclk_0_set_freq(mod_id, static_cast<double>(DCLK_FREQUENCY));

    vth_mseq_neg_cpu_tsp(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    /* Setup path from ASRU din to DTRGOUT */

    vth_atrig_out_sel(mod_id, ADRV0);

    vth_aclose_rly(mod_id, K766);   /* TRIG OUT to DTRIGOUT relay */



    /* Setup path from DTRIGIN to ASRU din out */

    vth_afc_sel_gt0(mod_id, PDTRGIN);

    vth_afc_sel_arcv0(mod_id, AFC_CHANNEL, AFC_SIGNAL);

    vth_aarcv0_en(mod_id);



    /* Setup the path from MAC din to TICB */

    vth_mmbd_en_arcv(mod_id);

    vth_mclose_rly(mod_id, MK1601);   /* TIC_AMUX to TIC_A relay */

    vth_mtic_a_arcv0_mux(mod_id);



    /* Measure the frequency to verify the DTRG paths */

    /* Use friendly routines */

    vth_ameas_set_averaging(mod_id, AVERAGES);

    vth_afunc_store_det_type(mod_id, DET_TYPE);

    vth_afunc_meas(mod_id);

    vth_get_afunc_result(mod_id);



    /* Log the result */

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected TIC reading)", true);

    /* Don't log the status */

    if (!get_result_nolog(mod_id, &result))

      display_prompt("No result in result log (Expected TIC status)", true);

  }  /*else*/



}  /*t9033*/

#undef DCLK_FREQUENCY

#undef WAIT_TIME

#undef ADRV0

#undef PDTRGIN

#undef AFC_CHANNEL

#undef AFC_SIGNAL

#undef AVERAGES

#undef DET_TYPE



/////////////////new test added 9th March 2016- detect heron P3-with logic check for card id///////////////////
#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL_HI   2.0e+00   /* drive hi level */

#define VOLTAGE_LEVEL_LO   0.0e+00   /* drive hi level */

#define DMM_FUNCTION    DCV


void t9034(int mod_id, int  slot )
{

  int channel_no;

  int driver;

  integer spike;

  int HeronP5_sales =0;

  vth_pin_card_is_heron_p5(mod_id, slot);

  HeronP5_sales = vt_receive_integer();


  if (HeronP5_sales == 1)  //if Heron P5 detected then only execute
  {
	  OpenResourceManager();//chun 08032022
	  //open_mux(mod_id);
	  open_34980A(mod_id);

	  open_cntr(mod_id);
	  //open_53230A(mod_id);

	  test_result_type result;

	  aconnect_osc_ch1_af2(mod_id);

	 ///////////////////////////VERIFY TEST SETUP CONNECTION COUNTER WITH NASRU/////////////////////////

	  driver = 'A';

	  channel_no = driver - 'A';

	  vth_aopen_all_rlys(mod_id);

	  vth_popen_all_rlys(mod_id, slot);

	  vth_mtmr_wait(mod_id, 0.5);

	  vth_mseq_neg_cpu_tsp(mod_id);

	  vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL_HI);

	  vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL_LO);

	  vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0); ///disable tri-state

	  vth_mhpib_wr(mod_id, 4, "*RST");

	  vth_mtmr_wait(mod_id, 1);


	  vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

	  vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

	  vth_pclose_rly(mod_id, slot, KDCL);//TOWARDS AF2

	  vth_aclose_rly(mod_id, K753);//TOWARDS AF2

	  vth_aclose_rly(mod_id, K764);//TOWARDS AF2

	  vth_mtmr_wait(mod_id, 0.1);

	  //////////////setup counter////////////

	  if (get_53132A_IDN() == true)
	  {
		  vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
		  vth_mtmr_wait(mod_id, 0.5);
		  vth_mhpib_wr(mod_id, 4, ":sense:event1:level:absolute:auto 0");
		  vth_mtmr_wait(mod_id, 0.5);
		  vth_mhpib_wr(mod_id, 4, ":EVENT1:LEVEL 0.5");
		  vth_mtmr_wait(mod_id, 0.5);
		  vth_mhpib_wr(mod_id, 4, ":init:continuous on");
		  vth_mtmr_wait(mod_id, 0.5);

		  /*
		  vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
		  vth_mtmr_wait(mod_id, 2.0);//0.5);
		  vth_mhpib_wr(mod_id, 4, ":SENSe:EVENt1:LEVel:ABSolute:AUTO 0");
		  vth_mtmr_wait(mod_id, 2.0);//0.5);
		  vth_mhpib_wr(mod_id, 4, ":EVENt1:LEVel 0.5");
		  vth_mtmr_wait(mod_id, 2.0);//0.5);
		  vth_mhpib_wr(mod_id, 4, ":INIT:CONTinuous ON");
		  vth_mtmr_wait(mod_id, 2.0);//0.5);
		  */
	  }
	  else if (get_53230A_IDN() == true)
	  {
		  setup_counter_53230A_conf_total_cont();
		  vth_mtmr_wait(mod_id, 0.5);

		  setup_counter_53230A_inp_lev_0p5();
		  vth_mtmr_wait(mod_id, 0.5);

		  //setup_counter_53230A_inp_slop_neg();
		  //vth_mtmr_wait(mod_id, 0.5);

		  setup_counter_53230A_init();
		  vth_mtmr_wait(mod_id, 0.5);

		  //setup_counter_E4980AL_event1_level_0d35();
		  //vth_mtmr_wait(mod_id, 0.5);

		  //setup_counter_E4980AL_init_continuous_on();
		  //vth_mtmr_wait(mod_id, 0.5);
	  }

	  vth_mtmr_wait(mod_id, 0.5);
	  //////////////////////////////////////


	  for (int loop = 1; loop < 100; loop++)
	  {

		  vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

		  vth_mtmr_wait(mod_id, 0.0001);

		  vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);
	  }


	  //////////////read counter///////////
	if(get_53132A_IDN()==true)
	{
		vth_mhpib_wr(mod_id, 4, ":init:continuous off");
		vth_mtmr_wait(mod_id, 0.5);
		spike = read_cntr(mod_id);
	}
	if (get_53230A_IDN() == true)
	{
		//setup_counter_E4980AL_init_continuous_off();
		//vth_mhpib_wr(mod_id, 4, ":INIT:CONTinuous OFF");

		//vth_mtmr_wait(mod_id, 0.5);//0.5);

	    //setup_counter_53230A_abort();
	   spike = read_counter_53230A_fetch();//read_cntr(mod_id);

	}

	/////////////////////////////////////


	vth_mseq_ass_cpu_tsp(mod_id);

	result.Measurement_class = CLASS_INTEGER;

	result.UU.Integer_result = spike;

	log_result(mod_id, result);


    if(spike==0)
	{
		display_prompt("Counter to NASRU test setup having issue, pls. verify and re-run test!!!", true);
    }

  //////////////////////////////END OF SETUP VERIFICATION/////////////////////////////////////////////////

	else{////test setup has no issue proceed testing


	for(driver ='A'; driver <= 'H'; driver++)
	{

    //driver = 'A';

    channel_no = driver - 'A';

	vth_aopen_all_rlys(mod_id);

    vth_popen_all_rlys(mod_id, slot);

	vth_mtmr_wait(mod_id, 0.5);

    vth_mseq_neg_cpu_tsp(mod_id);

	vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL_HI);

	vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL_LO);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0); ///disable tri-state

	vth_mhpib_wr(mod_id, 4, "*RST");

	vth_mtmr_wait(mod_id, 1);


	for(int loop=1;loop<100;loop++)
	{

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

	vth_mtmr_wait(mod_id, 0.0001);

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);
	}


	vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, KDCL);//TOWARDS AF2

	vth_aclose_rly(mod_id, K753);//TOWARDS AF2

	vth_aclose_rly(mod_id, K764);//TOWARDS AF2

	vth_mtmr_wait(mod_id, 0.1);

    //////////////setup counter////////////
	if (get_53132A_IDN() == true)
	{
		vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
		vth_mtmr_wait(mod_id, 0.5);
		vth_mhpib_wr(mod_id, 4, ":sense:event1:level:absolute:auto 0");
		vth_mtmr_wait(mod_id, 0.5);
		vth_mhpib_wr(mod_id, 4, ":EVENT1:LEVEL 0.35");
		vth_mtmr_wait(mod_id, 0.5);
		vth_mhpib_wr(mod_id, 4, ":init:continuous on");
		vth_mtmr_wait(mod_id, 0.5);


		/*
		vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
		vth_mtmr_wait(mod_id, 2.0);//0.5);
		vth_mhpib_wr(mod_id, 4, ":SENSe:EVENt1:LEVel:ABSolute:AUTO 0");
		vth_mtmr_wait(mod_id, 2.0);//0.5);
		vth_mhpib_wr(mod_id, 4, ":EVENt1:LEVel 0.35");
		vth_mtmr_wait(mod_id, 2.0);//0.5);
		vth_mhpib_wr(mod_id, 4, ":INIT:CONTinuous ON");
		vth_mtmr_wait(mod_id, 2.0);//0.5);
		*/
	}
	else if (get_53230A_IDN() == true)
	{
		setup_counter_53230A_conf_total_cont();
		vth_mtmr_wait(mod_id, 0.5);

		setup_counter_53230A_inp_lev_0p5();
		vth_mtmr_wait(mod_id, 0.5);

		//setup_counter_53230A_inp_slop_neg();
		//vth_mtmr_wait(mod_id, 0.5);

		setup_counter_53230A_init();
		vth_mtmr_wait(mod_id, 0.5);

		/*setup_counter_E4980AL_event1_level_0d35();
		vth_mtmr_wait(mod_id, 0.5);

		setup_counter_E4980AL_init_continuous_on();
		vth_mtmr_wait(mod_id, 0.5);*/
	}


	//////////////////////////////////////


	vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 1);


	//////////////read counter///////////
	if (get_53132A_IDN() == true)
	{
		vth_mhpib_wr(mod_id, 4, ":init:continuous off");
		//vth_mhpib_wr(mod_id, 4, ":INIT:CONTinuous OFF");
		vth_mtmr_wait(mod_id, 0.5);//0.5);
		spike = read_cntr(mod_id);
	}
	else if (get_53230A_IDN() == true)
	{
		//setup_counter_E4980AL_init_continuous_off();
		//vth_mtmr_wait(mod_id, 0.5);//0.5);
		//setup_counter_53230A_abort();
		vth_mtmr_wait(mod_id, 0.5);
		spike = read_counter_53230A_fetch();//read_cntr(mod_id);
	}


	/////////////////////////////////////


	vth_mseq_ass_cpu_tsp(mod_id);

	result.Measurement_class = CLASS_INTEGER;

	result.UU.Integer_result = spike;

	log_result(mod_id, result);

	}

}///if else ending

	vth_pinit(mod_id, slot);

	close_34980A(mod_id);//close_mux(mod_id);

	//close_53230A(mod_id);
	close_cntr(mod_id);

	CloseResourceManager();//chun 08032022
	}// T9034 execution based on CARD ID

}  /*t9034*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL_HI   /* drive hi level */

#undef VOLTAGE_LEVEL_LO   /* drive hi level */

#undef DMM_FUNCTION



///////////////////////////////////added T9035-without logic/////////////////////////////////


#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL_HI   2.0e+00   /* drive hi level */

#define VOLTAGE_LEVEL_LO   0.0e+00   /* drive hi level */

#define DMM_FUNCTION    DCV


void t9035(int mod_id, int  slot )

{

  int channel_no;

  int driver;

  integer spike;


  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  test_result_type result;

  aconnect_osc_ch1_af2(mod_id);


  ///////////////////////////VERIFY TEST SETUP CONNECTION COUNTER WITH NASRU/////////////////////////

    driver = 'A';

    channel_no = driver - 'A';

	vth_aopen_all_rlys(mod_id);

    vth_popen_all_rlys(mod_id, slot);

	vth_mtmr_wait(mod_id, 0.5);

    vth_mseq_neg_cpu_tsp(mod_id);

	vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL_HI);

	vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL_LO);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0); ///disable tri-state

	vth_mhpib_wr(mod_id, 4, "*RST");

	vth_mtmr_wait(mod_id, 1);


	vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, KDCL);//TOWARDS AF2

	vth_aclose_rly(mod_id, K753);//TOWARDS AF2

	vth_aclose_rly(mod_id, K764);//TOWARDS AF2

	vth_mtmr_wait(mod_id, 0.1);

    //////////////setup counter////////////

	vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
	vth_mtmr_wait(mod_id, 0.5);
    vth_mhpib_wr(mod_id, 4, ":sense:event1:level:absolute:auto 0");
	vth_mtmr_wait(mod_id, 0.5);
	vth_mhpib_wr(mod_id, 4, ":EVENT1:LEVEL 0.5");
	vth_mtmr_wait(mod_id, 0.5);
	vth_mhpib_wr(mod_id, 4, ":init:continuous on");
    vth_mtmr_wait(mod_id, 0.5);


	//////////////////////////////////////


	for(int loop=1;loop<100;loop++)
	{

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

	vth_mtmr_wait(mod_id, 0.0001);

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);
	}


	//////////////read counter///////////

	vth_mhpib_wr(mod_id, 4, ":init:continuous off");
	vth_mtmr_wait(mod_id, 0.5);
	spike = read_cntr(mod_id);


	/////////////////////////////////////


	vth_mseq_ass_cpu_tsp(mod_id);

	result.Measurement_class = CLASS_INTEGER;

	result.UU.Integer_result = spike;

	log_result(mod_id, result);


    if(spike==0)
	{
	display_prompt("Counter to NASRU test setup having issue, pls. verify and re-run test!!!", true);

    }

  //////////////////////////////END OF SETUP VERIFICATION/////////////////////////////////////////////////

	else{////test setup has no issue proceed testing


	for(driver ='A'; driver <= 'H'; driver++)
	{

    //driver = 'A';

    channel_no = driver - 'A';

	vth_aopen_all_rlys(mod_id);

    vth_popen_all_rlys(mod_id, slot);

	vth_mtmr_wait(mod_id, 0.5);

    vth_mseq_neg_cpu_tsp(mod_id);

	vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL_HI);

	vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL_LO);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0); ///disable tri-state

	vth_mhpib_wr(mod_id, 4, "*RST");

	vth_mtmr_wait(mod_id, 1);


	for(int loop=1;loop<100;loop++)
	{

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

	vth_mtmr_wait(mod_id, 0.0001);

	vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);
	}


	vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

	vth_pclose_rly(mod_id, slot, KDCL);//TOWARDS AF2

	vth_aclose_rly(mod_id, K753);//TOWARDS AF2

	vth_aclose_rly(mod_id, K764);//TOWARDS AF2

	vth_mtmr_wait(mod_id, 0.1);

    //////////////setup counter////////////

	vth_mhpib_wr(mod_id, 4, ":CONFigure:TOTalize:CONTinuous");
	vth_mtmr_wait(mod_id, 0.5);
    vth_mhpib_wr(mod_id, 4, ":sense:event1:level:absolute:auto 0");
	vth_mtmr_wait(mod_id, 0.5);
	vth_mhpib_wr(mod_id, 4, ":EVENT1:LEVEL 0.35");
	vth_mtmr_wait(mod_id, 0.5);
	vth_mhpib_wr(mod_id, 4, ":init:continuous on");
    vth_mtmr_wait(mod_id, 0.5);


	//////////////////////////////////////


	vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 1);


	//////////////read counter///////////

	vth_mhpib_wr(mod_id, 4, ":init:continuous off");
	vth_mtmr_wait(mod_id, 0.5);
	spike = read_cntr(mod_id);


	/////////////////////////////////////


	vth_mseq_ass_cpu_tsp(mod_id);

	result.Measurement_class = CLASS_INTEGER;

	result.UU.Integer_result = spike;

	log_result(mod_id, result);

	}

}///if else ending

	vth_pinit(mod_id, slot);

	close_34980A(mod_id);//close_mux(mod_id);

	close_cntr(mod_id);



}  /*t9035*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL_HI   /* drive hi level */

#undef VOLTAGE_LEVEL_LO   /* drive hi level */

#undef DMM_FUNCTION




////////////////////////////////////////////////////////////////////////////////




#define BLANK_LINE      ""

#define SLEW_RATE       225/*v/uS*/

#define GEN_LOW         0.1e+00

#define GEN_HIGH        1.75e+00

#define SYN_FREQ__      10000000

#define PULSE_WIDTH     50e-09

#define TIMEBASE_SENS   2.0e-09

//------------------------------------------------------------------------------

void t9040(int mod_id, int /* slot */)

{

  /*Time Interval Measurement Verification */

  boolean error_detected;

  boolean restarted;

  double transition_time;

  test_result_type result;

  int osc_chan;

  char buffer[81];

  double res[2][2];

  OpenResourceManager(); //added by chuanho, 18jul2011
  open_33250A(mod_id);
  //open_mux(mod_id);
  open_34980A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

//  open_delay_osc(mod_id);

  transition_time = (GEN_HIGH - GEN_LOW) * 0.8 * 1e-06 / SLEW_RATE;

  restarted = false;

_L9999:

  error_detected = false;

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH);

  setup_gen_pwidth(mod_id, PULSE_WIDTH);

  setup_gen_transition_times(mod_id, transition_time);

  	/*Added by chuanho to select syn model, 14jun2012*/
	/*--------------------------------------------*/
    if(check_syn_model())
		setup_33250A_freq(mod_id, SYN_FREQ__);
	else
		setup_syn_freq(mod_id, SYN_FREQ__);
    /*--------------------------------------------*/

  connect_syn_out_gen_ext(mod_id);

  enable_gen_out(mod_id);

  if (get_result_nolog(mod_id, &result))

    display_prompt("Unexpected result encountered!", true);

  else

  {  /*else*/



/*Use this section for troubleshooting, it saves scope setup so you can recall it.*/

/*  display_prompt("\007", true);   //'#7' should cause a beep

    display_prompt(BLANK_LINE, true);

    vth_mhpib_wr(mod_id, 8, "SAVE 9");

    display_prompt("Disconnect cable from output of 8110 OUTPUT", true);

    display_prompt("Connect Oscilloscope Channel A and B directly ", true);

    display_prompt("to the output unterminated, balance the probes  ", true);

    display_prompt("using RECALL SETUP 0 & 1, then press <Return> or <Enter> ", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    vth_mhpib_wr(mod_id, 8, "RECALL 9");

    get_user_answer(buffer, 80);

    update_status(MEASURING);

*/





    display_prompt("\007", true);   // '#7' should cause a beep

    display_prompt(BLANK_LINE, true);

    display_prompt("Disconnect cable from output of pulse generator OUTPUT", true);

    display_prompt("Connect Oscilloscope Channel A and B directly ", true);

    display_prompt("to the output unterminated using matched high ", true);

    display_prompt("frequency probing techniques and press <Return> or <Enter> ", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



  }  /*else*/

  for (int edge = RISING; edge <= FALLING; ++edge)

  {

    for (osc_chan = 1; osc_chan <= 2; osc_chan++)

    {

      res[edge]

        [osc_chan - 1] = measure_td(mod_id, 0.0, osc_chan, edge, POST, edge,

                                    TIMEBASE_SENS);

      if (res[edge][osc_chan - 1] == 9999)

        error_detected = true;

    }



  }





  if (error_detected && !restarted)

  {

    display_prompt("\007", true);   /* '#7' should cause a beep */

    display_prompt(BLANK_LINE, true);

    display_prompt("Error detected in Time Interval measurement", true);

    display_prompt("recheck your connections and start again by", true);

    display_prompt("pressing <Return> or <Enter> ( 2 tries only! )", true);

    display_prompt(BLANK_LINE, true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);

    restarted = true;

    goto _L9999;

  }



  for (edge = RISING; edge <= FALLING; ++edge)

  {

    for (osc_chan = 0; osc_chan <= 1; osc_chan++)

    {

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = res[edge][osc_chan];

      log_result(mod_id, result);

    }



  }





  display_prompt("\007", true);   /* '#7' should cause a beep */

  display_prompt(BLANK_LINE, true);

  display_prompt("Reconnect the cable to the 8110 OUTPUT then press <Return> or <Enter>", true);

  display_prompt(BLANK_LINE, false);

  update_status(WAITING);

  get_user_answer(buffer, 80);

  disable_gen_out(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  CloseResourceManager();

//  close_delay_osc(mod_id);



}  /* t9040 */

#undef BLANK_LINE

#undef SLEW_RATE

#undef GEN_LOW

#undef GEN_HIGH

#undef SYN_FREQ__

#undef PULSE_WIDTH

#undef TIMEBASE_SENS



#define TIMEOUT         1e-03

#define TCLK_FREQ       5.0e+06

#define BLANK_LINE      ""

#define WAIT_TIME       0.3

#define RISING_EDGE     1

#define MUX_NODE_PIN    7

#define TEST_CHAN       'A'

#define NEXT_CHAN       'B'

#define SLEW_RATE       225/*V/uS*/

#define GEN_LOW_UNTERMINATED  0.1e+00

#define GEN_HIGH_UNTERMINATED  1.75e+00

#define GEN_LOW_TERMINATED  0.2e+00

#define GEN_HIGH_TERMINATED  3.5e+00

#define TIMEBASE_SENS   2.0e-09

#define COARSE_TIMEBASE 2.0E-08

//------------------------------------------------------------------------------

void t9041(int mod_id, int slot)

{

  /* System delay constant measurements */

  boolean error_detected;

  boolean restarted;

  double transition_time;

  double temp;

  test_result_type result;

  int current_position;

  int next_position;

  char s[81];

  char buffer[81];

  char comment[81];

  double probe_to_clkrb_falling;

  double probe_to_clkrb_rising;

  double start_to_stop_112_rising;

  double start_to_stop_112_falling;

  double start_to_stop_lin_falling;

  double start_to_stop_lin_rising;

  double start_to_stop_rising;

  double start_to_stop_falling;

  double af2_to_stop_rising;

  double af2_to_stop_falling;

  double clkrb_to_af2_rising;

  double clkrb_to_af2_falling;

  double clkrb_to_stop;

  double start_to_stop_85;

  int probe_id;

  database_system clkrb_delay;

  database_system af2_start_delay;

  database_system af2_clkrb_delay;

  database_system probe_clkrb_delay;

  char *s_ptr;

  char rack_serial_number[81];

  FILE *rack_delays;

  int a_module;

  char str1[81];

  char *p2c_temp;

  double coarse_delay;

  OpenResourceManager(); //added by chuanho, 18jul2011
  open_33250A(mod_id);
  rack_delays = NULL;

  //open_mux(mod_id);
  open_34980A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  open_delay_osc(mod_id);

  open_cntr(mod_id);

  vth_mhpib_wr(mod_id, 8, "CH 1 SENS .7 OFFS 1.0"); //changed to fix 9041

  open_cntr(mod_id); // this was added to fix this test-- setup_gen_trg_out_delay

                     // needs the cntr to setup and calibrate a delay



  probe_id = get_system_probe_location();

  transition_time = (GEN_HIGH_TERMINATED - GEN_LOW_TERMINATED) * 0.8 * 1e-06 / SLEW_RATE;

  get_mux_serial_number(mod_id);



  if (get_result_nolog(mod_id, &result))

  {

    result.Measurement_class = CLASS_PSTRING_PTR;

    s_ptr = static_cast(char*,result.UU.Pstring_ptr);

    strcpy(rack_serial_number, s_ptr);



    /* The following line strips the quotation marks from either side of the S/N */

    if (mtd_strlen(rack_serial_number) > 11)

    {

      sprintf(str1, "%.10s", rack_serial_number + 1);

      strcpy(rack_serial_number, str1);

    }

  }

  else

    display_prompt("No result in result log (Expected mux s/n)", true);



  if (strpos2("A", rack_serial_number, 1) > 0)

  {  /* valid rack */

    rack_delays = fopen(rack_serial_number, "r");



    if (rack_delays == NULL)

    {

      display_prompt("The sales rack serial number file was not found.  Please have sys admin replace.", true);

      _EscIO(FileNotFound);

    }



    for (a_module = 0; a_module <= 3; a_module++)

      read_database_line(rack_delays, &clkrb_delay[a_module]);



    for (a_module = 0; a_module <= 3; a_module++)

      read_database_line(rack_delays, &af2_start_delay[a_module]);



    for (a_module = 0; a_module <= 3; a_module++)

      read_database_line(rack_delays, &af2_clkrb_delay[a_module]);



    for (a_module = 0; a_module <= 3; a_module++)

      read_database_line(rack_delays, &probe_clkrb_delay[a_module]);



    fgets(comment, 81, rack_delays);

    p2c_temp = strchr(comment, '\n');



    if (p2c_temp != NULL)

      *p2c_temp = 0;



    if (rack_delays != NULL)

      fclose(rack_delays);



    rack_delays = NULL;



    strcpy(s, "Measuring Delay Constants for System ");

    strcat(s, rack_serial_number);

    strcat(s, " Module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%2d", mod_id);

    next_position = mtd_strlen(s) + 1;

    display_prompt(s, true);

    display_prompt(BLANK_LINE, true);



    restarted = false;

_L1111:

    error_detected = false;



    while (get_result_nolog(mod_id, &result))

      display_prompt("Unexpected result encountered!", true);



    display_prompt("\007", true);   /* '#7' should cause a beep */

    display_prompt(BLANK_LINE, true);

    display_prompt("Connect Measurement Oscilloscope Chan 1 to 5370 Counter", true);

    display_prompt("START input, Chan 2 to 5370 Counter STOP input", true);

    display_prompt("Press <Return> or <Enter> when ready", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);

    connect_syn_out_gen_ext(mod_id);

    setup_gen_levels(mod_id, GEN_LOW_TERMINATED, GEN_HIGH_TERMINATED);

    connect_gen_trg_cntr_start(mod_id);

    connect_gen_out_cntr_stop(mod_id);

    setup_gen_trg_out_delay(mod_id, t9171_delay);

    enable_gen_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041)  coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));



    if (dbg_int==9041)  display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041)  start_to_stop_112_rising = measure_td(mod_id, coarse_delay, 1, RISING, POST, RISING, TIMEBASE_SENS);



    if (dbg_int!=9041)  start_to_stop_112_rising = measure_td(mod_id, t9171_delay, 1, RISING, POST, RISING, TIMEBASE_SENS);



    if (start_to_stop_112_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    complement_gen_out(mod_id);



    if (dbg_int==9041)  coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, FALLING, COARSE_TIMEBASE));



    if (dbg_int==9041)  display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041)  start_to_stop_112_falling = measure_td(mod_id, coarse_delay, 1, RISING, POST, FALLING, TIMEBASE_SENS);



    if (dbg_int!=9041)  start_to_stop_112_falling = measure_td(mod_id, t9171_delay, 1, RISING, POST, FALLING, TIMEBASE_SENS);



    if (start_to_stop_112_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    setup_gen_transition_times(mod_id, transition_time);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, FALLING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) start_to_stop_lin_falling = measure_td(mod_id, coarse_delay, 1, RISING,

                                           POST, FALLING, TIMEBASE_SENS);

    if (dbg_int!=9041) start_to_stop_lin_falling = measure_td(mod_id, t9171_delay, 1, RISING,

                                           POST, FALLING, TIMEBASE_SENS);

    if (start_to_stop_lin_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    no_complement_gen_out(mod_id);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) start_to_stop_lin_rising = measure_td(mod_id, coarse_delay, 1, RISING,

                                          POST, RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) start_to_stop_lin_rising = measure_td(mod_id, t9171_delay, 1, RISING,

                                          POST, RISING, TIMEBASE_SENS);

    if (start_to_stop_lin_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    setup_gen_fixed_transition(mod_id);

    setup_gen_trg_out_delay(mod_id, t9120_delay);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) start_to_stop_85 = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                  RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) start_to_stop_85 = measure_td(mod_id, t9120_delay, 1, RISING, POST,

                                  RISING, TIMEBASE_SENS);

    if (start_to_stop_85 == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    connect_gen_trg_clkrb(mod_id);

    connect_cntr_start_af2(mod_id);



    vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

    vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

    vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

    vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[TEST_CHAN - 'A']);

    vth_pclose_rly(mod_id, slot, KDCL);



    vth_mhsl_1_init_master(mod_id);

    all_modules_but_me(mod_id, &vth_mhsl_1_init_passive);

    vth_mhsl_2_init_master(mod_id);



    all_modules_but_me(mod_id, &vth_mhsl_2_init_passive);

    vth_mdig_set_clkrb_master(mod_id, TCLK_FREQ, TCLK_FREQ, RISING_EDGE);



    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[TEST_CHAN - 'A']);

    sales_reset_sequencer(mod_id, slot);



#include "t9120_nd.cmd"



    sales_start_sequencer(mod_id, slot);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) start_to_stop_rising = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                      RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) start_to_stop_rising = measure_td(mod_id, t9120_res, 1, RISING, POST,

                                      RISING, TIMEBASE_SENS);

    if (start_to_stop_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, FALLING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) start_to_stop_falling = measure_td(mod_id, coarse_delay, 1, FALLING, POST,

                                       RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) start_to_stop_falling = measure_td(mod_id, t9120_res, 1, FALLING, POST,

                                       RISING, TIMEBASE_SENS);

    if (start_to_stop_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    vth_mseq_stop(mod_id, TIMEOUT);



    display_prompt("Move Measurement Oscilloscope Chan 1 to AF2 connector at",

                   true);

    *s = '\0';

    strcat(s, "the rack end of ET27830 Digital Fixture for Module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%2d", mod_id);

    next_position = mtd_strlen(s) + 1;

    display_prompt(s, true);

    display_prompt("Press <Return> or <Enter> when ready", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



    sales_reset_sequencer(mod_id, slot);



#include "t9120_nd.cmd"



    sales_start_sequencer(mod_id, slot);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) af2_to_stop_rising = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                    RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) af2_to_stop_rising = measure_td(mod_id, t9120_af2, 1, RISING, POST,

                                    RISING, TIMEBASE_SENS);

    if (af2_to_stop_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, FALLING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



     if (dbg_int==9041) af2_to_stop_falling = measure_td(mod_id, coarse_delay, 1, FALLING, POST,

                                     RISING, TIMEBASE_SENS);

     if (dbg_int!=9041) af2_to_stop_falling = measure_td(mod_id, t9120_af2, 1, FALLING, POST,

                                     RISING, TIMEBASE_SENS);

    if (af2_to_stop_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    vth_mseq_stop(mod_id, TIMEOUT);



    display_prompt("Move Measurement Oscilloscope Chan 1 to CLKRB, pins 3 and 1",

                   true);

    display_prompt("on slot 6, at the testhead end of ET27830 Digital Fixture",

                   true);

    *s = '\0';

    strcat(s, "for Module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%2d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, "   Press <Return> or <Enter> when ready");

    display_prompt(s, true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



    sales_reset_sequencer(mod_id, slot);



#include "t9120_nd.cmd"



    sales_start_sequencer(mod_id, slot);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



   if (dbg_int==9041)   clkrb_to_stop = measure_td(mod_id, coarse_delay, 1, RISING, POST, RISING,

                               TIMEBASE_SENS);

   if (dbg_int!=9041)   clkrb_to_stop = measure_td(mod_id, t9120_delay, 1, RISING, POST, RISING,

                               TIMEBASE_SENS);

    if (clkrb_to_stop == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    vth_mseq_stop(mod_id, TIMEOUT);

    disable_gen_out(mod_id);

    vth_popen_rly(mod_id, slot, PIN_KD_RLYS[TEST_CHAN - 'A']);



    display_prompt("Move Measurement Oscilloscope Chan 2 to AF2 connector at",

                   true);

    *s = '\0';

    strcat(s, "the rack end of ET27830 Digital Fixture for Module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%2d", mod_id);

    next_position = mtd_strlen(s) + 1;

    display_prompt(s, true);

    display_prompt("Press <Return> or <Enter> when ready", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



    close_pin_gnd_relays(mod_id, slot);

    connect_gen_out_af2(mod_id);

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[TEST_CHAN - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][TEST_CHAN - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN + 1][TEST_CHAN - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[NEXT_CHAN - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][NEXT_CHAN - 'A']);

    setup_gen_trg_out_delay(mod_id, t9171_delay);

    enable_gen_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) clkrb_to_af2_rising = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                     RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) clkrb_to_af2_rising = measure_td(mod_id, t9171_af2, 1, RISING, POST,

                                     RISING, TIMEBASE_SENS);

    if (clkrb_to_af2_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    complement_gen_out(mod_id);

    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, FALLING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) clkrb_to_af2_falling = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                      FALLING, TIMEBASE_SENS);

    if (dbg_int!=9041) clkrb_to_af2_falling = measure_td(mod_id, t9171_af2, 1, RISING, POST,

                                      FALLING, TIMEBASE_SENS);

    if (clkrb_to_af2_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    disable_gen_out(mod_id);



    display_prompt("Move Measurement Oscilloscope Chan 2 to probe connector at",

                   true);

    display_prompt("the rack end of ET27830 Digital Fixture", true);

    display_prompt("Press <Return> or <Enter> when ready", true);

    display_prompt(BLANK_LINE, false);

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



    setup_gen_transition_times(mod_id, transition_time);

    setup_gen_levels(mod_id, GEN_LOW_UNTERMINATED, GEN_HIGH_UNTERMINATED);

    connect_gen_out_probe(mod_id);

    vth_aclose_rly(probe_id, K2203);   /* probe in relay */

    enable_gen_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);



    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, FALLING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) probe_to_clkrb_falling = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                        FALLING, TIMEBASE_SENS);

    if (dbg_int!=9041) probe_to_clkrb_falling = measure_td(mod_id, t9191_probe, 1, RISING, POST,

                                        FALLING, TIMEBASE_SENS);

    if (probe_to_clkrb_falling == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    no_complement_gen_out(mod_id);

    vth_mtmr_wait(mod_id, WAIT_TIME);

    if (dbg_int==9041) coarse_delay = fabs(measure_td(mod_id, 0, 1, RISING, POST, RISING, COARSE_TIMEBASE));

    if (dbg_int==9041) display_it(mod_id, "coarse_delay = ", 0, coarse_delay);



    if (dbg_int==9041) probe_to_clkrb_rising = measure_td(mod_id, coarse_delay, 1, RISING, POST,

                                       RISING, TIMEBASE_SENS);

    if (dbg_int!=9041) probe_to_clkrb_rising = measure_td(mod_id, t9191_probe, 1, RISING, POST,

                                        RISING, TIMEBASE_SENS);

    if (probe_to_clkrb_rising == 9999)

    {

      error_detected = true;

      goto _L9999;

    }



    disable_gen_out(mod_id);



_L9999:

    if (error_detected && !restarted)

    {

      display_prompt("\007", true);   /* '#7' should cause a beep */

      display_prompt(BLANK_LINE, true);

      display_prompt("Error detected in Time Interval measurement", true);

      display_prompt("recheck your connections and start again by", true);

      display_prompt("pressing <Return> or <Enter> ( 2 tries only! )", true);

      display_prompt(BLANK_LINE, true);

      display_prompt(BLANK_LINE, false);

      get_user_answer(buffer, 80);

      restarted = true;

      goto _L1111;

    }

    if (!error_detected)

    {  /* valid delays */

      temp = clkrb_to_stop - start_to_stop_85;

      recalculate_database_line(temp, &clkrb_delay[mod_id]);



      *s = '\0';

      strcat(s, "CLKRB_delay ");

      current_position = mtd_strlen(s) + 1;

      sprintf(s + current_position - 1, "% .6E", temp);

      next_position = mtd_strlen(s) + 1;

      display_prompt(s, true);



      temp = (af2_to_stop_rising - start_to_stop_rising +

              af2_to_stop_falling - start_to_stop_falling) / 2;

      recalculate_database_line(temp, &af2_start_delay[mod_id]);



      *s = '\0';

      strcat(s, "AF2_start_delay ");

      current_position = mtd_strlen(s) + 1;

      sprintf(s + current_position - 1, "% .6E", temp);

      next_position = mtd_strlen(s) + 1;

      display_prompt(s, true);



      temp = (start_to_stop_112_rising - clkrb_to_af2_rising +

              start_to_stop_112_falling - clkrb_to_af2_falling) / 2;

      recalculate_database_line(temp, &af2_clkrb_delay[mod_id]);



      *s = '\0';

      strcat(s, "AF2_CLKRB_delay ");

      current_position = mtd_strlen(s) + 1;

      sprintf(s + current_position - 1, "% .6E", temp);

      next_position = mtd_strlen(s) + 1;

      display_prompt(s, true);



      temp = (start_to_stop_lin_rising - probe_to_clkrb_rising +

              start_to_stop_lin_falling - probe_to_clkrb_falling) / 2;

      recalculate_database_line(temp, &probe_clkrb_delay[mod_id]);



      *s = '\0';

      strcat(s, "probe_CLKRB_delay ");

      current_position = mtd_strlen(s) + 1;

      sprintf(s + current_position - 1, "% .6E", temp);

      next_position = mtd_strlen(s) + 1;

      display_prompt(s, true);



      if (rack_delays != NULL)

        rack_delays = freopen(rack_serial_number, "w", rack_delays);

      else

        rack_delays = fopen(rack_serial_number, "w");

      if (rack_delays == NULL)

      {

        display_prompt("The sales rack serial number file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (a_module = 0; a_module <= 3; a_module++)

        write_database_line(rack_delays, &clkrb_delay[a_module]);

      for (a_module = 0; a_module <= 3; a_module++)

        write_database_line(rack_delays, &af2_start_delay[a_module]);

      for (a_module = 0; a_module <= 3; a_module++)

        write_database_line(rack_delays, &af2_clkrb_delay[a_module]);

      for (a_module = 0; a_module <= 3; a_module++)

        write_database_line(rack_delays, &probe_clkrb_delay[a_module]);

      fprintf(rack_delays, "%s\n", comment);

      if (rack_delays != NULL)

        fclose(rack_delays);

      rack_delays = NULL;

    }  /* valid delays */

    else

      display_prompt("No delays generated due to measurement errors", true);

  }  /* valid rack */

  else

    display_prompt("Need to define sales rack serial number (T9007)", true);

  close_34980A(mod_id);//close_mux(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  close_delay_osc(mod_id);

  close_cntr(mod_id);

  close_cntr(mod_id);  //added to fix this test

  CloseResourceManager();

  if (rack_delays != NULL)

    fclose(rack_delays);

}  /* t9041 */

#undef TIMEOUT

#undef TCLK_FREQ

#undef BLANK_LINE

#undef WAIT_TIME

#undef RISING_EDGE

#undef MUX_NODE_PIN

#undef TEST_CHAN

#undef NEXT_CHAN

#undef SLEW_RATE

#undef GEN_LOW_UNTERMINATED

#undef GEN_HIGH_UNTERMINATED

#undef GEN_LOW_TERMINATED

#undef GEN_HIGH_TERMINATED

#undef TIMEBASE_SENS





typedef int a_mint_pin;

typedef a_mint_pin mint_pin_array['H' + 1 - 'A'];

#define BLANK_LINE      ""

#define CH_2            2

#define CH_1            1

#define RISING_EDGE     1

#define TCLK_FREQ       5.0e+06

#define GEN_LOW_TERMINATED  0.2e+00

#define GEN_HIGH_TERMINATED  3.5e+00

#define TIMEOUT         1.0e-03

#define GEN_DELAY       65e-09

#define DR_AT_AF2_NOMINAL  10e-09

#define RX_AT_AF2_NOMINAL  80e-09

#define DR_AT_MINT_NOMINAL  0e-09

#define RX_AT_MINT_NOMINAL  100e-09

#define TIMEBASE_SENS   5e-09

const mint_pin_array MINT_PIN = {15, 16, 23, 24, 55, 56, 63, 64};

const mint_pin_array GROUND_PIN = {19, 19, 20, 20, 59, 59, 60, 60};

//------------------------------------------------------------------------------

void t9042(int mod_id, int slot)

{

  /*SLOT, CHANNEL, AND RECEIVER DELAY CONSTANT MEASUREMENTS*/

  boolean valid_configuration;

  int pslot;

  int valid_cards;

  char buffer[81];

  char s[81];

  int mux_node_pin;

  int current_position;

  int next_position;



  double dr_at_af2[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_at_af2[NUM_SLOTS]['H' + 1 - 'A'][2];

  double dr_at_mint[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_at_mint[NUM_SLOTS]['H' + 1 - 'A'][2];

  double dr_delta[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_delta[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_only[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_error[NUM_SLOTS]['H' + 1 - 'A'][2];

  double dr_error[NUM_SLOTS]['H' + 1 - 'A'][2];

  double ch_delta[NUM_SLOTS]['H' + 1 - 'A'][2];



  double channel_delay['H' + 1 - 'A'][2];

  double slot_average[NUM_SLOTS][2];

  double av_chan_delay['H' + 1 - 'A'];

  double average_slot_delay[NUM_SLOTS];

  int edge;

  int channel;

  double sum;

  double max_error;

  double av_dr_error;

  double av_rx_error;

  double av_rx_delay;

  double rx_delay[2];



  database_channel channel_data;

  database_slot slot_data;

  database_module receiver_data;

  char comment[81];



  FILE *infile;

  FILE *outfile;

  int p2c_temp;

  char *p2c_temp3;



  outfile = NULL;

  infile = NULL;

  /* CHECK FOR A PIN CARD IN ALL SLOTS */

  valid_configuration = true;

  valid_cards = (1 << PIN) | (1 << PIN6) | (1 << PINTERM) | (1 << PIN20);



  for (pslot = 2; pslot <= 11; pslot++)

  {

    if (pslot != 6)

    {  /* CHECK EVERY SLOT EXCEPT THE MAC SLOT */

      p2c_temp = get_testhead_actual_card(mod_id, pslot);



      if (!(((1 << p2c_temp) & valid_cards) != 0))

        valid_configuration = false;

    }  /* CHECK EVERY SLOT EXCEPT THE MAC SLOT */

  }



  if (valid_configuration)

  {  /* DO THE REST OF THE TEST */

    OpenResourceManager();
	open_33250A(mod_id);

	/*Added by chuanho to select syn model, 14jun2012*/
    /*--------------------------------------------*/
    if(check_syn_model())
	{
		enable_33250A_out(mod_id);
		setup_33250A_defaults(mod_id);
	}
    else
		open_syn(mod_id);
    /*--------------------------------------------*/

    open_gen(mod_id);

	//open_mux(mod_id);
	open_34980A(mod_id);

    open_delay_osc(mod_id);

    connect_syn_out_gen_ext(mod_id);

    setup_gen_levels(mod_id, GEN_LOW_TERMINATED, GEN_HIGH_TERMINATED);

    connect_gen_trg_clkrb(mod_id);

    vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

    vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

    vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

    vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */

    flush_commands(mod_id);

    strcpy(s, "Connect scope channel 1 to CLKRB and CLKSG for module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, ".");

    display_prompt(s, true);

    strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

    display_prompt(s, true);

    display_prompt(BLANK_LINE, true);

    strcpy(s, "Connect scope channel 2 directly to ASRU card AF2 output module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, " using");

    display_prompt(s, true);

    strcpy(s, "an adaptor such that the AF2 cable can be reconnected.");

    display_prompt(s, true);

    *s = '\0';

    display_prompt(BLANK_LINE, true);

    display_prompt("\007", false);   /* '#7' should cause a beep */

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);

    vth_mhsl_1_init_master(mod_id);

    all_modules_but_me(mod_id, &vth_mhsl_1_init_passive);

    vth_mhsl_2_init_master(mod_id);

    all_modules_but_me(mod_id, &vth_mhsl_2_init_passive);

    vth_mdig_set_clkrb_master(mod_id, TCLK_FREQ, TCLK_FREQ, RISING_EDGE);

    setup_gen_trg_out_delay(mod_id, GEN_DELAY);



    for (pslot = 2; pslot <= 11; pslot++)

    {

      if (pslot != 6)

      {  /* for slot */

        close_pin_gnd_relays(mod_id, pslot);

        vth_pclose_rly(mod_id, pslot, KDCL);



        for (channel = 'A'; channel <= 'H'; channel++)

        {  /* for channel */

          /* ***************************************************************** */

          /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE AF2 ON ASRU */

          /* ***************************************************************** */

          connect_cntr_start_af2(mod_id);

          sales_reset_sequencer(mod_id, pslot);

          slot = pslot;

#include "t9120_nd.cmd"

          vth_pclose_rly(mod_id, pslot, PIN_KD_RLYS[channel - 'A']);

          vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A']);

          vth_mtmr_wait(mod_id, 0.1);

          sales_start_sequencer(mod_id, pslot);

          vth_mtmr_wait(mod_id, 0.1);



          for (edge = RISING; edge <= FALLING; ++edge)

          {

            /* MEASURE THE DELTA WITH THE SCOPE */

            dr_at_af2[pslot - 1][channel - 'A'][edge] = measure_td(mod_id, DR_AT_AF2_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

          }



          vth_mseq_stop(mod_id, TIMEOUT);

          vth_popen_rly(mod_id, pslot, PIN_KD_RLYS[channel - 'A']);



          /* ***************************************************************** */

          /* SETUP TO MAKE THE RECEIVER RAW DELAY MEASUREMENT AT AF2 ON ASRU   */

          /* ***************************************************************** */

          connect_gen_out_af2(mod_id);

          vth_pclose_rly(mod_id, pslot, PIN_KR_RLYS[channel - 'A']);



          switch (channel)

          {   /*Use mux_node_pins closest to the grounds*/

            case 'A':

            case 'B':

            case 'E':

            case 'F':  mux_node_pin = 7; break;



            case 'C':

            case 'D':

            case 'G':

            case 'H':  mux_node_pin = 0; break;



            default:   assert(false);    break;

          }



          vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

          vth_pclose_rly(mod_id, pslot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



          if ((channel & 1) > 0)

          {

            vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' + 1]);

            vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

          }

          else

          {

            vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' - 1]);

            vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

          }



          enable_gen_out(mod_id);

          vth_mtmr_wait(mod_id, 0.1);

          no_complement_gen_out(mod_id);



          for (edge = RISING; edge <= FALLING; ++edge)

          {

            /* MEASURE THE DELTA WITH THE SCOPE */

            rx_at_af2[pslot - 1][channel - 'A'][edge] = measure_td(mod_id, RX_AT_AF2_NOMINAL, CH_1, RISING, POST, edge, TIMEBASE_SENS);

            complement_gen_out(mod_id);

          }



          disable_gen_out(mod_id);

          vth_popen_rly(mod_id, pslot, PIN_KR_RLYS[channel - 'A']);

          vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

          vth_popen_rly(mod_id, pslot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



          if ((channel & 1) > 0)

          {

            vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' + 1]);

            vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

          }

          else

          {

            vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' - 1]);

            vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

          }



          vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A']);

        }  /* for channel */



        vth_popen_rly(mod_id, pslot, KDCL);

      }  /* for slot */

    }



    /* ***************************************************************** */

    /* WRITE THE DRIVER MEASUREMENTS FOR AF2 RAW DATA TO A FILE          */

    /* ***************************************************************** */

    outfile = fopen("dr_at_af2_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR DRIVER MEASUREMENTS AT AF2 CONNECTION\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 2; pslot <= 11; pslot++)

      {  /* for pslot */

        if (pslot != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot);



          for (channel = 'A'; channel <= 'H'; channel++)

            fprintf(outfile, " % .5E", dr_at_af2[pslot - 1][channel - 'A'][edge]);



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* WRITE THE RECEIVER MEASUREMENTS FOR AF2 RAW DATA TO A FILE        */

    /* ***************************************************************** */

    outfile = fopen("rx_at_af2_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR RECEIVER MEASUREMENTS AT AF2 CONNECTION\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 2; pslot <= 11; pslot++)

      {  /* for pslot */

        if (pslot != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot);



          for (channel = 'A'; channel <= 'H'; channel++)

            fprintf(outfile, " % .5E", rx_at_af2[pslot - 1][channel - 'A'][edge]);



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    flush_commands(mod_id);

    strcpy(s, "Leave scope channel 1 connected to CLKRB and CLKSG for module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, ".");

    display_prompt(s, true);

    strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

    display_prompt(s, true);

    display_prompt(BLANK_LINE, true);



    for (pslot = 2; pslot <= 11; pslot++)

    {

      if (pslot != 6)

      {  /* for slot */

        slot = pslot;

#include "t9120_nd.cmd"

        vth_pclose_rly(mod_id, pslot, KDCL);



        for (channel = 'A'; channel <= 'H'; channel++)

        {  /* for channel */

          strcpy(s, "Connect scope channel 2 to Pin Card Slot ");

          current_position = mtd_strlen(s) + 1;

          sprintf(s + current_position - 1, "%d", pslot);

          next_position = mtd_strlen(s) + 1;

          strcat(s, ", Mint Pin ");

          current_position = mtd_strlen(s) + 1;

          sprintf(s + current_position - 1, "%d", MINT_PIN[channel - 'A']);

          next_position = mtd_strlen(s) + 1;

          display_prompt(s, true);



          strcpy(s, "and connect the ground for Channel 2 to Slot ");

          current_position = mtd_strlen(s) + 1;

          sprintf(s + current_position - 1, "%d", pslot);

          next_position = mtd_strlen(s) + 1;

          strcat(s, ", Mint Pin ");

          current_position = mtd_strlen(s) + 1;

          sprintf(s + current_position - 1, "%d", GROUND_PIN[channel - 'A']);

          next_position = mtd_strlen(s) + 1;

          display_prompt(s, true);



          *s = '\0';

          display_prompt(BLANK_LINE, true);



          display_prompt("\007", false);   /* '#7' should cause a beep */

          update_status(WAITING);

          get_user_answer(buffer, 80);

          update_status(MEASURING);



          /* ***************************************************************** */

          /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS   */

          /* ***************************************************************** */

          connect_cntr_start_af2(mod_id);

          sales_reset_sequencer(mod_id, pslot);



          switch (channel)

          {

            case 'A':

            case 'B':

            case 'E':

            case 'F':  mux_node_pin = 7; break;



            case 'C':

            case 'D':

            case 'G':

            case 'H':  mux_node_pin = 1; break;



            default:   assert(false);    break;

          }



          vth_pclose_rly(mod_id, pslot, PIN_KD_RLYS[channel - 'A']);

          vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

          sales_start_sequencer(mod_id, pslot);



          for (edge = RISING; edge <= FALLING; ++edge)

          {

            /* MEASURE THE DELTA WITH THE SCOPE */

            dr_at_mint[pslot - 1][channel - 'A'][edge] = measure_td(mod_id, DR_AT_MINT_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

          }



          vth_mseq_stop(mod_id, TIMEOUT);

          vth_popen_rly(mod_id, pslot, PIN_KD_RLYS[channel - 'A']);



          /* ***************************************************************** */

          /* SETUP TO MAKE THE RECEIVER RAW DELAY MEASUREMENT AT THE MINT PINS */

          /* ***************************************************************** */

          connect_gen_out_af2(mod_id);

          vth_pclose_rly(mod_id, pslot, PIN_KR_RLYS[channel - 'A']);



          switch (channel)

          {   /*Use mux_node_pins closest to the grounds*/

            case 'A':

            case 'B':

            case 'E':

            case 'F':  mux_node_pin = 7; break;



            case 'C':

            case 'D':

            case 'G':

            case 'H':  mux_node_pin = 1; break;



            default:   assert(false);    break;

          }



          vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

          vth_pclose_rly(mod_id, pslot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



          if ((channel & 1) > 0)

          {

            vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' + 1]);

            vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

          }

          else

          {

            vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' - 1]);

            vth_pclose_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

          }



          vth_pclose_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A']);

          enable_gen_out(mod_id);

          vth_mtmr_wait(mod_id, 0.1);

          no_complement_gen_out(mod_id);



          for (edge = RISING; edge <= FALLING; ++edge)

          {

            /* MEASURE THE DELTA WITH THE SCOPE */

            rx_at_mint[pslot - 1][channel - 'A'][edge] = measure_td(mod_id, RX_AT_MINT_NOMINAL, CH_1, RISING, POST, edge, TIMEBASE_SENS);

            complement_gen_out(mod_id);

          }



          disable_gen_out(mod_id);

          vth_popen_rly(mod_id, pslot, PIN_KR_RLYS[channel - 'A']);

          vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

          vth_popen_rly(mod_id, pslot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



          if ((channel & 1) > 0)

          {

            vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' + 1]);

            vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

          }

          else

          {

            vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A' - 1]);

            vth_popen_rly(mod_id, pslot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

          }



          vth_popen_rly(mod_id, pslot, PIN_KGL_RLYS[channel - 'A']);

        }  /* for channel */



        vth_popen_rly(mod_id, pslot, KDCL);

      }  /* for slot */

    }



    /* ***************************************************************** */

    /* WRITE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS           */

    /* ***************************************************************** */

    outfile = fopen("dr_at_mint_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR DRIVER MEASUREMENTS AT MINT PINS\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 2; pslot <= 11; pslot++)

      {  /* for pslot */

        if (pslot != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot);



          for (channel = 'A'; channel <= 'H'; channel++)

            fprintf(outfile, " % .5E", dr_at_mint[pslot - 1][channel - 'A'][edge]);



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* WRITE THE RECEIVER RAW DELAY MEASUREMENT AT THE MINT PINS         */

    /* ***************************************************************** */

    outfile = fopen("rx_at_mint_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR RECEIVER MEASUREMENTS AT MINT PINS\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 2; pslot <= 11; pslot++)

      {  /* for pslot */

        if (pslot != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot);



          for (channel = 'A'; channel <= 'H'; channel++)

            fprintf(outfile, " % .5E", rx_at_mint[pslot - 1][channel - 'A'][edge]);



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE DRIVER DELTAS (AF2-AT_MINT)               */

    /* ***************************************************************** */

    outfile = fopen("dr_af2_mint_delta", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DELTA FOR DRIVERS AF2 DELAY - MINT PIN DELAY\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            dr_delta[pslot][channel - 'A'][edge] = dr_at_af2[pslot][channel - 'A'][edge] - dr_at_mint[pslot][channel - 'A'][edge];

            fprintf(outfile, " % .5E", dr_delta[pslot][channel - 'A'][edge]);

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE RECEIVER DELTAS (AF2-AT_MINT)             */

    /* ***************************************************************** */

    outfile = fopen("rx_af2_mint_delta", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DELTA FOR RECEIVERS AF2 DELAY - MINT PIN DELAY\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            rx_delta[pslot][channel - 'A'][edge] = rx_at_mint[pslot][channel - 'A'][edge] - rx_at_af2[pslot][channel - 'A'][edge];

            fprintf(outfile, " % .5E", rx_delta[pslot][channel - 'A'][edge]);

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE CHANNEL DELAYS FROM CHANNEL H             */

    /* ***************************************************************** */

    outfile = fopen("ch_minus_h_deltas", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DELTA FOR DRIVERS CHANNEL<x> - CHANNEL H \n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            ch_delta[pslot][channel - 'A'][edge] = dr_delta[pslot][channel - 'A'][edge] - dr_delta[pslot]['H' - 'A'][edge];

            fprintf(outfile, " % .5E", ch_delta[pslot][channel - 'A'][edge]);

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* AVERAGE DATA FOR ALL SLOTS */

    for (edge = RISING; edge <= FALLING; edge = (int)(edge + 1))

    {

      for (channel = 'A'; channel <= 'H'; channel++)

      {  /*calculate channel delay*/

        sum = 0.0;



        for (pslot = 2; pslot <= 11; pslot++)

        {

          if (pslot != 6)

            sum += ch_delta[pslot - 1][channel - 'A'][edge];

        }



        channel_delay[channel - 'A'][edge] = sum / 9;

      }  /*calculate channel delay*/

    }



    /* AVERAGE DATA FOR RISING AND FALLING */

    for (channel = 'A'; channel <= 'H'; channel++)

      av_chan_delay[channel - 'A'] = (channel_delay[channel - 'A'][RISING] +

                                      channel_delay[channel - 'A'][FALLING]) / 2;



    /* CALCULATE SLOT DELAYS */

    /* --------------------- */

    /* CALCULATE AVERAGE DELAY FOR EACH SLOT */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      for (pslot = 1; pslot <= 10; pslot++)

      {

        if (pslot + 1 != 6)

        {  /* for pslot */

          sum = 0.0;



          for (channel = 'A'; channel <= 'H'; channel++)

            sum += dr_delta[pslot][channel - 'A'][edge];



          slot_average[pslot][edge] = sum / 8;

        }  /* for pslot */

      }

    }



    /* REFERENCE EACH SLOT TO SLOT 2 */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      for (pslot = 0; pslot <= 10; pslot++)

      {

        switch (pslot + 1)

        {

          case 2:  slot_delay[pslot][edge] = dr_delta[pslot]['H' - 'A'][edge]; break;



          case 1:

          case 6:  slot_delay[pslot][edge] = 0.0e00;                           break;



          default: slot_delay[pslot][edge] = slot_average[pslot][edge] -

                                             slot_average[1][edge] +

                                             dr_delta[1]['H' - 'A'][edge];     break;

        }

      }

    }



    /* AVERAGE THE RISING AND FALLING NUMBERS */

    for (pslot = 0; pslot <= 10; pslot++)

      average_slot_delay[pslot] = (slot_delay[pslot][RISING] + slot_delay[pslot][FALLING]) / 2;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE DRIVER ERROR BASED ON CHANNEL(AV) + SLOT(EDGE) */

    /* ***************************************************************** */

    outfile = fopen("dr_errors", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DRIVER ERROR FOR CHANNEL(AV) + SLOT(EDGE)\n\n");

    sum = 0.0;

    max_error = 0.0;



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            dr_error[pslot][channel - 'A'][edge] = dr_delta[pslot][channel - 'A'][edge] - av_chan_delay[channel - 'A'] - slot_delay[pslot][edge];

            fprintf(outfile, " % .5E", dr_error[pslot][channel - 'A'][edge]);

            sum += fabs(dr_error[pslot][channel - 'A'][edge]);



            if (fabs(dr_error[pslot][channel - 'A'][edge]) > max_error)

              max_error = fabs(dr_error[pslot][channel - 'A'][edge]);

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    av_dr_error = sum / 144;

    fprintf(outfile, "AVERAGE MAGNITUDE OF DRIVER ERROR = % .5E\n", av_dr_error);

    fprintf(outfile, "MAXIMUM MAGNITUDE OF DRIVER ERROR = % .5E\n", max_error);



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE RECEIVER ONLY DELTAS (RX - DR)            */

    /* ***************************************************************** */

    outfile = fopen("rx_minus_dr_deltas", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RECEIVER ONLY (RECEIVER DELTAS MINUS DRIVER DELAYS)\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      sum = 0.0;



      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            rx_only[pslot][channel - 'A'][edge] = rx_delta[pslot][channel - 'A'][edge] - av_chan_delay[channel - 'A'] - slot_delay[pslot][edge];

            fprintf(outfile, "% .5E", rx_only[pslot][channel - 'A'][edge]);

            sum += rx_only[pslot][channel - 'A'][edge];

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

      rx_delay[edge] = sum / 72;

    }  /* for edge */



    av_rx_delay = (rx_delay[RISING] + rx_delay[FALLING]) / 2;



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE RECEIVER ERROR                            */

    /* ***************************************************************** */

    outfile = fopen("rx_errors", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RECEIVER ERRORS USING RECEIVER AVERAGE OFFSET\n\n");

    sum = 0.0;

    max_error = 0.0;



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      for (pslot = 1; pslot <= 10; pslot++)

      {  /* for pslot */

        if (pslot + 1 != 6)

        {  /* not a mac slot */

          fprintf(outfile, "%3d", pslot + 1);



          for (channel = 'A'; channel <= 'H'; channel++)

          {

            rx_error[pslot][channel - 'A'][edge] = rx_only[pslot][channel - 'A'][edge] - av_rx_delay;

            fprintf(outfile, " % .5E", rx_error[pslot][channel - 'A'][edge]);

            sum += fabs(rx_error[pslot][channel - 'A'][edge]);



            if (fabs(rx_error[pslot][channel - 'A'][edge]) > max_error)

              max_error = fabs(rx_error[pslot][channel - 'A'][edge]);

          }



          putc('\n', outfile);

        }  /* not a mac slot */

      }  /* for pslot */



      putc('\n', outfile);

    }  /* for edge */



    av_rx_error = sum / 144;

    fprintf(outfile, "AVERAGE MAGNITUDE OF RECEIVER ERROR = % .5E\n", av_rx_error);

    fprintf(outfile, "MAXIMUM MAGNITUDE OF RECEIVER ERROR = % .5E\n", max_error);



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* write out calculated new values for channel and slot delays */

    /* ***************************************************************** */

    outfile = fopen("new_slot_ch_delays", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "NEWLY CALCULATED SLOT AND CHANNEL DELAYS\n\n");



    for (channel = 'A'; channel <= 'H'; channel++)

      fprintf(outfile, "% .5E  AVERAGE CHANNEL DELAY FOR CHANNEL %c\n", av_chan_delay[channel - 'A'], channel);



    for (pslot = 1; pslot <= 11; pslot++)

      fprintf(outfile, "% .5E% .5E  RISING/FALLING SLOT DELAY FOR SLOT %3d\n", slot_delay[pslot - 1][RISING], slot_delay[pslot - 1][FALLING], pslot);



    fprintf(outfile, "% .5E% .5E% .5E  RISING/FALLING/AVERAGE RECEIVER DELAYS \n", rx_delay[RISING], rx_delay[FALLING], av_rx_delay);



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* merge the new data into the old database of delay constants       */

    /* ***************************************************************** */



    /* ************************** */

    /* first read the old data in */

    /* ************************** */

    if (infile != NULL)

      infile = freopen("delay_const", "r", infile);

    else

      infile = fopen("delay_const", "r");

    if (infile == NULL)

    {

      display_prompt("The 'delay_const' file was not found.  Please have sys admin replace.", true);

      _EscIO(FileNotFound);

    }



    for (channel = 'A'; channel <= 'H'; channel++)

      read_database_line(infile, &channel_data[channel - 'A']);

    for (pslot = 0; pslot <= 10; pslot++)

    {

    for (edge = RISING; edge <= FALLING; ++edge)

        read_database_line(infile, &slot_data[pslot][edge]);

    }

    read_database_line(infile, &receiver_data);

    fgets(comment, 81, infile);

    p2c_temp3 = strchr(comment, '\n');

    if (p2c_temp3 != NULL)

      *p2c_temp3 = 0;

    if (infile != NULL)

      fclose(infile);

    infile = NULL;



    /* ************************** */

    /* recalculate the values     */

    /* ************************** */

    for (channel = 'A'; channel <= 'H'; channel++)

      recalculate_database_line(av_chan_delay[channel - 'A'],

                                &channel_data[channel - 'A']);

    for (pslot = 0; pslot <= 10; pslot++)

    {

    for (edge = RISING; edge <= FALLING; ++edge)

        recalculate_database_line(slot_delay[pslot][edge], &slot_data[pslot]

                                  [edge]);

    }

    recalculate_database_line(av_rx_delay, &receiver_data);



    /* ************************** */

    /* write the new values       */

    /* ************************** */

    if (outfile != NULL)

      outfile = freopen("delay_const", "w", outfile);

    else

      outfile = fopen("delay_const", "w");

    if (outfile == NULL)

    {

      display_prompt("The 'delay_const' file was not found.  Please have sys admin replace.", true);

      _EscIO(FileNotFound);

    }



    for (channel = 'A'; channel <= 'H'; channel++)

      write_database_line(outfile, &channel_data[channel - 'A']);

    for (pslot = 0; pslot <= 10; pslot++)

    {

    for (edge = RISING; edge <= FALLING; ++edge)

        write_database_line(outfile, &slot_data[pslot][edge]);

    }

    write_database_line(outfile, &receiver_data);

    fprintf(outfile, "%s\n", comment);

    if (outfile != NULL)

      fclose(outfile);

    outfile = NULL;

	if(check_syn_model())
		close_33250A(mod_id);
	else
		close_syn(mod_id);

    close_gen(mod_id);

    close_34980A(mod_id);//close_mux(mod_id);

    close_delay_osc(mod_id);

    CloseResourceManager();

  }  /* DO THE REST OF THE TEST */



  if (infile != NULL)

    fclose(infile);

  if (outfile != NULL)

    fclose(outfile);

}  /*t9042*/

#undef BLANK_LINE

#undef CH_2

#undef CH_1

#undef RISING_EDGE

#undef TCLK_FREQ

#undef GEN_LOW_TERMINATED

#undef GEN_HIGH_TERMINATED

#undef TIMEOUT

#undef GEN_DELAY

#undef DR_AT_AF2_NOMINAL

#undef RX_AT_AF2_NOMINAL

#undef DR_AT_MINT_NOMINAL

#undef RX_AT_MINT_NOMINAL

#undef TIMEBASE_SENS



typedef int a_mint_pin_;

typedef a_mint_pin_ mint_pin_array_['H' + 1 - 'A'];

#define BLANK_LINE      ""

#define CH_2            2

#define CH_1            1

#define RISING_EDGE     1

#define TCLK_FREQ       5.0e+06

#define GEN_LOW_TERMINATED  0.2e+00

#define GEN_HIGH_TERMINATED  3.5e+00

#define TIMEOUT         1.0e-03

#define GEN_DELAY       65e-09

#define DR_AT_AF2_NOMINAL  10e-09

#define RX_AT_AF2_NOMINAL  80e-09

#define DR_AT_MINT_NOMINAL  0e-09

#define RX_AT_MINT_NOMINAL  100e-09

#define TIMEBASE_SENS   5e-09

const mint_pin_array_ MINT_PIN_ = {15, 16, 23, 24, 55, 56, 63, 64};

const mint_pin_array_ GROUND_PIN_ = {19, 19, 20, 20, 59, 59, 60, 60};

//------------------------------------------------------------------------------

/* NOTE: This was a prototype test that runs on only one slot (2) */

/* This test was used to develop t9042.p                          */

void t9043(int mod_id, int slot)

{

  /*SLOT AND CHANNEL DELAY CONSTANT MEASUREMENTS*/

  boolean valid_configuration;

  int pin_slot;

  char buffer[81];

  char s[81];

  int mux_node_pin;

  int current_position;

  int next_position;



  double dr_at_af2[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_at_af2[NUM_SLOTS]['H' + 1 - 'A'][2];

  double dr_at_mint[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_at_mint[NUM_SLOTS]['H' + 1 - 'A'][2];

  double dr_delta[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_delta[NUM_SLOTS]['H' + 1 - 'A'][2];

  double rx_only[NUM_SLOTS]['H' + 1 - 'A'][2];

  double ch_delta[NUM_SLOTS]['H' + 1 - 'A'][2];



  double channel_delay['H' + 1 - 'A'][2];

  double receiver_delay['H' + 1 - 'A'][2];

  double slot_average[NUM_SLOTS][2];

  double average_receiver_delay[2];

  double average_channel_delay['H' + 1 - 'A'];

  double average_slot_delay[NUM_SLOTS];

  int edge;

  int channel;

  double sum;

  FILE *outfile = NULL;



  /* CHECK FOR A PIN CARD IN ALL SLOTS */

  valid_configuration = true;



  if (valid_configuration)

  {  /* DO THE REST OF THE TEST */

    OpenResourceManager();
	open_33250A(mod_id);

	/*Added by chuanho to select syn model, 14jun2012*/
    /*--------------------------------------------*/
    if(check_syn_model())
	{
      enable_33250A_out(mod_id);
	  setup_33250A_defaults(mod_id);
	}
    else
      open_syn(mod_id);
    /*--------------------------------------------*/

    open_gen(mod_id);

	//open_mux(mod_id);
	open_34980A(mod_id);

    open_delay_osc(mod_id);

    connect_syn_out_gen_ext(mod_id);

    setup_gen_levels(mod_id, GEN_LOW_TERMINATED, GEN_HIGH_TERMINATED);



    connect_gen_trg_clkrb(mod_id);



    vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

    vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

    vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

    vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



    flush_commands(mod_id);

    strcpy(s, "Connect scope channel 1 to CLKRB and CLKSG for module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, ".");

    display_prompt(s, true);



    strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

    display_prompt(s, true);



    display_prompt(BLANK_LINE, true);



    strcpy(s, "Connect scope channel 2 directly to ASRU card AF2 output module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, " using");

    display_prompt(s, true);



    strcpy(s, "an adaptor such that the AF2 cable can be reconnected.");

    display_prompt(s, true);



    *s = '\0';

    display_prompt(BLANK_LINE, true);



    display_prompt("\007", false);   /* '#7' should cause a beep */

    update_status(WAITING);

    get_user_answer(buffer, 80);

    update_status(MEASURING);



    vth_mhsl_1_init_master(mod_id);

    all_modules_but_me(mod_id, &vth_mhsl_1_init_passive);

    vth_mhsl_2_init_master(mod_id);

    all_modules_but_me(mod_id, &vth_mhsl_2_init_passive);

    vth_mdig_set_clkrb_master(mod_id, TCLK_FREQ, TCLK_FREQ, RISING_EDGE);



    setup_gen_trg_out_delay(mod_id, GEN_DELAY);



    pin_slot = 2;

    if (pin_slot != 6)

    {  /* for slot */

      close_pin_gnd_relays(mod_id, pin_slot);

      vth_pclose_rly(mod_id, pin_slot, KDCL);



      for (channel = 'A'; channel <= 'H'; channel++)

      {  /* for channel */

        /* ***************************************************************** */

        /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE AF2 ON ASRU */

        /* ***************************************************************** */

        connect_cntr_start_af2(mod_id);

        sales_reset_sequencer(mod_id, pin_slot);

        slot = pin_slot;

#include "t9120_nd.cmd"

        vth_pclose_rly(mod_id, pin_slot, PIN_KD_RLYS[channel - 'A']);

        vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A']);

        vth_mtmr_wait(mod_id, 0.1);

        sales_start_sequencer(mod_id, pin_slot);

        vth_mtmr_wait(mod_id, 0.1);



        for (edge = RISING; edge <= FALLING; ++edge)

        {

          /* MEASURE THE DELTA WITH THE SCOPE */

          dr_at_af2[pin_slot - 1][channel - 'A'][edge] = measure_td(mod_id, DR_AT_AF2_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

        }



        vth_mseq_stop(mod_id, TIMEOUT);

        vth_popen_rly(mod_id, pin_slot, PIN_KD_RLYS[channel - 'A']);



        /* ***************************************************************** */

        /* SETUP TO MAKE THE RECEIVER RAW DELAY MEASUREMENT AT AF2 ON ASRU   */

        /* ***************************************************************** */

        connect_gen_out_af2(mod_id);

        vth_pclose_rly(mod_id, pin_slot, PIN_KR_RLYS[channel - 'A']);



        switch (channel)

        {   /*Use mux_node_pins closest to the grounds*/

          case 'A':

          case 'B':

          case 'E':

          case 'F':  mux_node_pin = 7; break;



          case 'C':

          case 'D':

          case 'G':

          case 'H':  mux_node_pin = 0; break;



          default:   assert(false);    break;

        }



        vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        vth_pclose_rly(mod_id, pin_slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



        if ((channel & 1) > 0)

        {

          vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' + 1]);

          vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

        }

        else

        {

          vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' - 1]);

          vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

        }



        enable_gen_out(mod_id);

        vth_mtmr_wait(mod_id, 0.1);

        no_complement_gen_out(mod_id);



        for (edge = RISING; edge <= FALLING; ++edge)

        {

          /* MEASURE THE DELTA WITH THE SCOPE */

          rx_at_af2[pin_slot - 1][channel - 'A'][edge] = measure_td(mod_id, RX_AT_AF2_NOMINAL, CH_1, RISING, POST, edge, TIMEBASE_SENS);

          complement_gen_out(mod_id);

        }



        disable_gen_out(mod_id);

        vth_popen_rly(mod_id, pin_slot, PIN_KR_RLYS[channel - 'A']);

        vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        vth_popen_rly(mod_id, pin_slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



        if ((channel & 1) > 0)

        {

          vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' + 1]);

          vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

        }

        else

        {

          vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' - 1]);

          vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

        }



        vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A']);

      }  /* for channel */



      vth_popen_rly(mod_id, pin_slot, KDCL);

    }  /* for slot */



    /* ***************************************************************** */

    /* WRITE THE DRIVER MEASUREMENTS FOR AF2 RAW DATA TO A FILE          */

    /* ***************************************************************** */

    outfile = fopen("dr_at_af2_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR DRIVER MEASUREMENTS AT AF2 CONNECTION\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

          fprintf(outfile, "% .5E", dr_at_af2[pin_slot - 1][channel - 'A'][edge]);



        putc('\n', outfile);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* WRITE THE RECEIVER MEASUREMENTS FOR AF2 RAW DATA TO A FILE        */

    /* ***************************************************************** */

    outfile = fopen("rx_at_af2_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR RECEIVER MEASUREMENTS AT AF2 CONNECTION\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

          fprintf(outfile, "% .5E", rx_at_af2[pin_slot - 1][channel - 'A'][edge]);



        putc('\n', outfile);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    flush_commands(mod_id);

    strcpy(s, "Leave scope channel 1 connected to CLKRB and CLKSG for module ");

    current_position = mtd_strlen(s) + 1;

    sprintf(s + current_position - 1, "%d", mod_id);

    next_position = mtd_strlen(s) + 1;

    strcat(s, ".");

    display_prompt(s, true);

    strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

    display_prompt(s, true);



    display_prompt(BLANK_LINE, true);

    pin_slot = 2;



    if (pin_slot != 6)

    {  /* for slot */

      slot = pin_slot;

#include "t9120_nd.cmd"

      vth_pclose_rly(mod_id, pin_slot, KDCL);



      for (channel = 'A'; channel <= 'H'; channel++)

      {  /* for channel */

        strcpy(s, "Connect scope channel 2 to Pin Card Slot ");

        current_position = mtd_strlen(s) + 1;

        sprintf(s + current_position - 1, "%d", pin_slot);

        next_position = mtd_strlen(s) + 1;

        strcat(s, ", Mint Pin ");

        current_position = mtd_strlen(s) + 1;

        sprintf(s + current_position - 1, "%d", MINT_PIN_[channel - 'A']);

        next_position = mtd_strlen(s) + 1;

        display_prompt(s, true);



        strcpy(s, "and connect the ground for Channel 2 to Slot ");

        current_position = mtd_strlen(s) + 1;

        sprintf(s + current_position - 1, "%d", pin_slot);

        next_position = mtd_strlen(s) + 1;

        strcat(s, ", Mint Pin ");

        current_position = mtd_strlen(s) + 1;

        sprintf(s + current_position - 1, "%d", GROUND_PIN_[channel - 'A']);

        next_position = mtd_strlen(s) + 1;

        display_prompt(s, true);



        *s = '\0';

        display_prompt(BLANK_LINE, true);



        display_prompt("\007", false);   /* '#7' should cause a beep */

        update_status(WAITING);

        get_user_answer(buffer, 80);

        update_status(MEASURING);



        /* ***************************************************************** */

        /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS   */

        /* ***************************************************************** */

        connect_cntr_start_af2(mod_id);

        sales_reset_sequencer(mod_id, pin_slot);



        switch (channel)

        {

          case 'A':

          case 'B':

          case 'E':

          case 'F':  mux_node_pin = 7; break;



          case 'C':

          case 'D':

          case 'G':

          case 'H':  mux_node_pin = 1; break;



          default:   assert(false);    break;

        }



        vth_pclose_rly(mod_id, pin_slot, PIN_KD_RLYS[channel - 'A']);

        vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        sales_start_sequencer(mod_id, pin_slot);



        for (edge = RISING; edge <= FALLING; ++edge)

        {

          /* MEASURE THE DELTA WITH THE SCOPE */

          dr_at_mint[pin_slot - 1][channel - 'A'][edge] = measure_td(mod_id, DR_AT_MINT_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

        }



        vth_mseq_stop(mod_id, TIMEOUT);

        vth_popen_rly(mod_id, pin_slot, PIN_KD_RLYS[channel - 'A']);



        /* ***************************************************************** */

        /* SETUP TO MAKE THE RECEIVER RAW DELAY MEASUREMENT AT THE MINT PINS */

        /* ***************************************************************** */

        connect_gen_out_af2(mod_id);

        vth_pclose_rly(mod_id, pin_slot, PIN_KR_RLYS[channel - 'A']);



        switch (channel)

        {   /*Use mux_node_pins closest to the grounds*/

          case 'A':

          case 'B':

          case 'E':

          case 'F':  mux_node_pin = 7; break;



          case 'C':

          case 'D':

          case 'G':

          case 'H':  mux_node_pin = 1; break;



          default:   assert(false);    break;

        }/* case */



        vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        vth_pclose_rly(mod_id, pin_slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



        if ((channel & 1) > 0)

        {

          vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' + 1]);

          vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

        }

        else

        {

          vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' - 1]);

          vth_pclose_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

        }



        vth_pclose_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A']);

        enable_gen_out(mod_id);

        vth_mtmr_wait(mod_id, 0.1);

        no_complement_gen_out(mod_id);



        for (edge = RISING; edge <= FALLING; ++edge)

        {

          /* MEASURE THE DELTA WITH THE SCOPE */

          rx_at_mint[pin_slot - 1][channel - 'A'][edge] = measure_td(mod_id, RX_AT_MINT_NOMINAL, CH_1, RISING, POST, edge, TIMEBASE_SENS);

          complement_gen_out(mod_id);

        }



        disable_gen_out(mod_id);

        vth_popen_rly(mod_id, pin_slot, PIN_KR_RLYS[channel - 'A']);

        vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        vth_popen_rly(mod_id, pin_slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);



        if ((channel & 1) > 0)

        {

          vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' + 1]);

          vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' + 1]);

        }

        else

        {

          vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A' - 1]);

          vth_popen_rly(mod_id, pin_slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A' - 1]);

        }



        vth_popen_rly(mod_id, pin_slot, PIN_KGL_RLYS[channel - 'A']);



      }  /* for channel */



      vth_popen_rly(mod_id, pin_slot, KDCL);



    }  /* for slot */



    /* ***************************************************************** */

    /* WRITE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS           */

    /* ***************************************************************** */

    outfile = fopen("dr_at_mint_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR DRIVER MEASUREMENTS AT MINT PINS\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

          fprintf(outfile, "% .5E", dr_at_mint[pin_slot - 1][channel - 'A'][edge]);



        putc('\n', outfile);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* WRITE THE RECEIVER RAW DELAY MEASUREMENT AT THE MINT PINS         */

    /* ***************************************************************** */

    outfile = fopen("rx_at_mint_raw", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RAW DATA FOR RECEIVER MEASUREMENTS AT MINT PINS\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

          fprintf(outfile, "% .5E", rx_at_mint[pin_slot - 1][channel - 'A'][edge]);



        putc('\n', outfile);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE DRIVER DELTAS (AF2-AT_MINT)               */

    /* ***************************************************************** */

    outfile = fopen("dr_af2_mint_delta", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DELTA FOR DRIVERS AF2 DELAY - MINT PIN DELAY\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

        {

          dr_delta[pin_slot - 1][channel - 'A'][edge] = dr_at_af2[pin_slot - 1][channel - 'A'][edge] - dr_at_mint[pin_slot - 1][channel - 'A'][edge];

          fprintf(outfile, "% .5E", dr_delta[pin_slot - 1][channel - 'A'][edge]);

        }



        putc('\n', outfile);

      }  /* not a mac slot */

      putc('\n', outfile);



    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE RECEIVER DELTAS (AF2-AT_MINT)             */

    /* ***************************************************************** */

    outfile = fopen("rx_af2_mint_delta", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "DELTA FOR RECEIVERS AF2 DELAY - MINT PIN DELAY\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      pin_slot = 2;   /* for pin_slot */



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);



        for (channel = 'A'; channel <= 'H'; channel++)

        {

          rx_delta[pin_slot - 1][channel - 'A'][edge] = rx_at_mint[pin_slot - 1][channel - 'A'][edge] - rx_at_af2[pin_slot - 1][channel - 'A'][edge];

          fprintf(outfile, "% .5E", dr_delta[pin_slot - 1][channel - 'A'][edge]);

        }



        putc('\n', outfile);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    display_prompt("Done writing delta file", true);

    /* CALCULATE CHANNEL DELAYS */

    /* ------------------------ */

    /* CALCULATE INDIVIDUAL DELAYS */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      pin_slot = 2;



      for (channel = 'A'; channel <= 'H'; channel++)

        ch_delta[pin_slot - 1][channel - 'A'][edge] = dr_delta[pin_slot - 1][channel - 'A'][edge] - dr_delta[pin_slot - 1]['H' - 'A'][edge];

    }



    display_prompt("Done calculating individual delays ", true);



    /* AVERAGE DATA FOR ALL SLOTS */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      for (channel = 'A'; channel <= 'H'; channel++)

      {  /*calculate channel delay*/

        sum = 0.0;



        for (pin_slot = 2; pin_slot <= 11; pin_slot++)

        {

          if (pin_slot != 6)

            sum += ch_delta[pin_slot - 1][channel - 'A'][edge];

        }



        channel_delay[channel - 'A'][edge] = sum / 9;

      }  /*calculate channel delay*/

    }



    display_prompt("Done doing average for all slots ", true);



    /* AVERAGE DATA FOR RISING AND FALLING */

    for (channel = 'A'; channel <= 'H'; channel++)

      average_channel_delay[channel - 'A'] = (channel_delay[channel - 'A'][RISING] +

                                              channel_delay[channel - 'A'][FALLING]) / 2;



    display_prompt("Done doing average for rising and falling", true);

    display_prompt("Begin slot delays", true);



    /* CALCULATE SLOT DELAYS */

    /* --------------------- */

    /* CALCULATE AVERAGE DELAY FOR EACH SLOT */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      if (pin_slot != 6)

      {  /* for pin_slot */

        sum = 0.0;



        for (channel = 'A'; channel <= 'H'; channel++)

         sum += dr_delta[pin_slot - 1][channel - 'A'][edge];



        slot_average[pin_slot - 1][edge] = sum / 8;

      }  /* for pin_slot */

    }



    display_prompt("Done calculating average for each slot", true);



    /* REFERENCE EACH SLOT TO SLOT 2 */

    for (edge = RISING; edge <= FALLING; ++edge)

    {

      switch (pin_slot)

      {

      case 2:  slot_delay[pin_slot - 1][edge] = dr_delta[pin_slot - 1]['H' - 'A'][edge]; break;



      case 1:

      case 6:  slot_delay[pin_slot - 1][edge] = 0.0e00;                                  break;



      default: slot_delay[pin_slot - 1][edge] = slot_average[pin_slot - 1][edge] -

                                                slot_average[1][edge] +

                                                dr_delta[1]['H' - 'A'][edge];            break;

      }

    }



    display_prompt("Done referencing each slot to slot 2", true);



    /* AVERAGE THE RISING AND FALLING NUMBERS */

    average_slot_delay[pin_slot - 1] = (slot_delay[pin_slot - 1][RISING] +

                                        slot_delay[pin_slot - 1][FALLING]) / 2;

    display_prompt("Done averaging rising and falling for each slot.", true);



    /* ***************************************************************** */

    /* CALCULATE AND WRITE THE RECEIVER DELTAS (AF2-AT_MINT)             */

    /* ***************************************************************** */

    outfile = fopen("rx_minus_dr_deltas", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "RECEIVER DELTAS MINUS DRIVER DELTAS\n\n");



    for (edge = RISING; edge <= FALLING; ++edge)

    {  /* for edge */

      if (edge == RISING)   /* for pin_slot */

        fprintf(outfile, "RISING EDGE:\n");

      else

        fprintf(outfile, "FALLING EDGE:\n");



      if (pin_slot != 6)   /* for pin_slot */

      {  /* not a mac slot */

        fprintf(outfile, "%3d", pin_slot);

        rx_only[pin_slot - 1][channel - 'A'][edge] = rx_delta[pin_slot - 1][channel - 'A'][edge] - dr_delta[pin_slot - 1][channel - 'A'][edge];

        fprintf(outfile, "% .5E\n", rx_only[pin_slot - 1][channel - 'A'][edge]);

      }  /* not a mac slot */



      putc('\n', outfile);

    }  /* for edge */



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;



    for (edge = RISING; edge <= FALLING; edge = (int)(edge + 1))

    {

      average_receiver_delay[edge] = 0.0;

      sum = 0.0;



      if (pin_slot != 6)

        sum += rx_only[pin_slot - 1][channel - 'A'][edge];



      receiver_delay[channel - 'A'][edge] = sum / 9;

      average_receiver_delay[edge] += receiver_delay[channel - 'A'][edge];

      average_receiver_delay[edge] /= 8;

    }



    /* ***************************************************************** */

    /* write out calculated new values for channel and slot delays */

    /* ***************************************************************** */

    outfile = fopen("new_slot_ch_delays", "w");



    if (outfile == NULL)

      _EscIO(FileNotFound);



    fprintf(outfile, "NEWLY CALCULATED SLOT AND CHANNEL DELAYS\n\n");

    fprintf(outfile, "  AVERAGE      RISING     FALLING      DELTA\n");

    fprintf(outfile,

            "% .5E% .5E% .5E% .5E  CHANNEL DELAY FOR CHANNEL %c\n",

            average_channel_delay[channel - 'A'],

            channel_delay[channel - 'A'][RISING],

            channel_delay[channel - 'A'][FALLING],

            fabs(channel_delay[channel - 'A'][FALLING] - channel_delay[channel - 'A'][RISING]),

            channel);



    fprintf(outfile, "% .5E% .5E% .5E% .5E  SLOT DELAY FOR SLOT %3d\n",

            average_slot_delay[pin_slot - 1],

            slot_delay[pin_slot - 1][RISING],

            slot_delay[pin_slot - 1][FALLING],

            fabs(slot_delay[pin_slot - 1][FALLING] - slot_delay[pin_slot - 1][RISING]),

            pin_slot);



    fprintf(outfile, "% .5E% .5E% .5E% .5E  RECEIVER DELAY FOR RECEIVER %c\n",

            (receiver_delay[channel - 'A'][RISING] + receiver_delay[channel - 'A'][FALLING]) / 2,

            receiver_delay[channel - 'A'][RISING],

            receiver_delay[channel - 'A'][FALLING],

            fabs(receiver_delay[channel - 'A'][RISING] - receiver_delay[channel - 'A'][FALLING]),

            channel);



    fprintf(outfile, "% .5E% .5E% .5E% .5E  AVERAGE RECEIVER DELAYS \n",

            (average_receiver_delay[RISING] + average_receiver_delay[FALLING]) / 2,

            average_receiver_delay[RISING],

            average_receiver_delay[FALLING],

            fabs(average_receiver_delay[RISING] - average_receiver_delay[FALLING]));



    if (outfile != NULL)

      fclose(outfile);



    outfile = NULL;

	if(check_syn_model())
		close_33250A(mod_id);
	else
		close_syn(mod_id);

    close_gen(mod_id);

    close_34980A(mod_id);//close_mux(mod_id);

    close_delay_osc(mod_id);

    CloseResourceManager();

  }  /* DO THE REST OF THE TEST */



}  /*t9043*/

#undef BLANK_LINE

#undef CH_2

#undef CH_1

#undef RISING_EDGE

#undef TCLK_FREQ

#undef GEN_LOW_TERMINATED

#undef GEN_HIGH_TERMINATED

#undef TIMEOUT

#undef GEN_DELAY

#undef DR_AT_AF2_NOMINAL

#undef RX_AT_AF2_NOMINAL

#undef DR_AT_MINT_NOMINAL

#undef RX_AT_MINT_NOMINAL

#undef TIMEBASE_SENS



typedef int a_mint_pin__;

typedef int ss_virt_card_type;

typedef a_mint_pin__ mint_pin_ch_array['H' + 1 - 'A'];

typedef mint_pin_ch_array mint_pin_array__[3];

#define BLANK_LINE      ""

#define CH_2            2

#define RISING_EDGE     1

#define TCLK_FREQ       5.0e+06

#define GEN_LOW_TERMINATED  0.1e+00

#define GEN_HIGH_TERMINATED  4.0e+00

#define TIMEOUT         1.0e-03

#define DR_AT_AF2_NOMINAL  30e-09

#define DR_AT_MINT_NOMINAL  20e-09

#define TIMEBASE_SENS   5e-09



const mint_pin_array__ MINT_PIN__ =

{

  {  3,  4, 23, 24, 43, 44, 63, 64 },

  {  9, 10, 29, 30, 49, 50, 69, 70 },

  { 15, 16, 35, 36, 55, 56, 75, 76 }

};



const mint_pin_array__ GROUND_PIN__ =

{

  { 19, 19, 20, 20, 59, 59, 60, 60 },

  { 19, 19, 20, 20, 59, 59, 60, 60 },

  { 19, 19, 20, 20, 59, 59, 60, 60 }

};



//------------------------------------------------------------------------------

void t9044(int mod_id, int slot)

{

  /* SILVER SWORD CHANNEL DELAY CONSTANTS MEASUREMENT */

  char buffer[81];

  char s[81];

  int mux_node_pin;

  int current;

  int next;



  double dr_at_af2['H' + 1 - 'A'][3][2];

  double dr_at_mint['H' + 1 - 'A'][3][2];

  double dr_delta['H' + 1 - 'A'][3][2];

  double channel_delay['H' + 1 - 'A'][3][2];



  double av_chan_delay['H' + 1 - 'A'][3];

  int edge;

  int channel;

  ss_virt_card_type ss_page;

  int slice;

  int slice_ch;



  FILE *outfile;



  outfile = NULL;

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_delay_osc(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW_TERMINATED, GEN_HIGH_TERMINATED);



  connect_gen_trg_clkrb(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  flush_commands(mod_id);

  strcpy(s, "Connect scope channel 1 to CLKRB and CLKSG for module ");

  current = mtd_strlen(s) + 1;

  sprintf(s + current - 1, "%d", mod_id);

  next = mtd_strlen(s) + 1;

  strcat(s, ".");

  display_prompt(s, true);



  strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

  display_prompt(s, true);



  display_prompt(BLANK_LINE, true);



  strcpy(s, "Connect scope channel 2 directly to ASRU card AF2 output module ");

  current = mtd_strlen(s) + 1;

  sprintf(s + current - 1, "%d", mod_id);

  next = mtd_strlen(s) + 1;

  strcat(s, " using");

  display_prompt(s, true);



  strcpy(s, "an adaptor such that the AF2 cable can be reconnected.");

  display_prompt(s, true);



  *s = '\0';

  display_prompt(BLANK_LINE, true);



  display_prompt("\007", false);   /* '#7' should cause a beep */

  update_status(WAITING);

  get_user_answer(buffer, 80);

  update_status(MEASURING);



  close_pin_gnd_relays(mod_id, slot);



  for (ss_page = 0; ss_page <= 2; ss_page++)

  {  /* ss_page */

    relay_map(mod_id, slot, ss_page);   /*selects "relay page"*/



    for (channel = 'A'; channel <= 'H'; channel++)

      vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);



  }  /* ss_page */



  vth_pclose_rly(mod_id, slot, KDCL);

  vth_mhsl_1_init_master(mod_id);

  all_modules_but_me(mod_id, &vth_mhsl_1_init_passive);

  vth_mhsl_2_init_master(mod_id);

  all_modules_but_me(mod_id, &vth_mhsl_2_init_passive);

  vth_mdig_set_clkrb_master(mod_id, TCLK_FREQ, TCLK_FREQ, RISING_EDGE);



#include "t9620_nd.cmd"



  for (ss_page = 0; ss_page <= 2; ss_page++)

  {  /* for ss_page */

    for (channel = 'A'; channel <= 'H'; channel++)

    {  /* for channel */

      /* ***************************************************************** */

      /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE AF2 ON ASRU */

      /* ***************************************************************** */

      connect_cntr_start_af2(mod_id);

      sales_reset_sequencer(mod_id, slot);

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

      vth_mtmr_wait(mod_id, 0.1);

      sales_start_sequencer(mod_id, slot);

      vth_mtmr_wait(mod_id, 0.1);



      for (edge = RISING; edge <= FALLING; ++edge)

      {

        /* MEASURE THE DELTA WITH THE SCOPE */

        dr_at_af2[channel - 'A'][ss_page][edge] = measure_td(mod_id, DR_AT_AF2_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

      }



      vth_mseq_stop(mod_id, TIMEOUT);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);



    }  /* for channel */



  }  /* for ss_page */



  /* ***************************************************************** */

  /* WRITE THE DRIVER MEASUREMENTS FOR AF2 RAW DATA TO A FILE          */

  /* ***************************************************************** */

  outfile = fopen("ss_dr_at_af2_raw", "w");



  if (outfile == NULL)

    _EscIO(FileNotFound);



  fprintf(outfile, "SS RAW DATA - DRIVER MEASUREMENTS AT AF2 CONNECTION\n\n");



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for edge */

    if (edge == RISING)

      fprintf(outfile, "RISING EDGE:\n");

    else

      fprintf(outfile, "FALLING EDGE:\n");



    for (ss_page = 0; ss_page <= 2; ss_page++)

    {  /* for ss_page */

      fprintf(outfile, "%3d", ss_page);



      for (channel = 'A'; channel <= 'H'; channel++)

        fprintf(outfile, " % .5E", dr_at_af2[channel - 'A'][ss_page][edge]);



      putc('\n', outfile);

    }  /* for ss_page */



    putc('\n', outfile);

  }  /* for edge */



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;



  /* ***************************************************************** */

  /* MESSAGE TO LEAVE THE SCOPE PROBE CONNECTED TO CLKRB               */

  /* ***************************************************************** */

  flush_commands(mod_id);

  strcpy(s, "Leave scope channel 1 connected to CLKRB and CLKSG for module ");

  current = mtd_strlen(s) + 1;

  sprintf(s + current - 1, "%d", mod_id);

  next = mtd_strlen(s) + 1;

  strcat(s, ".");

  display_prompt(s, true);



  strcpy(s, "This corresponds to SLOT 6, Probe tip = pin 3, Ground = pin 1.");

  display_prompt(s, true);



  display_prompt(BLANK_LINE, true);



  /* ********************************************************************* */

  /* The slice, ss_page, slice_ch, algorith is used such that the the MINT */

  /* pins are traversed in a increasing numeric sequence.                  */

  /* ********************************************************************* */

  for (slice = 0; slice <= 3; slice++)

  {  /* for slice */

    for (ss_page = 0; ss_page <= 2; ss_page++)

    {  /* for ss_page */

      for (slice_ch = 65; slice_ch <= 66; slice_ch++)

      {  /* for slice_ch */

        channel = slice * 2 + slice_ch;

        strcpy(s, "Connect scope channel 2 to SS Card Slot ");

        current = mtd_strlen(s) + 1;

        sprintf(s + current - 1, "%d", slot);

        next = mtd_strlen(s) + 1;

        strcat(s, ", Mint Pin ");

        current = mtd_strlen(s) + 1;

        sprintf(s + current - 1, "%d", MINT_PIN__[ss_page][channel - 'A']);

        next = mtd_strlen(s) + 1;

        display_prompt(s, true);



        strcpy(s, "and connect the ground for Channel 2 to Slot ");

        current = mtd_strlen(s) + 1;

        sprintf(s + current - 1, "%d", slot);

        next = mtd_strlen(s) + 1;

        strcat(s, ", Mint Pin ");

        current = mtd_strlen(s) + 1;

        sprintf(s + current - 1, "%d", GROUND_PIN__[ss_page][channel - 'A']);

        next = mtd_strlen(s) + 1;

        display_prompt(s, true);



        *s = '\0';

        display_prompt(BLANK_LINE, true);



        display_prompt("\007", false);   /* '#7' should cause a beep */

        update_status(WAITING);

        get_user_answer(buffer, 80);

        update_status(MEASURING);



        /* ***************************************************************** */

        /* SETUP TO MAKE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS   */

        /* ***************************************************************** */

        connect_cntr_start_af2(mod_id);

        sales_reset_sequencer(mod_id, slot);

        relay_map(mod_id, slot, ss_page);

        mux_node_pin = ss_page * 3 + 1;

        vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

        vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        sales_start_sequencer(mod_id, slot);



        for (edge = RISING; edge <= FALLING; ++edge)

        {

          /* MEASURE THE DELTA WITH THE SCOPE */

          dr_at_mint[channel - 'A'][ss_page][edge] = measure_td(mod_id, DR_AT_MINT_NOMINAL, CH_2, edge, PRE, RISING, TIMEBASE_SENS);

        }



        vth_mseq_stop(mod_id, TIMEOUT);

        vth_popen_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

        vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);



      }  /* for slice_ch */

    }  /* for ss_page */

  }  /* for slice */



  vth_popen_rly(mod_id, slot, KDCL);



  /* ************************************************************** */

  /* WRITE THE DRIVER RAW DELAY MEASUREMENT AT THE MINT PINS        */

  /* ************************************************************** */

  outfile = fopen("ss_dr_at_mint_raw", "w");



  if (outfile == NULL)

    _EscIO(FileNotFound);



  fprintf(outfile, "RAW DATA FOR SS DRIVER MEASUREMENTS AT MINT PINS\n");



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for edge */

    if (edge == RISING)

      fprintf(outfile, "RISING EDGE:\n");

    else

      fprintf(outfile, "FALLING EDGE:\n");



    for (ss_page = 0; ss_page <= 2; ss_page++)

    {  /* for ss_page */

      fprintf(outfile, "%3d", ss_page);



      for (channel = 'A'; channel <= 'H'; channel++)

        fprintf(outfile, " % .5E", dr_at_mint[channel - 'A'][ss_page][edge]);



      putc('\n', outfile);

    }  /* for ss_page */



    putc('\n', outfile);

  }  /* for edge */



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;



  /* ***************************************************************** */

  /* CALCULATE AND WRITE THE DRIVER DELTAS (AF2-AT_MINT)               */

  /* ***************************************************************** */

  outfile = fopen("ss_dr_af2_mint_delta", "w");



  if (outfile == NULL)

    _EscIO(FileNotFound);



  fprintf(outfile, "DELTA FOR SS DRIVERS AF2 DELAY - MINT PIN DELAY\n\n");



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for edge */

    if (edge == RISING)

      fprintf(outfile, "RISING EDGE:\n");

    else

      fprintf(outfile, "FALLING EDGE:\n");



    for (ss_page = 0; ss_page <= 2; ss_page++)

    {  /* for ss_page */

      fprintf(outfile, "%3d", ss_page);



      for (channel = 'A'; channel <= 'H'; channel++)

      {

        dr_delta[channel - 'A'][ss_page][edge] = dr_at_af2[channel - 'A'][ss_page][edge] - dr_at_mint[channel - 'A'][ss_page][edge];

        fprintf(outfile, " % .5E", dr_delta[channel - 'A'][ss_page][edge]);

      }



      putc('\n', outfile);

    }  /* for ss_page */



    putc('\n', outfile);

  }  /* for edge */



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;



  /* ***************************************************************** */

  /* CALCULATE AND WRITE THE CHANNEL DELAYS                            */

  /* ***************************************************************** */

  outfile = fopen("ss_ch_minus_slot_rx_deltas", "w");



  if (outfile == NULL)

    _EscIO(FileNotFound);



  fprintf(outfile, "DELTA FOR DRIVERS CHANNEL<x> - SLOT(slot) - rx offset\n\n");



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for edge */

    if (edge == RISING)

      fprintf(outfile, "RISING EDGE:\n");

    else

      fprintf(outfile, "FALLING EDGE:\n");



    for (ss_page = 0; ss_page <= 2; ss_page++)

    {  /* for ss_page */

      fprintf(outfile, "%3d", ss_page);



      for (channel = 'A'; channel <= 'H'; channel++)

      {

        channel_delay[channel - 'A'][ss_page][edge] = dr_delta[channel - 'A'][ss_page][edge] - slot_delay[slot - 1][edge] - rx_path_offset;

        fprintf(outfile, " % .5E", channel_delay[channel - 'A'][ss_page][edge]);

      }



      putc('\n', outfile);

    }  /* for ss_page */



    putc('\n', outfile);

  }  /* for edge */



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;



  /* ***************************************************************** */

  /* AVERAGE CHANNEL DELTA DATA FOR RISING AND FALLING */

  /* ***************************************************************** */

  outfile = fopen("ss_average_ch_delay", "w");



  if (outfile == NULL)

    _EscIO(FileNotFound);



  fprintf(outfile, "AVERAGE CHANNEL DELAY FOR SS CHANNELS\n\n");



  for (ss_page = 0; ss_page <= 2; ss_page++)

  {  /* for ss_page */

    fprintf(outfile, "%3d", ss_page);



    for (channel = 'A'; channel <= 'H'; channel++)

    {  /* for channel */

      av_chan_delay[channel - 'A'][ss_page] = (channel_delay[channel - 'A'][ss_page][RISING] +

                                               channel_delay[channel - 'A'][ss_page][FALLING]) / 2;

      fprintf(outfile, "% .5E", av_chan_delay[channel - 'A'][ss_page]);

    }  /* for channel */



    putc('\n', outfile);

  }  /* for ss_page */



  if (outfile != NULL)

    fclose(outfile);



  outfile = NULL;

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_delay_osc(mod_id);

  CloseResourceManager();

}  /*t9044*/

#undef WHAT_STRING_

#undef BLANK_LINE

#undef CH_2

#undef RISING_EDGE

#undef TCLK_FREQ

#undef GEN_LOW_TERMINATED

#undef GEN_HIGH_TERMINATED

#undef TIMEOUT

#undef DR_AT_AF2_NOMINAL

#undef DR_AT_MINT_NOMINAL

#undef TIMEBASE_SENS



#define FIXTURE_ENABLED  5

#define ID_MIN          3780

#define ID_MAX          3783

#define ID_MIN_EXP      3798

#define ID_MAX_EXP      3803

#define FIXTURE_LOCK_TIME  1.0e+00

//------------------------------------------------------------------------------

void t9047(int mod_id, int /* slot */)

{

  /* STANDARD COMPONENTS - fixture ID */

  int fixture_id;



  char buffer[81];

  test_result_type result;



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_nolog(mod_id, &result))

  {

    if (result.UU.Integer_result != FIXTURE_ENABLED)

    {

//      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

      /* FLUSH THE COMMANDS */

      if (get_result_nolog(mod_id, &result))

        display_prompt("Unexpected result encountered", true);

      display_prompt("Please install the Standard Components Sales fixture.", true);

      display_prompt("Then press <Return> or <Enter>.  ", true);

      get_user_answer(buffer, 80);

    }

  }



//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

  vth_mtmr_wait(mod_id, FIXTURE_LOCK_TIME);

  vth_mrd_cell(mod_id, MIO_FXT_EN);

  if (get_result_log(mod_id, &result))

  {

    if (result.UU.Integer_result == FIXTURE_ENABLED)

    {  /*fixture found - check type*/

      fixture_id = get_fixture_id(mod_id);

     // if (fixture_id < ID_MIN || fixture_id > ID_MAX)

      if (!(((ID_MIN <= fixture_id) && (fixture_id <= ID_MAX)) || ((ID_MIN_EXP <= fixture_id) && (fixture_id <= ID_MAX_EXP) )))

	  {

        display_prompt("Incorrect Fixture Found", true);

        /* Next routine causes the non-module failure to be set also */

        add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);

      }

      result.UU.Integer_result = fixture_id;

      log_result(mod_id, result);

    }  /*fixture found - check type*/

    else

    {  /*no fixture found*/

      display_prompt("No fixture found.", true);

      /* Next routine causes the non-module failure to be set also */

      add_test_to_gfs(present_test[mod_id - NO_TESTHEAD_NUMBER]);



//      if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//        display_prompt("Press footswitch to (un)lock fixture",true);



      vth_cfxt_unlock();

    }  /*no fixture found*/



  }



}  /*t9047*/

#undef FIXTURE_ENABLED

#undef ID_MIN

#undef ID_MAX

#undef FIXTURE_LOCK_TIME



//------------------------------------------------------------------------------

void t9048(void)

{

  /* Lock fixture in place */

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();

}  /*t9048*/



//------------------------------------------------------------------------------

void t9049(void)

{

  /* unock fixture  */

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_unlock();

}  /*t9049*/



#define SYN_FREQ_AF2    20000000

#define SYN_FREQ_CLKRB  60000000

#define GEN_PWIDTH      25e-09

//------------------------------------------------------------------------------

void t9050(int mod_id, int /* slot */)

{

  /*TIME INTERVAL COUNTER VERIFICATION - FREQUENCY MODE*/

  test_result_type result;

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  /*CHECK THE FREQUENCY ACCURACY THROUGH THE AF2 PATH*/

  connect_syn_out_gen_ext(mod_id);

    /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
      setup_33250A_freq(mod_id, SYN_FREQ_AF2);
  else
	  setup_syn_freq(mod_id, SYN_FREQ_AF2);
  /*--------------------------------------------*/

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

  connect_gen_out_af2(mod_id);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */

  vth_mclose_rly(mod_id, MK1614);   /* XL connect relay */

  vth_mclose_rly(mod_id, MK1604);   /* XL to TIC relay */

  vth_mclose_rly(mod_id, MK1602);   /* TIC A/B common  */

  enable_gen_out(mod_id);

  /* Adding to give equip time to setup before taking measurement -gpm */

  vth_mtmr_wait(mod_id, 0.100);

  vth_mtic_sel_long_gate(mod_id);

  vth_mtic_freq_a_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_sel_shrt_gate(mod_id);

  vth_mtic_freq_a_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  disable_gen_out(mod_id);

  vth_mopen_rly(mod_id, MK1614);   /* XL connect relay */

  vth_mopen_rly(mod_id, MK1604);   /* XL to TIC relay */

  /*CHECK THE FREQUENCY ACCURACY THROUGH THE CLKRB PATH*/

    /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    setup_33250A_freq(mod_id, SYN_FREQ_CLKRB);
  }
  else
  {
    connect_syn_aux_gen_ext(mod_id);
    setup_syn_freq(mod_id, SYN_FREQ_CLKRB);
  }
  /*--------------------------------------------*/

  connect_gen_trg_clkrb(mod_id);

  vth_mclose_rly(mod_id, MK2902);   /*CLKRB relay*/

  vth_mclose_rly(mod_id, MK2903);   /*CLKRSG relay*/

  vth_mclose_rly(mod_id, MK1601);   /*TIC A MUX to TIC A relay*/

  vth_mtic_a_dclkrb_mux(mod_id);

  vth_mtic_sel_long_gate(mod_id);

  vth_mtmr_wait(mod_id, 0.100);   /* See if this is required? */

  vth_mtic_freq_a_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    result.UU.Real_result *= 2;   /*CLKRB input divided by 2*/

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    result.UU.Real_result *= 2;   /*CLKRB input divided by 2*/

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected TIC reading)", true);



  vth_mtic_sel_shrt_gate(mod_id);

  vth_mtic_freq_a_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    result.UU.Real_result *= 2;   /*CLKRB input divided by 2*/

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    result.UU.Real_result *= 2;   /*CLKRB input divided by 2*/

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();



}  /*t9050*/

#undef SYN_FREQ_AF2

#undef SYN_FREQ_CLKRB

#undef GEN_PWIDTH



#define SAMPLES         100

#define SYN_FREQ__      20000000

#define SYN_WAIT_TIME	30e-03

#define GEN_PWIDTH      25e-09

/* loaded - low output level = -2.0v */

#define GEN_LO          (-1.8e+00)

/* loaded - high output level = 5.0v */

#define GEN_HI          5.2e+00

//------------------------------------------------------------------------------

void t9052(int mod_id, int /* slot */)

{

  /*TIME INTERVAL COUNTER VERIFICATION - TI MODE*/



  /* This test has been modified to use the counter instead of the oscilloscope.  Relay closures have yet to be changed.  mjs */

  /* NOTE: This test requires a MAC 11 card (or later) because of the 50 ohm TIC load to ground. */

  double actual_pos_pulse;

  double actual_neg_pulse;

  double tic_pos_pulse_lg;

  double tic_pos_pulse_sg;

  double tic_neg_pulse_lg;

  double tic_neg_pulse_sg;

  test_result_type result;

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
      open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  	  setup_33250A_freq(mod_id, SYN_FREQ__);
  else
	  setup_syn_freq(mod_id, SYN_FREQ__);

  vth_mtmr_wait(mod_id, SYN_WAIT_TIME);

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

  setup_gen_levels(mod_id, GEN_LO, GEN_HI);

  connect_gen_out_cntr_ch1(mod_id);

  enable_gen_out(mod_id);





  /* use cntr to measure 'golden' values for the positive and negative pulse widths

     output from the generator to be compared against values measured by

     the TIC.   abr 7/98  */

//This next line is written in order to use the second output of the counter

  vth_mhpib_wr(mod_id, 4, ":EVEN2:FEED 'INP1'");

  setup_cntr_function(mod_id, PWID);

  vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

  actual_pos_pulse = read_cntr(mod_id);

  setup_cntr_function(mod_id, NWID);

  vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

  actual_neg_pulse = read_cntr(mod_id);



  disable_gen_out(mod_id);



  connect_gen_out_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */

  vth_mclose_rly(mod_id, MK1614);   /* XL connect relay */

  vth_mclose_rly(mod_id, MK1604);   /* XL to TIC relay */

  vth_mclose_rly(mod_id, MK1602);   /* TIC A/B common  */

  vth_mclose_rly(mod_id, MK1605);   /* TIC 50 ohm load */



  enable_gen_out(mod_id);



  /* Delected gate time selection because it doesn't make sense with ti mode

     10/28/91 JRM per Richard DeVore */

  vth_mtic_ti_abrf_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {

    tic_pos_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_lg - actual_pos_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* Delected gate time selection because it doesn't make sense with ti mode

     also, changed routine to one measurement (as opposed to fast meas'ment

     10/28/91 JRM per Richard DeVore */

  vth_mtic_ti_abrf_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {

    tic_pos_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_sg - actual_pos_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  /* Delected gate time selection because it doesn't make sense with ti mode

     10/28/91 JRM per Richard DeVore */

  vth_mtic_ti_abfr_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {

    tic_neg_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_lg - actual_neg_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* Delected gate time selection because it doesn't make sense with ti mode

     also, changed routine to one measurement (as opposed to fast meas'ment

     10/28/91 JRM per Richard DeVore */

  vth_mtic_ti_abfr_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {

    tic_neg_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_sg - actual_neg_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  disable_gen_out(mod_id);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9052*/

#undef SAMPLES

#undef SYN_FREQ__

#undef SYN_WAIT_TIME

#undef GEN_PWIDTH

#undef GEN_LO

#undef GEN_HI



#define OSC_CHANNEL     1

#define COUNT           5

#define SAMPLES         100

#define OSC_LOAD        1000000

#define SYN_FREQ__      20000000

#define GEN_PWIDTH      25e-09

/* no load - low output level = -2.0v */

#define GEN_LO          (-1.0e+00)

/* no load - high output level = 5.0v */

#define GEN_HI          2.5e+00

#define CHANNEL_RANGE   8.0e+00

#define CHANNEL_OFFSET  1.5e+00

#define TRIGGER_LEVEL   1.50e+00

#define TIMEBASE_RANGE  90e-09

#define TIMEBASE_OFFSET  12.5e-09

#define AVERAGING       true

#define OSC_MODE        AUTOMATIC

//------------------------------------------------------------------------------

void t9053(int mod_id, int /* slot */)

{

  /*TIME INTERVAL COUNTER VERIFICATION - TI MODE*/

  /* runs only on mac 10 and mac 15 */

  double actual_pos_pulse;

  double actual_neg_pulse;

  double tic_pos_pulse_lg;

  double tic_pos_pulse_sg;

  double tic_neg_pulse_lg;

  double tic_neg_pulse_sg;

  test_result_type result;

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	  enable_33250A_out(mod_id);
	  setup_33250A_defaults(mod_id);
  }
  else
      open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
		setup_33250A_freq(mod_id, SYN_FREQ__);
  else
		setup_syn_freq(mod_id, SYN_FREQ__);
  /*---------------------------------------------*/

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

  setup_gen_levels(mod_id, GEN_LO, GEN_HI);

  setup_osc_channel(mod_id, OSC_CHANNEL, OSC_LOAD, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, OSC_MODE);

  connect_gen_out_osc_ch1(mod_id);

  enable_gen_out(mod_id);

  setup_osc_trigger(mod_id, OSC_CHANNEL, POS, TRIGGER_LEVEL, AVERAGING);

  trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

  measure_osc(mod_id, WIDTH, POS);



  if (get_result_nolog(mod_id, &result))

    actual_pos_pulse = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected osc reading)", true);



  setup_osc_trigger(mod_id, OSC_CHANNEL, NEG, TRIGGER_LEVEL, AVERAGING);

  trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

  measure_osc(mod_id, WIDTH, NEG);

  disable_gen_out(mod_id);



  if (get_result_nolog(mod_id, &result))

    actual_neg_pulse = result.UU.Real_result;

  else

    display_prompt("No result in result log (Expected osc reading)", true);



  connect_gen_out_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */



  vth_mclose_rly(mod_id, MK1614);   /* XL connect relay */

  vth_mclose_rly(mod_id, MK1604);   /* XL to TIC relay */

  vth_mclose_rly(mod_id, MK1602);   /* TIC A/B common  */



  enable_gen_out(mod_id);



  /* ----------------------------------------------------------------------- */

  /* Delected gate time selection because it doesn't make sense with ti mode */

  /* 10/28/91 JRM per Richard DeVore --------------------------------------- */

  vth_mtic_ti_abrf_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    tic_pos_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_lg - actual_pos_pulse;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* ----------------------------------------------------------------------- */

  /* Delected gate time selection because it doesn't make sense with ti mode */

  /* also, changed routine to one measurement (as opposed to fast meas'ment  */

  /* 10/28/91 JRM per Richard DeVore --------------------------------------- */

  vth_mtic_ti_abrf_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    tic_pos_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_sg - actual_pos_pulse;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  /* ----------------------------------------------------------------------- */

  /* Delected gate time selection because it doesn't make sense with ti mode */

  /* 10/28/91 JRM per Richard DeVore --------------------------------------- */

  vth_mtic_ti_abfr_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    tic_neg_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_lg - actual_neg_pulse;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* ----------------------------------------------------------------------- */

  /* Delected gate time selection because it doesn't make sense with ti mode */

  /* also, changed routine to one measurement (as opposed to fast meas'ment  */

  /* 10/28/91 JRM per Richard DeVore --------------------------------------- */

  vth_mtic_ti_abfr_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    tic_neg_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_sg - actual_neg_pulse;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  disable_gen_out(mod_id);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  if(check_syn_model())
	  close_33250A(mod_id);
  else
	  close_syn(mod_id);

  close_gen(mod_id);

  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9053*/

#undef OSC_CHANNEL

#undef COUNT

#undef SAMPLES

#undef OSC_LOAD

#undef SYN_FREQ__

#undef GEN_PWIDTH

#undef GEN_LO

#undef GEN_HI

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef AVERAGING

#undef OSC_MODE



typedef double frequency_array__[3];

#define OSC_CHANNEL     2

#define COUNT           5

#define NUM_FREQUENCIES  3

#define COUPLING        50

#define CNTR_SAMPLE_SIZE  10

#define CHANNEL_RANGE   1.6e+00

#define CHANNEL_OFFSET  0.6e+00

#define TRIGGER_LEVEL   0.6e+00

#define TIMEBASE_OFFSET  0.0e+00

#define GATE_TIME       0.1e+00

#define TIMEOUT         1.0e-03

#define AVERAGING       true

#define TIMEBASE_MODE   AUTOMATIC

#define EDGE            POS

const frequency_array__ FREQUENCIES__ = {625e+03, 20e+06, 40e+06};

//------------------------------------------------------------------------------

void t9055(int mod_id, int /* slot */)

{

  /*USER CLOCK GENERATION RANGE, ACCURACY, & JITTER*/

  /* Modified: 01/21/92 JRMAdded falling to falling jitter measurements */

  /* Modified: 01/22/92 JRMChanged meas mode to use MD4 instead of MD2  */

  int loop;



  double cntr_actual_frequency;

  double cntr_actual_min;

  double cntr_actual_max;

  double cntr_max_minus_min;

  double timebase_range;

  frequency_array__ falling_jitters;



  test_result_type result;





  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);



  setup_cntr_trg_levels(mod_id, TRIGGER_LEVEL, TRIGGER_LEVEL);



  vth_mseq_stop(mod_id, TIMEOUT);



  vth_mclose_rly(mod_id, MK2801);   /* UCLK to Mint pins relay     */

  vth_mclose_rly(mod_id, MK2802);   /* UCLK GND to Mint pins relay */



  vth_mdclk_en_uclk(mod_id);



  for (loop = 0; loop < NUM_FREQUENCIES; loop++)

  {  /*for*/

    vth_mdclk_0_set_freq(mod_id, FREQUENCIES__[loop]);

    connect_cntr_stop_uclk(mod_id);



    setup_cntr_function(mod_id, FREQUENCY);

    setup_cntr_gate_time(mod_id, GATE_TIME);

    trigger_cntr(mod_id);

    cntr_actual_frequency = read_cntr_mean(mod_id);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_actual_frequency;

    log_result(mod_id, result);



    setup_cntr_function(mod_id, PERIOD);

    setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

    trigger_cntr(mod_id);



    cntr_actual_min = read_cntr_min(mod_id);

    cntr_actual_max = read_cntr_max(mod_id);

    cntr_max_minus_min = cntr_actual_max - cntr_actual_min;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_max_minus_min;

    log_result(mod_id, result);



    /* --------------------------------------------------------------------- */

    /* Now do the falling to falling jitter, but save the results and log    */

    /* at the end to preserve compatibility with existing data.  JRM 1/21/92 */

    /* --------------------------------------------------------------------- */

    /* First set the counter to measure falling to falling edges JRM 1/21/92 */

    setup_cntr_trigger_slopes(mod_id, NEG, NEG);

    /* Now make the same jitter measurement as before            JRM 1/21/92 */

    trigger_cntr(mod_id);

    cntr_actual_min = read_cntr_min(mod_id);

    cntr_actual_max = read_cntr_max(mod_id);

    cntr_max_minus_min = cntr_actual_max - cntr_actual_min;

    falling_jitters[loop] = cntr_max_minus_min;

    /* Now set the counter to measure rising to rising edges     JRM 1/21/92 */

    setup_cntr_trigger_slopes(mod_id, POS, POS);



    /* Now do the duty cycle measurement with the oscilloscope               */

    timebase_range = 3.6 / FREQUENCIES__[loop];

    setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                      CHANNEL_OFFSET);

    setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

    setup_osc_timebase(mod_id, AVERAGING, COUNT, timebase_range,

                       TIMEBASE_OFFSET, TIMEBASE_MODE);

    connect_osc_ch2_uclk(mod_id);

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    measure_osc(mod_id, DUTY_CYCLE, EDGE);



    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected DTY Cycle)", true);



  }  /*for*/



  /* Now log the falling jitter values that were saved earlier to preserve   */

  /* the order of previous data.                         JRM  1/21/92        */

  for (loop = 0; loop < NUM_FREQUENCIES; loop++)

  {  /* loop to log falling sigma values */

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = falling_jitters[loop];

    log_result(mod_id, result);

  }  /* loop to log falling sigma values */



  vth_minit(mod_id);

  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);



}  /*t9055*/

#undef OSC_CHANNEL

#undef COUNT

#undef NUM_FREQUENCIES

#undef COUPLING

#undef CNTR_SAMPLE_SIZE

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_OFFSET

#undef GATE_TIME

#undef TIMEOUT

#undef AVERAGING

#undef TIMEBASE_MODE

#undef EDGE



#define NUM_FREQUENCIES  4

typedef double frequency_array___[NUM_FREQUENCIES];

#define CNTR_SAMPLE_SIZE  10

#define TRIGGER_LEVEL   0.6e+00

#define GATE_TIME       0.1e+00

#define TIMEOUT         1.0e-03

const frequency_array___ FREQUENCIES___ = {625e+03, 20e+06, 40e+06, 50e+06};

//------------------------------------------------------------------------------

void t9056(int mod_id, int /* slot */)

{

  /*CONTROL PLUS - USER CLOCK RANGE, ACCURACY, & JITTER*/

  int loop;



  double cntr_actual_frequency;

  double cntr_actual_min;

  double cntr_actual_max;

  double cntr_max_minus_min;

  double cntr_duty_cycle;

  frequency_array___ falling_jitters;

  test_result_type result;




  OpenResourceManager();

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);



  setup_cntr_trg_levels(mod_id, TRIGGER_LEVEL, TRIGGER_LEVEL);



  vth_mseq_stop(mod_id, TIMEOUT);



  vth_mclose_rly(mod_id, MK2801);   /* UCLK to Mint pins relay     */

  vth_mclose_rly(mod_id, MK2802);   /* UCLK GND to Mint pins relay */



  vth_mdclk_en_uclk(mod_id);



  for (loop = 0; loop < NUM_FREQUENCIES; loop++)

  {  /*for*/

    vth_mdclk_0_set_freq(mod_id, FREQUENCIES___[loop]);

    connect_cntr_stop_uclk(mod_id);



    setup_cntr_function(mod_id, FREQUENCY);

    setup_cntr_gate_time(mod_id, GATE_TIME);

    trigger_cntr(mod_id);

    cntr_actual_frequency = read_cntr_mean(mod_id);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_actual_frequency;

    log_result(mod_id, result);



    setup_cntr_function(mod_id, PERIOD);

    setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

    trigger_cntr(mod_id);

    cntr_actual_min = read_cntr_min(mod_id);

    cntr_actual_max = read_cntr_max(mod_id);

    cntr_max_minus_min = cntr_actual_max - cntr_actual_min;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_max_minus_min;

    log_result(mod_id, result);



    /* --------------------------------------------------------------------- */

    /* Now do the falling to falling jitter, but save the results and log    */

    /* at the end to preserve compatibility with existing data.  JRM 1/21/92 */

    /* --------------------------------------------------------------------- */

    setup_cntr_trigger_slopes(mod_id, NEG, NEG);

    trigger_cntr(mod_id);

    cntr_actual_min = read_cntr_min(mod_id);

    cntr_actual_max = read_cntr_max(mod_id);

    cntr_max_minus_min = cntr_actual_max - cntr_actual_min;

    falling_jitters[loop] = cntr_max_minus_min;

    setup_cntr_trigger_slopes(mod_id, POS, POS);



    connect_cntr_ch1_uclk(mod_id);

    setup_cntr_function(mod_id, DCYCLE);

    trigger_cntr(mod_id);

    cntr_duty_cycle = read_cntr(mod_id);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_duty_cycle * 100;

    log_result(mod_id, result);



  }  /*for*/



  for (loop = 0; loop < NUM_FREQUENCIES; loop++)

  {  /* loop to log falling jitter values */

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = falling_jitters[loop];

    log_result(mod_id, result);

  }  /* loop to log falling jitter values */



  vth_minit(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager();


}  /*t9056*/

#undef NUM_FREQUENCIES

#undef CNTR_SAMPLE_SIZE

#undef TRIGGER_LEVEL

#undef GATE_TIME

#undef TIMEOUT



#define NUM_FREQUENCIES  3

typedef int frequency_array____[NUM_FREQUENCIES];

#define HIGH            0

#define LOW             1

typedef frequency_array____ syn_array__[2];

#define CNTR_SAMPLE_SIZE  10

#define TIMEOUT         1.00e-03

#define GATE_TIME       0.0e+00

#define START_LEVEL     0.6e+00

#define STOP_LEVEL      0.6e+00

#define SIGMA_MULTIPLIER  6.0e+00

const frequency_array____ FREQUENCIES____ = {5250000, 19750000, 40000000};

const syn_array__ SYN_FREQ__ =

{

  { 5000000, 10000000, 40000000},

  {10000000, 20000000, 40000000}

};



//------------------------------------------------------------------------------

void t9060(int mod_id, int /* slot */)

{

  /*SYNC TO CLOCK RANGE, & JITTER*/

  int loop;



  double cntr_actual_frequency;

  double cntr_actual_min;

  double cntr_actual_max;

  double cntr_max_minus_min;

  double actual_sigma;



  test_result_type result;

  int debug_connect_module;

  int temp_debug_connect_module;

  void (*p2c_temp)(int mod_id);



  /* ----------------------------------------------------------------------- */



  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();

    OpenResourceManager();
	open_33250A(mod_id);
	//open_mux(mod_id);
	open_34980A(mod_id);

    /*Added by chuanho to select syn model, 14jun2012*/
    /*--------------------------------------------*/
    if(check_syn_model())
	{
      enable_33250A_out(mod_id);
	  setup_33250A_defaults(mod_id);
	}
    else
      open_syn(mod_id);
  /*--------------------------------------------*/

    open_gen(mod_id);

    open_cntr(mod_id);

    setup_cntr_trg_levels(mod_id, START_LEVEL, STOP_LEVEL);

    connect_gen_trg_clkrb(mod_id);

    connect_cntr_stop_db1(mod_id);

    vth_mseq_stop(mod_id, TIMEOUT);



    vth_mclose_rly(debug_connect_module, MK2305);

        /* DBG1 to Mother Board relay */

    vth_mclose_rly(mod_id, MK2902);   /* CLKRB to Mint pins relay   */

    vth_mclose_rly(mod_id, MK2903);   /* CLKRSG to Mint pins relay  */



    vth_mtclk_clkrb_mux(mod_id);

    vth_mdbg_1_gtclk_mux(mod_id);

    vth_mtclk_sel_ris_edge(mod_id);



    p2c_temp = flush_commands;

    all_modules(p2c_temp);



    all_modules(&vth_mhsl_dis_hdbg1);   /* Enable HDBG1 through card  */



    all_modules(&flush_commands);



    if (debug_connect_module != mod_id)

      vth_mdbg_1_hdbg1_mux(debug_connect_module);



    all_modules(&flush_commands);



    vth_mhsl_en_hdbg1(mod_id);   /* Enable this mod driving HDBG1 */



    for (loop = 0; loop < NUM_FREQUENCIES; loop++)

    {

      for (int tclk_loop = HIGH; tclk_loop <= LOW; ++tclk_loop)

      {

        if (tclk_loop == HIGH || FREQUENCIES____[loop] < 40e06)

        {  /*if*/

		  if(check_syn_model())
			  setup_33250A_freq(mod_id, SYN_FREQ__[tclk_loop][loop]);
		  else
			  setup_syn_freq(mod_id, SYN_FREQ__[tclk_loop][loop]);

		  enable_gen_out(mod_id);

		  if (FREQUENCIES____[loop] <= 20e06)

          {  /*for frequencies <= 20MHz*/

            connect_syn_out_gen_ext(mod_id);

            vth_mtclk_set_freq(mod_id, static_cast<double>(FREQUENCIES____[loop]),

                           static_cast<double>(FREQUENCIES____[loop]));

          }  /*for frequencies <= 20MHz*/

          else

          {  /*Do 40MHz setup*/

            if(check_syn_model())
				connect_syn_out_gen_ext(mod_id);
			else
				connect_syn_aux_gen_ext(mod_id);


            vth_mtclk_set_freq(mod_id, static_cast<double>(FREQUENCIES____[loop]),

                           FREQUENCIES____[loop] / 2.0);

          }  /*Do 40MHz setup*/



          setup_cntr_function(mod_id, FREQUENCY);

          setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

          setup_cntr_gate_time(mod_id, GATE_TIME);

          trigger_cntr(mod_id);

          cntr_actual_frequency = read_cntr_mean(mod_id);

          result.Measurement_class = CLASS_REAL;

          result.UU.Real_result = cntr_actual_frequency;

          log_result(mod_id, result);



          setup_cntr_function(mod_id, PERIOD);

          setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

          trigger_cntr(mod_id);

          actual_sigma = read_cntr_sigma(mod_id) * SIGMA_MULTIPLIER;

          show_value(mod_id, "std", actual_sigma);



          cntr_actual_min = read_cntr_min(mod_id);

          show_value(mod_id, "min", cntr_actual_min);



          cntr_actual_max = read_cntr_max(mod_id);

          show_value(mod_id, "max", cntr_actual_max);



          cntr_max_minus_min = cntr_actual_max - cntr_actual_min;

          result.Measurement_class = CLASS_REAL;

          if (cntr_max_minus_min > actual_sigma)

            result.UU.Real_result = cntr_max_minus_min;

          else

            result.UU.Real_result = actual_sigma;

          log_result(mod_id, result);



          disable_gen_out(mod_id);



        }  /*if*/



      }



    }



    vth_minit(mod_id);

    vth_minit(debug_connect_module);

    close_34980A(mod_id);//close_mux(mod_id);

	if(check_syn_model())
		close_33250A(mod_id);
	else
		close_syn(mod_id);

    close_gen(mod_id);

    close_cntr(mod_id);

	CloseResourceManager();

  }  /*has debug ports*/



}  /*t9060*/

#undef NUM_FREQUENCIES

#undef HIGH

#undef LOW

#undef CNTR_SAMPLE_SIZE

#undef TIMEOUT

#undef GATE_TIME

#undef START_LEVEL

#undef STOP_LEVEL

#undef SIGMA_MULTIPLIER



#define NUM_FREQUENCIES  3

typedef int frequency_array_____[NUM_FREQUENCIES];

#define HIGH            0

#define LOW             1

typedef frequency_array_____ syn_array___[2];

#define CNTR_SAMPLE_SIZE  10

#define TIMEOUT         1.00e-03

#define GATE_TIME       0.0e+00

#define START_LEVEL     0.6e+00

#define STOP_LEVEL      0.6e+00

#define SIGMA_MULTIPLIER  6.0e+00

const frequency_array_____ FREQUENCIES_____ = {5250000, 19750000, 60000000};



const syn_array___ SYN_FREQ___ =

{

  { 5000000, 10000000, 60000000},

  {10000000, 20000000, 60000000}

};



//------------------------------------------------------------------------------

void t9061(int mod_id, int /* slot */)

{

  /*CONTROL PLUS - SYNC TO CLOCK RANGE, & JITTER*/

  int loop;



  double cntr_actual_frequency;

  double cntr_actual_min;

  double cntr_actual_max;

  double cntr_max_minus_min;

  double actual_sigma;



  test_result_type result;

  int debug_connect_module;

  int temp_debug_connect_module;



  /* ----------------------------------------------------------------------- */



  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();

    OpenResourceManager();
	open_33250A(mod_id);
	//open_mux(mod_id);
	open_34980A(mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
      open_syn(mod_id);
  /*--------------------------------------------*/

    open_gen(mod_id);

    open_cntr(mod_id);

    setup_cntr_trg_levels(mod_id, START_LEVEL, STOP_LEVEL);

    connect_gen_trg_clkrb(mod_id);

    connect_cntr_stop_db1(mod_id);



    vth_mseq_stop(mod_id, TIMEOUT);



    vth_mclose_rly(debug_connect_module, MK2305);

        /* DBG1 to Mother Board relay */

    vth_mclose_rly(mod_id, MK2902);   /* CLKRB to Mint pins relay   */

    vth_mclose_rly(mod_id, MK2903);   /* CLKRSG to Mint pins relay  */



    vth_mtclk_clkrb_mux(mod_id);

    vth_mdbg_1_gtclk_mux(mod_id);

    vth_mtclk_sel_ris_edge(mod_id);



    all_modules(&flush_commands);



    all_modules(&vth_mhsl_dis_hdbg1);   /* Enable HDBG1 through card  */



    all_modules(&flush_commands);



    if (debug_connect_module != mod_id)

      vth_mdbg_1_hdbg1_mux(debug_connect_module);



    all_modules(&flush_commands);



    vth_mhsl_en_hdbg1(mod_id);   /* Enable this mod driving HDBG1 */



    for (loop = 0; loop < NUM_FREQUENCIES; loop++)

    {

      for (int tclk_loop = HIGH; tclk_loop <= LOW; ++tclk_loop)

      {

        if (tclk_loop == HIGH || FREQUENCIES_____[loop] < 40e06)

        {  /*if*/

		  if(check_syn_model())
			  setup_33250A_freq(mod_id, SYN_FREQ___[tclk_loop][loop]);
		  else
			  setup_syn_freq(mod_id, SYN_FREQ___[tclk_loop][loop]);

		  enable_gen_out(mod_id);

          if (FREQUENCIES_____[loop] <= 20e06)

          {  /*for frequencies <= 20MHz*/

            connect_syn_out_gen_ext(mod_id);

            vth_mtclk_set_freq(mod_id, static_cast<double>(FREQUENCIES_____[loop]),

                           static_cast<double>(FREQUENCIES_____[loop]));

          }  /*for frequencies <= 20MHz*/

          else

          {  /*Do 60MHz setup*/

			  if(check_syn_model())
				  connect_syn_out_gen_ext(mod_id);
			  else
				  connect_syn_aux_gen_ext(mod_id);

            vth_mtclk_set_freq(mod_id, static_cast<double>(FREQUENCIES_____[loop]),

                           FREQUENCIES_____[loop] / 4.0);

          }  /*Do 60MHz setup*/



          setup_cntr_function(mod_id, FREQUENCY);

          setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

          setup_cntr_gate_time(mod_id, GATE_TIME);

          trigger_cntr(mod_id);

          cntr_actual_frequency = read_cntr_mean(mod_id);

          result.Measurement_class = CLASS_REAL;

          result.UU.Real_result = cntr_actual_frequency;

          log_result(mod_id, result);



          setup_cntr_function(mod_id, PERIOD);

          setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

          trigger_cntr(mod_id);

          actual_sigma = read_cntr_sigma(mod_id) * SIGMA_MULTIPLIER;

          show_value(mod_id, "std", actual_sigma);



          cntr_actual_min = read_cntr_min(mod_id);

          show_value(mod_id, "min", cntr_actual_min);



          cntr_actual_max = read_cntr_max(mod_id);

          show_value(mod_id, "max", cntr_actual_max);



          cntr_max_minus_min = cntr_actual_max - cntr_actual_min;

          result.Measurement_class = CLASS_REAL;

          if (cntr_max_minus_min > actual_sigma)

            result.UU.Real_result = cntr_max_minus_min;

          else

            result.UU.Real_result = actual_sigma;

          log_result(mod_id, result);



          disable_gen_out(mod_id);



        }  /*if*/



      }



    }



    vth_minit(mod_id);

    vth_minit(debug_connect_module);

    close_34980A(mod_id);//close_mux(mod_id);

    if(check_syn_model())
		close_33250A(mod_id);
	else
		close_syn(mod_id);

    close_gen(mod_id);

    close_cntr(mod_id);

	CloseResourceManager();

  }  /*has debug ports*/



}  /*t9061*/

#undef NUM_FREQUENCIES

#undef HIGH

#undef LOW

#undef CNTR_SAMPLE_SIZE

#undef TIMEOUT

#undef GATE_TIME

#undef START_LEVEL

#undef STOP_LEVEL

#undef SIGMA_MULTIPLIER



#define CNTR_SAMPLE_SIZE  1000

#define INPUT_FREQUENCY  80000000

#define OUTPUT_FREQUENCY  20000000

#define TIMEOUT         1.00e-03

#define GATE_TIME       0.1e+00

#define START_LEVEL     0.6e+00

#define STOP_LEVEL      0.6e+00

#define SIGMA_MULTIPLIER  6.0e+00

#define WAIT_TIME       100e-03

#define OSC_SUPPLY_VOLTAGE  5.0e+00

//------------------------------------------------------------------------------

void t9062(int mod_id, int /* slot */)

{

  /*CONTROL PLUS - 80MHz SYNC TO CLOCK, JITTER*/

  double cntr_actual_frequency;

  double cntr_actual_min;

  double cntr_actual_max;

  double cntr_max_minus_min;

  double actual_sigma;



  test_result_type result;

  int debug_connect_module;

  int temp_debug_connect_module;



  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();

	//open_mux(mod_id);
	open_34980A(mod_id);

    open_cntr(mod_id);

    setup_cntr_trg_levels(mod_id, START_LEVEL, STOP_LEVEL);

    connect_cntr_stop_db1(mod_id);

    vth_mseq_stop(mod_id, TIMEOUT);

    /* Setup the ASRU card to power the oscillator inside the fixture */

    vth_aclose_rly(mod_id, K818);

    vth_aclose_rly(mod_id, K759);

    vth_aclose_rly(mod_id, K814);

    vth_aclose_rly(mod_id, K760);

    vth_asrc_set_dc_ampl(mod_id, OSC_SUPPLY_VOLTAGE);

    vth_asrc_dis_30ma_ilim(mod_id);

    vth_afc_en_src_out(mod_id);



    /* Setup the input and output paths for the signal on the MAC card */

    vth_mclose_rly(debug_connect_module, MK2305);

        /* DBG1 to Mother Board relay */

    vth_mclose_rly(mod_id, MK2901);   /* CLKRA to Mint pins relay   */

    vth_mclose_rly(mod_id, MK2903);   /* CLKRSG to Mint pins relay  */



    /* Setup the internal signal routing, sync edge, and ratio */

    vth_mtclk_clkra_mux(mod_id);

    vth_mdbg_1_gtclk_mux(mod_id);

    vth_mtclk_sel_ris_edge(mod_id);

    vth_mtclk_set_freq(mod_id, static_cast<double>(INPUT_FREQUENCY), static_cast<double>(OUTPUT_FREQUENCY));



    /* Do the high speed link magic such that the signal is at the debug port */

    all_modules(flush_commands);

    all_modules(& vth_mhsl_dis_hdbg1);   /* Enable HDBG1 through card  */

    all_modules(&flush_commands);

    if (debug_connect_module != mod_id)

      vth_mdbg_1_hdbg1_mux(debug_connect_module);

    all_modules(&flush_commands);

    vth_mhsl_en_hdbg1(mod_id);   /* Enable this mod driving HDBG1 */



    vth_mtmr_wait(mod_id, WAIT_TIME);



    /* Make the frequency measurement with the counter */

    setup_cntr_function(mod_id, FREQUENCY);

    setup_cntr_gate_time(mod_id, GATE_TIME);

    vth_mtmr_wait(mod_id, 0.100);

    trigger_cntr(mod_id);

    cntr_actual_frequency = read_cntr_mean(mod_id);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = cntr_actual_frequency;

    log_result(mod_id, result);



    /* Make the sigma measurement with the counter */

    setup_cntr_function(mod_id, PERIOD);

    setup_cntr_sample_size(mod_id, CNTR_SAMPLE_SIZE);

    vth_mtmr_wait(mod_id, 0.300);   /*This much additional time is required */

    trigger_cntr(mod_id);

    actual_sigma = read_cntr_sigma(mod_id) * SIGMA_MULTIPLIER;



    /* Make the min and max measurements with the counter */

    cntr_actual_min = read_cntr_min(mod_id);

    cntr_actual_max = read_cntr_max(mod_id);

    cntr_max_minus_min = cntr_actual_max - cntr_actual_min;



    /* Log the greater of max-min or sigma*multiplier */

    result.Measurement_class = CLASS_REAL;

    if (cntr_max_minus_min > actual_sigma)

      result.UU.Real_result = cntr_max_minus_min;

    else

      result.UU.Real_result = actual_sigma;

    log_result(mod_id, result);



    vth_minit(mod_id);

    vth_minit(debug_connect_module);



    close_34980A(mod_id);//close_mux(mod_id);

    close_cntr(mod_id);



  }  /*has debug ports*/



}  /*t9062*/

#undef CNTR_SAMPLE_SIZE

#undef INPUT_FREQUENCY

#undef OUTPUT_FREQUENCY

#undef TIMEOUT

#undef GATE_TIME

#undef START_LEVEL

#undef STOP_LEVEL

#undef SIGMA_MULTIPLIER

#undef WAIT_TIME

#undef OSC_SUPPLY_VOLTAGE



#define MAX_VECTORS     32

#define STARTING_INPUT_FREQ  5750000

#define MAXIMUM_INPUT_FREQ  20000000

#define FREQ_INCREMENT  500000

#define EXECUTION_WAIT_TIME  10e-03

#define STOP_WAIT_TIME  1e-03

#define CLEAR_FREQ      5000000



/* static variables for t9065: */

struct LOC_t9065

{

  int    mod_id;

  int    slot;

  double gen_pwidth;

};



static void clear_log_ram(struct LOC_t9065* LINK)

{

  int mod_id = LINK->mod_id;

  int slot   = LINK->slot;

  LINK->gen_pwidth = 1.0 / CLEAR_FREQ / 2;

  open_33250A(LINK->mod_id); //Added by chuanho, 16jun2012

  if(check_syn_model())
  {
	  setup_33250A_defaults(LINK->mod_id);
	  setup_33250A_freq(LINK->mod_id, CLEAR_FREQ);
	  enable_33250A_out(mod_id);
  }
  else
	  setup_syn_freq(LINK->mod_id, CLEAR_FREQ);

  setup_gen_pwidth(LINK->mod_id, LINK->gen_pwidth);

  enable_gen_out(LINK->mod_id);



  /* Adding to give equip time to setup before taking measurement -gpm */

    vth_mtmr_wait(mod_id, 0.100);



  vth_mtclk_set_freq(LINK->mod_id, static_cast<double>(CLEAR_FREQ), CLEAR_FREQ * 2.0);



#include "t9065_clr.cmd"



  sales_start_sequencer_mac(LINK->mod_id);



  vth_mtmr_wait(LINK->mod_id, EXECUTION_WAIT_TIME);

  vth_mseq_stop(LINK->mod_id, STOP_WAIT_TIME);



  disable_gen_out(LINK->mod_id);



}  /*clear_log_ram*/

#undef CLEAR_FREQ



//------------------------------------------------------------------------------

void t9065(int mod_id, int slot)

{

  /*Sequencer Margin Test*/



  struct LOC_t9065 V;



  int loop;

  int input_freq;

  int expected_status;

  int expected_vector_count;



  boolean failure_occurred;



  char buffer[81];



  FILE *infile;



  int expected_srp_log_ram_result[MAX_VECTORS];

  int expected_stat_log_ram_result[MAX_VECTORS];



  test_result_type result;



  V.mod_id = mod_id;

  infile = NULL;

  slot = 2;

  V.slot = slot;



  sprintf(buffer, "%sseq_results", testwhere_path);

  infile = fopen(buffer, "r");



  if (infile == NULL)

    _EscIO(FileNotFound);



  fscanf(infile, "%d%*[^\n]", &expected_status);

  getc(infile);

  fscanf(infile, "%d%*[^\n]", &expected_vector_count);

  getc(infile);



  for (loop = 0; loop < MAX_VECTORS; loop++)

  {

    fscanf(infile, "%d%*[^\n]", &expected_srp_log_ram_result[loop]);

    getc(infile);

  }



  for (loop = 0; loop < MAX_VECTORS; loop++)

  {

    fscanf(infile, "%d%*[^\n]", &expected_stat_log_ram_result[loop]);

    getc(infile);

  }

  OpenResourceManager();
  open_33250A(V.mod_id);

  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(V.mod_id);
	setup_33250A_defaults(V.mod_id);
  }
  else
      open_syn(V.mod_id);
  /*--------------------------------------------*/

  open_gen(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);

  connect_syn_out_gen_ext(V.mod_id);

  connect_gen_trg_clkrb(V.mod_id);



  failure_occurred = false;

  input_freq = STARTING_INPUT_FREQ;



  vth_mclose_rly(V.mod_id, MK2902);   /* CLKRB to Mint pins relay   */

  vth_mclose_rly(V.mod_id, MK2903);   /* CLKRSG to Mint pins relay  */



  vth_mtclk_clkrb_mux(V.mod_id);

  vth_mtclk_sel_ris_edge(V.mod_id);



  while (!failure_occurred && input_freq <= MAXIMUM_INPUT_FREQ)

  {  /*while*/

    clear_log_ram(&V);



    input_freq += FREQ_INCREMENT;

    V.gen_pwidth = 1.0 / input_freq / 2;

    if(check_syn_model())
		setup_33250A_freq(V.mod_id, input_freq);
	else
		setup_syn_freq(V.mod_id, input_freq);

	setup_gen_pwidth(V.mod_id, V.gen_pwidth);

    enable_gen_out(V.mod_id);



/* Adding to give equip time to setup before taking measurement -gpm */

      vth_mtmr_wait(mod_id, 0.100);



    if (input_freq <= 10e06)

      vth_mtclk_set_freq(V.mod_id, static_cast<double>(input_freq), input_freq * 2.0);

    else

      vth_mtclk_set_freq(V.mod_id, 10e06, 20e06);



#include "t9065_vml.cmd"



    sales_start_sequencer_mac(V.mod_id);



    vth_mtmr_wait(V.mod_id, EXECUTION_WAIT_TIME);

    vth_mseq_stop(V.mod_id, STOP_WAIT_TIME);



    disable_gen_out(V.mod_id);



    vth_mseq_rd_seq_stat(V.mod_id);

    if (get_result_nolog(V.mod_id, &result))

    {

      if (result.UU.Integer_result != expected_status)

        failure_occurred = true;

    }

    else

      display_prompt("No result in result log (Expected seq status)", true);



    vth_mec_rd_vctr_cntr(V.mod_id);

    if (get_result_nolog(V.mod_id, &result))

    {

      if (result.UU.Integer_result != expected_vector_count)

        failure_occurred = true;

    }

    else

      display_prompt("No result in result log (Expected vector count)", true);



    vth_mseq_rd_srp_log_ram(V.mod_id, 0, expected_vector_count);

    for (loop = 0; loop < expected_vector_count; loop++)

    {

      if (get_result_nolog(V.mod_id, &result))

      {

        if (result.UU.Integer_result != expected_srp_log_ram_result[loop])

          failure_occurred = true;

      }

      else

        display_prompt("No result in result log (Expected srp log RAM)", true);

    }



    vth_mseq_rd_stat_log_ram(V.mod_id, 0, expected_vector_count);

    for (loop = 0; loop < expected_vector_count; loop++)

    {

      if (get_result_nolog(V.mod_id, &result))

      {

        if (result.UU.Integer_result != expected_stat_log_ram_result[loop])

          failure_occurred = true;

      }

      else

        display_prompt("No result in result log (Expected stat log RAM)",

                       true);

    }



  }  /*while*/



  result.Measurement_class = CLASS_REAL;

  result.UU.Real_result = input_freq * 2.0;

  log_result(V.mod_id, result);

  if(check_syn_model())
	  close_33250A(V.mod_id);
  else
	  close_syn(V.mod_id);

  close_gen(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);

  CloseResourceManager();


  if (infile != NULL)

    fclose(infile);

}  /*t9065*/

#undef MAX_VECTORS

#undef STARTING_INPUT_FREQ

#undef MAXIMUM_INPUT_FREQ

#undef FREQ_INCREMENT

#undef EXECUTION_WAIT_TIME

#undef STOP_WAIT_TIME



#define TIMEOUT         1.0e-03

#define STOP_WAIT       100.0e-03

#define CLOCK_FREQUENCY  12.5e+06

#define T0_ADVANCE      165.9e-9

#define PRIOR           0

#define POST_           1

#define LOW             0

#define HIGH            1

//------------------------------------------------------------------------------

void t9070(int mod_id, int slot)

{

  /*USER TIME AT 12.5MHz GUARANTEED > 40nS*/

  int channel_no;

  int mux_node_pin;

  int werrs['H' + 1 - 'A'];

  int channel;

  test_result_type result;





  //open_mux(mod_id);
  open_34980A(mod_id);

  break_test_for_function_step_compatability(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /* for */

    switch (channel)

    {   /*Use mux_node_pins closest to the grounds*/



    case 'A':

    case 'B':

    case 'E':

    case 'F':

      mux_node_pin = 7;

      break;



    case 'C':

    case 'D':

    case 'G':

    case 'H':

      mux_node_pin = 0;

      break;

    default:

      assert(false);

      break;



    }/*case*/

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);

  }  /* for */

  close_pin_gnd_relays(mod_id, slot);



  vth_mdclk_0_set_freq(mod_id, CLOCK_FREQUENCY);

  vth_mtclk_dutclk_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, CLOCK_FREQUENCY, CLOCK_FREQUENCY);

  vth_mtclk_set_adv_time(mod_id, T0_ADVANCE);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  for (int level = LOW; level <= HIGH; ++level)

  {

    for (int receive = PRIOR; receive <= POST_; ++receive)

    {  /*for receive*/

      for (channel = 'A'; channel <= 'H'; channel++)

      {  /* for channel */

        channel_no = channel - 'A';

        sales_reset_sequencer(mod_id, slot);

        if (receive == PRIOR)

        {

          /* This vml code sets the receive 10nS prior to the next drive */

          if (level == LOW)

          {

#include "t9070l_pri.cmd"

          }

          else /*level = high*/

          {

#include "t9070h_pri.cmd"

          }

        }

        else  /* receive must be equal to post */

        {

          /* This vml code sets the receive 10nS after the drive */

          if (level == LOW)

          {

#include "t9070l_pos.cmd"

          }

          else /*level = high*/

          {

#include "t9070h_pos.cmd"

          }

        }



        vth_pfc_sel_arcv0(mod_id, slot, channel_no, 3);   /* ARCV0 = RRESP */

        vth_pfc_sel_arcv1(mod_id, slot, channel_no, 4);   /* ARCV1 = WERR  */

        sales_start_sequencer(mod_id, slot);

        vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

        vth_mseq_stop(mod_id, TIMEOUT);

        vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_log(mod_id, &result))

          display_prompt("No result in result log (Expected RRESP)", true);

        vth_mmbd_rd_arcv1(mod_id);

        if (get_result_nolog(mod_id, &result))

        {  /*if*/

          werrs[channel - 'A'] = result.UU.Integer_result;

        }  /*if*/

        else

          display_prompt("No result in result log (Expected WERR)", true);



      }  /* for channel */





      for (channel = 'A'; channel <= 'H'; channel++)

      {   /*for*/

        result.UU.Integer_result = werrs[channel - 'A'];

        log_result(mod_id, result);

      }  /*for*/



      /*log the window error results*/



    }  /*for receive*/



  }



  vth_pinit(mod_id, slot);

  vth_mopen_all_rlys(mod_id);



  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9070 */

#undef TIMEOUT

#undef STOP_WAIT

#undef CLOCK_FREQUENCY

#undef T0_ADVANCE

#undef PRIOR

#undef POST_

#undef LOW

#undef HIGH



#define TIMEOUT         1.0e-03

#define STOP_WAIT       100.0e-03

#define CLOCK_FREQUENCY  12.5e+06

#define T0_ADVANCE      165.9e-9

#define PRIOR           0

#define POST_           1

#define LOW             0

#define HIGH            1

//------------------------------------------------------------------------------

void t9071(int mod_id, int slot)

{

  /*USER TIME AT 12.5MHz GUARANTEED > 30nS*/

  int channel_no;

  int mux_node_pin;

  int werrs['H' + 1 - 'A'];

  int channel;

  test_result_type result;




  OpenResourceManager();  // fikri added 9/05/2024
  //open_mux(mod_id);
  open_34980A(mod_id);

  break_test_for_function_step_compatability(mod_id);

  flush_commands(mod_id);


  for (channel = 'A'; channel <= 'H'; channel++)

  {  /* for */

    switch (channel)

    {   /*Use mux_node_pins closest to the grounds*/



    case 'A':

    case 'B':

    case 'E':

    case 'F':

      mux_node_pin = 7;

      break;



    case 'C':

    case 'D':

    case 'G':

    case 'H':

      mux_node_pin = 0;

      break;

    default:

      assert(false);

      break;



    }/*case*/

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);

  }  /* for */

  close_pin_gnd_relays(mod_id, slot);



  vth_mdclk_0_set_freq(mod_id, CLOCK_FREQUENCY);

  vth_mtclk_dutclk_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, CLOCK_FREQUENCY, CLOCK_FREQUENCY);

  vth_mtclk_set_adv_time(mod_id, T0_ADVANCE);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  for (int level = LOW; level <= HIGH; ++level)

  {

    for (int receive = PRIOR; receive <= POST_; ++receive)

    {  /*for receive*/

      for (channel = 'A'; channel <= 'H'; channel++)

      {  /* for channel */

        channel_no = channel - 'A';

        sales_reset_sequencer(mod_id, slot);

        if (receive == PRIOR)

        {

          /* This vml code sets the receive 10nS prior to the next drive */

          if (level == LOW)

          {

#include "t9071l_pri.cmd"

          }

          else /*level = high*/

          {

#include "t9071h_pri.cmd"

          }

        }

        else /* receive must be equal to post */

        {

          /* This vml code sets the receive 10nS after the drive */

          if (level == LOW)

          {

#include "t9071l_pos.cmd"

          }

          else  /*level = high*/

          {

#include "t9071h_pos.cmd"

          }

        }



        vth_pfc_sel_arcv0(mod_id, slot, channel_no, 3);   /* ARCV0 = RRESP */

        vth_pfc_sel_arcv1(mod_id, slot, channel_no, 4);   /* ARCV1 = WERR  */

        sales_start_sequencer(mod_id, slot);

        vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

        vth_mseq_stop(mod_id, TIMEOUT);

        vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_log(mod_id, &result))

          display_prompt("No result in result log (Expected RRESP)", true);

        vth_mmbd_rd_arcv1(mod_id);

        if (get_result_nolog(mod_id, &result))

        {  /*if*/

          werrs[channel - 'A'] = result.UU.Integer_result;

        }  /*if*/

        else

          display_prompt("No result in result log (Expected WERR)", true);



      }  /* for channel */





      for (channel = 'A'; channel <= 'H'; channel++)

      {   /*for*/

        result.UU.Integer_result = werrs[channel - 'A'];

        log_result(mod_id, result);

      }  /*for*/



      /*log the window error results*/



    }  /*for receive*/



  }



  vth_pinit(mod_id, slot);

  vth_mopen_all_rlys(mod_id);



  close_34980A(mod_id);//close_mux(mod_id);
   CloseResourceManager();


}  /* t9071 */

#undef TIMEOUT

#undef STOP_WAIT

#undef CLOCK_FREQUENCY

#undef T0_ADVANCE

#undef PRIOR

#undef POST_

#undef LOW

#undef HIGH



#define TIMEOUT         1.0e-03

#define STOP_WAIT       100.0e-03

#define CLOCK_FREQUENCY  12.5e+06

#define T0_ADVANCE      165.9e-9

#define PRIOR           0

#define POST_           1

#define LOW             0

#define HIGH            1

//------------------------------------------------------------------------------

void t9072(int mod_id, int slot)

{

  /*USER TIME AT 12.5MHz GUARANTEED > 20nS*/

  int channel_no;

  int mux_node_pin;

  int werrs['H' + 1 - 'A'];

  int channel;

  test_result_type result;



  //open_mux(mod_id);
  open_34980A(mod_id);

  break_test_for_function_step_compatability(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /* for */

    switch (channel)

    {   /*Use mux_node_pins closest to the grounds*/



    case 'A':

    case 'B':

    case 'E':

    case 'F':

      mux_node_pin = 7;

      break;



    case 'C':

    case 'D':

    case 'G':

    case 'H':

      mux_node_pin = 0;

      break;

    default:

      assert(false);

      break;



    }/*case*/

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);

  }  /* for */

  close_pin_gnd_relays(mod_id, slot);



  vth_mdclk_0_set_freq(mod_id, CLOCK_FREQUENCY);

  vth_mtclk_dutclk_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, CLOCK_FREQUENCY, CLOCK_FREQUENCY);

  vth_mtclk_set_adv_time(mod_id, T0_ADVANCE);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  for (int level = LOW; level <= HIGH; ++level)

  {

    for (int receive = PRIOR; receive <= POST_; ++receive)

    {  /*for receive*/

      for (channel = 'A'; channel <= 'H'; channel++)

      {  /* for channel */

        channel_no = channel - 'A';

        sales_reset_sequencer(mod_id, slot);

        if (receive == PRIOR)

        {

          /* This vml code sets the receive 10nS prior to the next drive */

          if (level == LOW)

          {

#include "t9072l_pri.cmd"

          }

          else        /*level = high*/

          {

#include "t9072h_pri.cmd"

          }

        }

        else        /* receive must be equal to post */

        {

          /* This vml code sets the receive 10nS after the drive */

          if (level == LOW)

          {

#include "t9072l_pos.cmd"

          }

          else        /*level = high*/

          {

#include "t9072h_pos.cmd"

          }

        }



        vth_pfc_sel_arcv0(mod_id, slot, channel_no, 3);   /* ARCV0 = RRESP */

        vth_pfc_sel_arcv1(mod_id, slot, channel_no, 4);   /* ARCV1 = WERR  */

        sales_start_sequencer(mod_id, slot);

        vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

        vth_mseq_stop(mod_id, TIMEOUT);

        vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_log(mod_id, &result))

          display_prompt("No result in result log (Expected RRESP)", true);

        vth_mmbd_rd_arcv1(mod_id);

        if (get_result_nolog(mod_id, &result))

        {  /*if*/

          werrs[channel - 'A'] = result.UU.Integer_result;

        }  /*if*/

        else

          display_prompt("No result in result log (Expected WERR)", true);



      }  /* for channel */



      for (channel = 'A'; channel <= 'H'; channel++)

      {

      /*for*/

        result.UU.Integer_result = werrs[channel - 'A'];

        log_result(mod_id, result);

      }  /*for*/



      /*log the window error results*/



    }  /*for receive*/



  }



  vth_pinit(mod_id, slot);

  vth_mopen_all_rlys(mod_id);



  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9072 */

#undef TIMEOUT

#undef STOP_WAIT

#undef CLOCK_FREQUENCY

#undef T0_ADVANCE

#undef PRIOR

#undef POST_

#undef LOW

#undef HIGH



typedef double control_array_type[2];

#define RISING_         0

#define FALLING_        1

#define MAX_            0

#define MIN_            1

#define RATIO_NUMBER    0

#define T0_NOM          160e-9

#define SYNC_ADVANCE    5.9e-9

const control_array_type TCLK_ADVANCE = {T0_NOM + SYNC_ADVANCE, SYNC_ADVANCE};

const control_array_type ET_DELAY = {100e-9, -30e-9};

const control_array_type NOM_FREQ = {10e6, 7.69e6};

const control_array_type ET_SEARCH_ADVANCE = {0.0, T0_NOM};

#define LARGE_STEP      2e-9

#define SMALL_STEP      250e-12

#define ET1A_MASK       127

#define SEARCH_ESTIMATE  4e-9

#define SEARCH_LIMIT    20e-9

#define CNTR_MEASUREMENT_TIME  0.10

//------------------------------------------------------------------------------

void t9075(int mod_id, int)

{

  /* Event trigger range/accuracy */

  int event;

  int strg;



  double first;

  double last;

  double freq;



  boolean toggling;

  boolean bogus;



  test_result_type result;

  int debug_connect_module;

  int temp_debug_connect_module;



  char   id_string[MAX_S_LENGTH + 1]; //for reproducing t9000 purposes

  struct LOC_t9000 V;

  char   str1[256];



  /* ----------------------------------------------------------------------- */





  temp_debug_connect_module = get_system_debug_port();

  if (temp_debug_connect_module != -1)

  {  /*has debug ports*/

    debug_connect_module = get_system_debug_port();



//    t9000noprint();

/////////////////////////////////////////////////////

    OpenResourceManager();
	open_33250A(mod_id);
  /*Added by chuanho to select syn model, 14jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
      open_syn(mod_id);
  /*--------------------------------------------*/

	//open_mux(mod_id);
  open_34980A(mod_id);

    open_gen(mod_id);


//mjs -- temporary fix for t9075 to ensure that we have period of 100ns on trig out pulse

    vth_mhpib_wr(mod_id, 3, ":ARM:EWID ON");

    open_cntr(mod_id);



    result.Measurement_class = CLASS_REAL;



    connect_syn_out_gen_ext(mod_id);

    connect_gen_trg_clkrb(mod_id);

    connect_cntr_stop_db1(mod_id);



    vth_mclose_rly(debug_connect_module, MK2305);

        /* DBG1 to Mother Board relay */

    vth_mclose_rly(mod_id, MK2902);   /* CLKRB to Mint pins relay   */

    vth_mclose_rly(mod_id, MK2903);   /* CLKRSG to Mint pins relay  */

    vth_mclose_rly(mod_id, MK1801);   /* ET1A  to MINT pins */

    vth_mdbg_1_et_strg_mux(mod_id);



    all_modules(&flush_commands);

    all_modules(&vth_mhsl_dis_hdbg1);

    all_modules(&flush_commands);

    if (debug_connect_module != mod_id)

      vth_mdbg_1_hdbg1_mux(debug_connect_module);

    all_modules(&flush_commands);



    vth_mhsl_en_hdbg1(mod_id);

    vth_mtclk_clkrb_mux(mod_id);

    vth_mtclk_sel_ris_edge(mod_id);

    vth_met_init(mod_id);

    vth_met_set_trg_cnd(mod_id, ET1A_MASK);

    vth_met_en(mod_id);

    vth_mseq_run(mod_id);

    vth_mtclk_gtclk_set_ratio(mod_id, RATIO_NUMBER);



    for (int edge = RISING_; edge <= FALLING_; ++edge)

    {  /* for edge */

      if (edge == FALLING_)

      {

        vth_mtclk_sel_fal_edge(mod_id);

        event = 0;   /* Event false */

      }

      else

      {

        vth_mtclk_sel_ris_edge(mod_id);

        event = 1;   /* Event true */

      }



      for (int delay = MAX_; delay <= MIN_; ++delay)

      {  /* for delay */

        bogus = false;

        vth_mseq_ass_prog_mode(mod_id);

        vth_met_set_t0_trg_dly(mod_id, ET_DELAY[delay]);

        vth_mseq_ass_run_mode(mod_id);



        freq = 1.0 / (1.0 / NOM_FREQ[delay] + SEARCH_ESTIMATE);

            /* estimate */

        show_value(mod_id, "initial freq", freq);

        if(check_syn_model())
			setup_33250A_freq(mod_id, round(freq));
		else
			setup_syn_freq(mod_id, round(freq));

		vth_mtclk_set_freq(mod_id, freq, freq);

        vth_mtclk_set_adv_time(mod_id, TCLK_ADVANCE[delay]);



        vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);



        toggling = counter_measurement_pending(mod_id);



        sales_show_state(mod_id, "initial toggle", toggling);



        vth_met_tst_et_strg(mod_id);

        if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

        else

          display_prompt("No result in result log (Expected STRG)", true);



        if (event == strg || toggling)   /* bad estimate */

        {  /* reprogram for full limit */

          sales_show_state(mod_id, "reprogram for full limit, toggle", toggling);



          freq = 1.0 / (1.0 / NOM_FREQ[delay] + SEARCH_LIMIT);

          show_value(mod_id, "full limit freq", freq);

          if(check_syn_model())
		  {
			  setup_33250A_freq(mod_id, round(freq));
			  enable_33250A_out(mod_id);
		  }
		  else
			  setup_syn_freq(mod_id, round(freq));

          vth_mtclk_set_freq(mod_id, freq, freq);

          vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);

          toggling = counter_measurement_pending(mod_id);

          sales_show_state(mod_id, "full limit toggle", toggling);

          vth_met_tst_et_strg(mod_id);

          if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

          else

            display_prompt("No result in result log (Expected STRG)", true);



        }  /* reprogram for full limit */



        /* -----  MAIN LOOP ------------------------------------------------------ */



        if (event != strg && !toggling)

        {  /* if valid event */

          while (!toggling &&

                 1.0 / freq >= 1.0 / NOM_FREQ[delay] - SEARCH_LIMIT &&

                 event != strg)

          {  /* while searching */

            freq = 1.0 / (1.0 / freq - LARGE_STEP);

            show_value(mod_id, "1st search loop freq", freq);

            if(check_syn_model())
			{
			  setup_33250A_freq(mod_id, round(freq));
			  enable_33250A_out(mod_id);
			}
		    else
			  setup_syn_freq(mod_id, round(freq));

            vth_mtclk_set_freq(mod_id, freq, freq);

            vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);

            toggling = counter_measurement_pending(mod_id);

            sales_show_state(mod_id, "1st search loop toggle", toggling);

            vth_met_tst_et_strg(mod_id);

            if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

            else

              display_prompt("No result in result log (Expected STRG)", true);



          }  /* while searching */



          /*

          if (toggling) then

                  display_prompt('1st fin because toggling',true);

          if (event=strg) then

                  display_prompt('1st fin because event=strg',true);

          if (1.0/freq)<(1.0/nom_freq[ord(delay)]-search_limit) then

                  display_prompt('1st fin because out of range',true);

          */



          if (toggling || event == strg)

          {  /* if toggling */

            freq = 1.0 / (1.0 / freq + LARGE_STEP - SMALL_STEP);

            show_value(mod_id, "backed up freq", freq);

            if(check_syn_model())
			{
			  setup_33250A_freq(mod_id, round(freq));
			  enable_33250A_out(mod_id);
			}
		    else
			  setup_syn_freq(mod_id, round(freq));

            vth_mtclk_set_freq(mod_id, freq, freq);

            vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);

            toggling = counter_measurement_pending(mod_id);

            sales_show_state(mod_id, "backed up toggle", toggling);

            vth_met_tst_et_strg(mod_id);

            if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

            else

              display_prompt("No result in result log (Expected STRG)", true);



            while (!toggling &&

                   1.0 / freq >= 1.0 / NOM_FREQ[delay] - SEARCH_LIMIT &&

                   event != strg)

            {  /* while searching */

              freq = 1.0 / (1.0 / freq - SMALL_STEP);

              show_value(mod_id, "2nd search freq", freq);

			  if(check_syn_model())
			  {
				setup_33250A_freq(mod_id, round(freq));
				enable_33250A_out(mod_id);
			  }
		      else
				setup_syn_freq(mod_id, round(freq));

              vth_mtclk_set_freq(mod_id, freq, freq);

              vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);

              toggling = counter_measurement_pending(mod_id);

              sales_show_state(mod_id, "2nd search toggle", toggling);

              vth_met_tst_et_strg(mod_id);

              if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

              else

                display_prompt("No result in result log (Expected STRG)",

                               true);

            }  /* while searching */

            /* -----  END MAIN LOOP -------------------------------------------------- */

            first = 1.0 / round(freq) - ET_SEARCH_ADVANCE[delay];

            result.Measurement_class = CLASS_REAL;

            result.UU.Real_result = first;

            log_result(mod_id, result);



          }  /* if toggling */

          else

          {  /*value is bogus*/

            bogus = true;

            display_prompt("No Valid Event Trigger Signal Measured", true);

            result.Measurement_class = CLASS_REAL;

            result.UU.Real_result = 0.0;

                /* dummy result assigned and logged */

            log_result(mod_id, result);

            log_result(mod_id, result);

            log_result(mod_id, result);

          }  /*value is bogus*/





          /* -----  SECOND   LOOP -------------------------------------------------- */



          if (!bogus)

          {  /*search for the other value and the delta*/

            while ((toggling || event != strg) &&

                   1.0 / freq >= 1.0 / NOM_FREQ[delay] - SEARCH_LIMIT)

            {  /* while searching */

              freq = 1.0 / (1.0 / freq - SMALL_STEP);

              show_value(mod_id, "end search freq", freq);

              if(check_syn_model())
			  {
				setup_33250A_freq(mod_id, round(freq));
			    enable_33250A_out(mod_id);
			  }
		      else
				setup_syn_freq(mod_id, round(freq));

              vth_mtclk_set_freq(mod_id, freq, freq);

              vth_mtmr_wait(mod_id, CNTR_MEASUREMENT_TIME);

              toggling = counter_measurement_pending(mod_id);

              sales_show_state(mod_id, "end search toggle", toggling);

              vth_met_tst_et_strg(mod_id);

              if (get_result_nolog(mod_id, &result))

        {

          strg = result.UU.Integer_result;

        }

              else

                display_prompt("No result in result log (Expected STRG)",

                               true);



            }  /* while searching */





            /* -----  END SECOND LOOP ------------------------------------------------ */



            last = 1.0 / round(freq) - ET_SEARCH_ADVANCE[delay];

            result.Measurement_class = CLASS_REAL;

            result.UU.Real_result = last;

            log_result(mod_id, result);

            result.UU.Real_result = first - last;

            log_result(mod_id, result);

          }  /*search for the other value and the delta*/

        }  /* if valid event */

        else

        {  /* else no valid event */

          display_prompt("No Valid Event Trigger Signal Measured", true);

          result.Measurement_class = CLASS_REAL;

          result.UU.Real_result = 0.0;

              /* dummy result assigned and logged */

          log_result(mod_id, result);

          log_result(mod_id, result);

          log_result(mod_id, result);

        }  /* else no valid event */



      }  /* for delay */

    }  /* for edge */





    vth_minit(mod_id);

    close_34980A(mod_id);//close_mux(mod_id);

    vth_mtmr_wait(mod_id, 5);

	if(check_syn_model())
		close_33250A(mod_id);
	else
		close_syn(mod_id);

    vth_mtmr_wait(mod_id, 5);
    vth_mhpib_wr(mod_id, 3, ":ARM:EWID OFF");
    vth_mhpib_wr(mod_id, 3, ":SYST:ERR?");
    vth_mhpib_rd(mod_id, 3);
    vth_read_string_result(id_string, mod_id, &V);
    sprintf(str1, "%.2s", id_string);
    if (!strcmp(str1, "+0"))
	    display_prompt(" ", true);
    else
	    display_prompt("   Generator did not reset at end of test.  Try again or Test Number Entry", true);

    close_gen(mod_id);
    vth_mtmr_wait(mod_id, 5);
    close_cntr(mod_id);
    vth_mtmr_wait(mod_id, 5);


  }  /*has debug ports*/

  CloseResourceManager();

}  /* t9075 */

#undef RISING_

#undef FALLING_

#undef MAX_

#undef MIN_

#undef RATIO_NUMBER

#undef T0_NOM

#undef SYNC_ADVANCE

#undef LARGE_STEP

#undef SMALL_STEP

#undef ET1A_MASK

#undef SEARCH_ESTIMATE

#undef SEARCH_LIMIT

#undef CNTR_MEASUREMENT_TIME



//------------------------------------------------------------------------------

/* Test 9080 is the Sales version of DGN test 1204. It was decided to duplicate

*  test 1204 into Sales to ensure the Tap Port is tested prior to shipment due

*  to this functionality not being turned on at release. Future plans for this

*  test is a fixture change (PVF and/or Sales) which will require a test change.

*  11/19/01: Dowd: Removed reading from TDO comparitor due to stability problems

*/

void t9080(int mod_id, int slot)

{

  int bit;



  vth_write(mod_id+2, 0x00480000, 0xF080);  // Setting relays signal side

  vth_write(mod_id+2, 0x004A0000, 0x8000);  // Setting relays ground side

  vth_write(mod_id+2, 0x004A0002, 0xC0C0);  // Setting relays ground side



  vth_write_integer(mod_id+2, 0x00120400, 0x01);  // 5Volt no backmatch

  vth_read_integer(mod_id+2, 0x00120400);



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  }



  vth_write_integer(mod_id+2, 0x00120400, 0x02);  // 5Volt w/ backmatch

  vth_read_integer(mod_id+2, 0x00120400);



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  }



  /* Dowd 3/28/02: Commented out redundant looping

  vth_write_integer(mod_id+2, 0x00120400, 0x03);   //1.5-3.3Volt no backmatch

  vth_write_integer(mod_id+2, 0x00120418, 0x045E); //1.5V DAC A

  vth_write_integer(mod_id+2, 0x00120418, 0x0C5E); //1.5V DAC B



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  }



  vth_write_integer(mod_id+2, 0x00120400, 0x04);   //1.5-3.3Volt w/backmatch

  vth_write_integer(mod_id+2, 0x00120418, 0x045E); //1.5V DAC A

  vth_write_integer(mod_id+2, 0x00120418, 0x0C5E); //1.5V DAC B



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  }



  vth_write_integer(mod_id+2, 0x00120400, 0x03);   //1.5-3.3Volt no backmatch

  vth_write_integer(mod_id+2, 0x00120418, 0x04CE); //3.3V DAC A

  vth_write_integer(mod_id+2, 0x00120418, 0x0CCE); //3.3V DAC B



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  }



  vth_write_integer(mod_id+2, 0x00120400, 0x04);   //1.5-3.3Volt w/backmatch

  vth_write_integer(mod_id+2, 0x00120418, 0x04CE); //3.3V DAC A

  vth_write_integer(mod_id+2, 0x00120418, 0x0CCE); //3.3V DAC B



  for (bit = 0; bit <= 2; bit++)

  {

    vth_write_integer(mod_id+2, 0x00120404, bit); // TCK

    vth_read_integer(mod_id+2, 0x00120404); // TCK

    //vth_write_integer(mod_id+2, 0x00120414, 0x01);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120408, bit); // TDI

    vth_read_integer(mod_id+2, 0x00120408); // TDI

    //vth_write_integer(mod_id+2, 0x00120414, 0x02);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x0012040C, bit); // TMS

    vth_read_integer(mod_id+2,0x0012040C); // TMS

    //vth_write_integer(mod_id+2, 0x00120414, 0x03);

    //vth_read_integer(mod_id+2, 0x0012041C);

    vth_write_integer(mod_id+2, 0x00120410, bit); // TRST

    vth_read_integer(mod_id+2, 0x00120410); // TRST

    //vth_write_integer(mod_id+2, 0x00120414, 0x04);

    //vth_read_integer(mod_id+2, 0x0012041C);

  } */



} /*t9080*/



//------------------------------------------------------------------------------

/* Test 9081 reads the version of the code within the sequencer.

 * This value will change often during development!

 */

void t9081(int mod_id, int slot)

{

  vth_read_integer(mod_id+2, 0x00120600);

} /*t9081*/



//------------------------------------------------------------------------------

// Test 9082 verifies ROM, RAM, PIT, MFP, and SONIC pass bist

void t9082(int mod_id,int slot)

{

  vth_mrd_byte(mod_id, 0x00560003); //RAM

} /* end t9082 */



#define SYN_FREQ____    20000000

#define RECEIVER_NO     0

#define RECEIVE_LEVEL   1.5e+00

#define GEN_PWIDTH      25e-09

//------------------------------------------------------------------------------

void t9090(int mod_id, int slot)

{

  test_result_type result; //added by chuanho, 22jul2011

  /*TIC VERIFY THROUGH PIN CARD - FREQUENCY MODE*/

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
	  setup_33250A_freq(mod_id, SYN_FREQ____);
  else
	  setup_syn_freq(mod_id, SYN_FREQ____);
  /*--------------------------------------------*/

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

  connect_gen_out_af2(mod_id);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL to XGL on pin card */

  vth_pclose_rly(mod_id, slot, KGLA);   /* XLG to DR0 bus */

  vth_pclose_rly(mod_id, slot, K1A);   /* DR0 mint pin relay */

  vth_pclose_rly(mod_id, slot, K10A);   /* R0 mint pin relay */

  vth_pclose_rly(mod_id, slot, KRA);   /* Reciver connect relay */

  vth_prcv_set_hi(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);

  vth_prcv_set_lo(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);

  vth_mclose_rly(mod_id, MK1601);   /* TIC A relay */

  vth_mclose_rly(mod_id, MK1606);   /* TIC B relay */

  vth_pfc_sel_arcv0(mod_id, slot, 0, 1);   /* ARCV0 = GTH0 */

  vth_pfc_sel_arcv1(mod_id, slot, 0, 1);   /* ARCV1 = GTH0 */

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);

  vth_mmbd_en_arcv(mod_id);

  vth_mtic_a_arcv0_mux(mod_id);

  vth_mtic_b_arcv1_mux(mod_id);

  enable_gen_out(mod_id);

  /* Adding to give equip time to setup before taking measurement -gpm */

  vth_mtmr_wait(mod_id, 0.100);

  vth_mtic_sel_long_gate(mod_id);

  vth_mtic_freq_a_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_sel_shrt_gate(mod_id);

  vth_mtic_freq_a_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  vth_mtic_freq_b_meas(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected TIC reading)", true);

  disable_gen_out(mod_id);

  vth_ainit(mod_id);

  vth_minit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9090*/

#undef SYN_FREQ____

#undef RECEIVER_NO

#undef RECEIVE_LEVEL

#undef GEN_PWIDTH



#define SYN_FREQ____    20000000

#define RECEIVER_NO     0

#define RECEIVE_LEVEL   1.5e+00

#define GEN_PWIDTH      25e-09

//------------------------------------------------------------------------------

void t9091(int mod_id, int slot)

{

  /*TIC VERIFY THROUGH PIN CARD - TI FREQUENCY MODE*/

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
	  setup_33250A_freq(mod_id, SYN_FREQ____);
  else
	  setup_syn_freq(mod_id, SYN_FREQ____);

  /*--------------------------------------------*/

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

  connect_gen_out_af2(mod_id);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL to XGL on pin card */

  vth_pclose_rly(mod_id, slot, KGLA);   /* XLG to DR0 bus */

  vth_pclose_rly(mod_id, slot, K1A);   /* DR0 mint pin relay */

  vth_pclose_rly(mod_id, slot, K10A);   /* R0 mint pin relay */

  vth_pclose_rly(mod_id, slot, KRA);   /* Reciver connect relay */

  vth_prcv_set_hi(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);

  vth_prcv_set_lo(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);

  vth_mclose_rly(mod_id, MK1601);   /* TIC A relay */

  vth_mclose_rly(mod_id, MK1606);   /* TIC B relay */

  vth_pfc_sel_arcv0(mod_id, slot, 0, 1);   /* ARCV0 = GTH0 */

  vth_pfc_sel_arcv1(mod_id, slot, 0, 1);   /* ARCV1 = GTH0 */

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);

  vth_mmbd_en_arcv(mod_id);

  vth_mtic_a_arcv0_mux(mod_id);

  vth_mtic_b_arcv1_mux(mod_id);

  enable_gen_out(mod_id);

  vth_mtic_sel_long_gate(mod_id);

  vth_mtic_ti_abrr_one_meas(mod_id);

  vth_mtic_sel_shrt_gate(mod_id);

  vth_mtic_ti_abrr_one_meas(mod_id);

  vth_mtic_sel_long_gate(mod_id);

  vth_mtic_ti_abff_one_meas(mod_id);

  vth_mtic_sel_shrt_gate(mod_id);

  vth_mtic_ti_abff_one_meas(mod_id);

  disable_gen_out(mod_id);

  vth_minit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/


  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9091*/

#undef SYN_FREQ____

#undef RECEIVER_NO

#undef RECEIVE_LEVEL

#undef GEN_PWIDTH



#define SAMPLES         100

#define RECEIVER_NO     0

#define SYN_FREQ____    20000000

#define RECEIVE_LEVEL   1.5e+00

#define GEN_PWIDTH      25e-09

//------------------------------------------------------------------------------

void t9092(int mod_id, int slot)

{

  /*TIC VERIFY THROUGH PIN CARD - TI MODE*/

  double actual_pos_pulse;

  double actual_neg_pulse;

  double tic_pos_pulse_lg;

  double tic_pos_pulse_sg;

  double tic_neg_pulse_lg;

  double tic_neg_pulse_sg;


  test_result_type result;

  OpenResourceManager();
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    setup_33250A_freq(mod_id, SYN_FREQ____);
  else
    setup_syn_freq(mod_id, SYN_FREQ____);
  /*--------------------------------------------*/

  setup_gen_pwidth(mod_id, GEN_PWIDTH);

//change input mpedance to 1 Mega

  vth_mhpib_wr(mod_id, 4, ":INP1:IMP 1E6");

  connect_gen_out_cntr_ch1(mod_id);

  enable_gen_out(mod_id);

  /* use cntr to measure 'golden' values for the positive and negative pulse widths

     output from the generator to be compared against values measured by

     the TIC.   abr 7/98  */

  setup_cntr_function(mod_id, PWID);

  vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

  actual_pos_pulse = read_cntr(mod_id);

  setup_cntr_function(mod_id, NWID);

  vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

  actual_neg_pulse = read_cntr(mod_id);

  disable_gen_out(mod_id);

  connect_gen_out_af2(mod_id);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL to XGL on pin card */

  vth_pclose_rly(mod_id, slot, KGLA);   /* XLG to DR0 bus */

  vth_pclose_rly(mod_id, slot, K1A);   /* DR0 mint pin relay */

  vth_pclose_rly(mod_id, slot, K10A);   /* R0 mint pin relay */

  vth_pclose_rly(mod_id, slot, KRA);   /* Reciver connect relay */

  vth_prcv_set_hi(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);

  vth_prcv_set_lo(mod_id, slot, RECEIVER_NO, RECEIVE_LEVEL);



  vth_mclose_rly(mod_id, MK1601);   /* TIC A relay */

  vth_mclose_rly(mod_id, MK1606);   /* TIC B relay */



  vth_pfc_sel_arcv0(mod_id, slot, 0, 1);   /* ARCV0 = GTH0 */

  vth_pfc_sel_arcv1(mod_id, slot, 0, 1);   /* ARCV1 = GTH0 */



  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);

  vth_mmbd_en_arcv(mod_id);

  vth_mtic_a_arcv0_mux(mod_id);

  vth_mtic_b_arcv1_mux(mod_id);



  enable_gen_out(mod_id);



  /* Deleted gate time selection because it doesn't make sense with ti mode

     04/14/92 JRM per similar changes to T9052 10/28/91 */

  vth_mtic_ti_abrf_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {

    tic_pos_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_lg - actual_pos_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* Deleted gate time selection because it doesn't make sense with ti mode

     04/14/92 JRM per similar changes to T9052 10/28/91 */

  vth_mtic_ti_abrf_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {

    tic_pos_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_pos_pulse_sg - actual_pos_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  /* Deleted gate time selection because it doesn't make sense with ti mode

     04/14/92 JRM per similar changes to T9052 10/28/91 */

  vth_mtic_ti_abfr_fast_meas(mod_id, SAMPLES);

  if (get_result_nolog(mod_id, &result))

  {

    tic_neg_pulse_lg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_lg - actual_neg_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);



  /* Deleted gate time selection because it doesn't make sense with ti mode

     04/14/92 JRM per similar changes to T9052 10/28/91 */

  vth_mtic_ti_abfr_one_meas(mod_id);

  if (get_result_nolog(mod_id, &result))

  {

    tic_neg_pulse_sg = result.UU.Real_result;

    result.UU.Real_result = tic_neg_pulse_sg - actual_neg_pulse;

    log_result(mod_id, result);

  }

  else

    display_prompt("No result in result log (Expected tic reading)", true);





  disable_gen_out(mod_id);

  vth_minit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9092*/

#undef SAMPLES

#undef RECEIVER_NO

#undef SYN_FREQ____

#undef RECEIVE_LEVEL

#undef GEN_PWIDTH



#define DRIVER_NO       0

#define NUMBER_OF_SAMPLES  20

#define SLEW_RATE       275e+00

#define ILIM            100e-03

#define DRIVE_LO_LEVEL  0.2e+00

#define DRIVE_HI_LEVEL  3.5e+00

#define SIGMA_MULTIPLIER  6.0e+00

#define DUT_CLK_FREQ    20e+06

//------------------------------------------------------------------------------

void t9095(int mod_id, int slot)

{

  /*USER CLOCK GENERATION ACCURACY, & JITTER THROUGH PIN CARD*/



  int loop;

  int n;

  double trigger_level;

  double exi;

  double exi_sqr;

  double std_dev;

  double jitter;

  double frequency;

  double duty_cycle;

  double period;

  test_result_type result;



  n = 0;

  exi = 0.0;

  exi_sqr = 0.0;

  OpenResourceManager(); //added by Fikri, 3/07/2024


  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);



  vth_mmbd_en_adrv(mod_id);

  connect_cntr_ch1_af2(mod_id);



  vth_pdrv_set_sr(mod_id, slot, DRIVER_NO, SLEW_RATE);

  vth_pdrv_set_il(mod_id, slot, DRIVER_NO, ILIM);

  vth_pfc_set_dd_cntl(mod_id, slot, DRIVER_NO, 1);

      /* Set DD0 control to ADRV0 */

  vth_pfc_set_sttc_tsp(mod_id, slot, DRIVER_NO, 0);   /* Set TSP0 control to 0 */



  vth_pclose_rly(mod_id, slot, KDA);   /* DR0 connect relay */

  vth_pclose_rly(mod_id, slot, KGLA);   /* DR0 to XGL bus */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XGL to XL bus */

  vth_pdrv_set_lo(mod_id, slot, DRIVER_NO, DRIVE_LO_LEVEL);

  vth_pdrv_set_hi(mod_id, slot, DRIVER_NO, DRIVE_HI_LEVEL);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay */

  flush_commands(mod_id); //added fikri 15/5/2024
  vth_mtmr_wait(mod_id, 3.0); /* add for stabilize new Fun Gen 33250 Fikri 26/06/2024*/


  vth_mdclk_0_set_freq(mod_id, DUT_CLK_FREQ);

  vth_mseq_neg_cpu_tsp(mod_id);



  vth_pdrv_clr_err(mod_id, slot);



  trigger_level = 1.5;

  vth_mtmr_wait(mod_id, 0.5);   /* Added 7/28/89 for 1E+38 problem */



// the precision of this test is slowing it down 20 seconds.  It can be changed

// by lowering the number of digits precision from 9 - 6 for example

  vth_mhpib_wr(mod_id, 4, ":CONF:FREQ");
  vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:START:SOUR IMM");
  vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:STOP:SOUR DIG");
  vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:STOP:DIG 9");
  vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

  frequency = read_cntr(mod_id);

  result.Measurement_class = CLASS_REAL;
  result.UU.Real_result = frequency;
  log_result(mod_id, result);

  vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'DCYCLE'");
  trigger_cntr(mod_id);

  duty_cycle  = read_cntr(mod_id);

  result.Measurement_class = CLASS_REAL;

  result.UU.Real_result = duty_cycle*100;

  log_result(mod_id, result);



  /*Setup to measure the 50% level so that I can set the trigger level

    to the same value.  Then measure the period variance at the trigger

    level*/



  for (loop = 1; loop <= NUMBER_OF_SAMPLES; loop++)

  { // for loop

//The following 3 lines set the number of digits in the precision

// the precision of this test is slowing it down 20 seconds.  It can be changed

// by lowering the number of digits precision from 9 - 6 for example

    vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:START:SOUR IMM");

    vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:STOP:SOUR DIG");

    vth_mhpib_wr(mod_id, 4, ":SENSE:FREQ:ARM:STOP:DIG 9");

    vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'PER 1'");

    trigger_cntr(mod_id);

    period = read_cntr(mod_id);



    n++;

    exi +=period;

    exi_sqr += period * period;



  } //for loop closing



/***************************************************************

The standard deviation was originally calculated using the

following statement:

  std_dev = sqrt((n * exi_sqr - exi * exi) / (n * (n - 1)));

However, given the order of magnitude of the measurements was

so small, the sqrt would sometimes give imaginary numbers as

answers so we used the absolute value to make sure that this

did not happen, but that the difference would still be taken

into consideration

****************************************************************/
  vth_mtmr_wait(mod_id, 1.0); /* add for stabilize new Fun Gen 33250 Fikri 26/06/2024*/

  std_dev = sqrt((abs(n * exi_sqr - exi * exi)) / (n * (n - 1)));

  jitter = std_dev * SIGMA_MULTIPLIER;

  result.Measurement_class = CLASS_REAL;

  result.UU.Real_result = jitter;

  log_result(mod_id, result);



  vth_minit(mod_id);



  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager(); //added by Fikri, 3/07/2024


}  /*t9095*/

#undef DRIVER_NO

#undef NUMBER_OF_SAMPLES

#undef SLEW_RATE

#undef ILIM

#undef DRIVE_LO_LEVEL

#undef DRIVE_HI_LEVEL

#undef SIGMA_MULTIPLIER

#undef DUT_CLK_FREQ



#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL   5.0e+00   /* drive hi level */

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9100(int mod_id, int slot)

{

  /* DR OUT V RANGE AND ACCURACY (5v DRIVE HI) */



  /* For path and test descriptions, see the documentation for test: 9100 */

  int channel_no;



  int driver;

  test_result_type result;



  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_dmm_pin(mod_id, slot);

  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  close_pin_gnd_relays(mod_id, slot);

  flush_commands(mod_id); //added fikri 15/5/2024

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    channel_no = driver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

  }  /* for driver */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    vth_mseq_neg_cpu_tsp(mod_id);
    vth_mtmr_wait(mod_id, 0.1); //added fikri 29/5/2024


    flush_commands(mod_id); //added fikri 15/5/2024

    vth_mtmr_wait(mod_id, 0.2); //added fikri 29/5/2024

    measure_dmm(mod_id);


    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected DMM reading)", true);

    flush_commands(mod_id); //added fikri 15/5/2024
	vth_mseq_ass_cpu_tsp(mod_id);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

  }  /* for driver */

  flush_commands(mod_id); //added fikri 15/5/2024


	vth_pinit(mod_id, slot);
  flush_commands(mod_id); //added fikri 15/5/2024



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  /*t9100*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL

#undef DMM_FUNCTION



#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL   (-3.5e+00)   /* drive hi level */

#define DMM_FUNCTION    DCV

/*t*/

//------------------------------------------------------------------------------

void t9101(int mod_id, int slot)

{

  /* [PINCARD] DR OUT V RANGE AND ACCURACY (-3.5v DRIVE HI) */



  /* For path and test descriptions, see the documentation for test: 9100 */

  int channel_no;



  int driver;

  test_result_type result;





  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_dmm_pin(mod_id, slot);

  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  close_pin_gnd_relays(mod_id, slot);

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    channel_no = driver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pdrv_set_hi(mod_id, slot, channel_no, VOLTAGE_LEVEL);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

  }  /* for driver */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    vth_mseq_neg_cpu_tsp(mod_id);

    measure_dmm(mod_id);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected DMM reading)", true);

    vth_mseq_ass_cpu_tsp(mod_id);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

  }  /* for driver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9101*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL

#undef DMM_FUNCTION



#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL   (-3.5e+00)   /* drive lo level */

#define DMM_FUNCTION    DCV

/*t*/

//------------------------------------------------------------------------------

void t9102(int mod_id, int slot)

{

  /* DR OUT V RANGE AND ACCURACY (-3.5V DRIVE LO) */



  /* For path and test descriptions, see the documentation for test: 9100 */

  int channel_no;



  int driver;

  test_result_type result;




  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_dmm_pin(mod_id, slot);

  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  close_pin_gnd_relays(mod_id, slot);

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    channel_no = driver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);

  }  /* for driver */


  vth_mseq_neg_cpu_tsp(mod_id); //for Heron - ANT

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    /*vth_mseq_neg_cpu_tsp(mod_id);*/ //for Heron - ANT

	vth_mtmr_wait(mod_id, 0.2);//added thru ANT's request for Heron

    measure_dmm(mod_id);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected DMM reading)", true);

    /*vth_mseq_ass_cpu_tsp(mod_id);*/ //for Heron - ANT

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

  }  /* for driver */

  vth_mseq_ass_cpu_tsp(mod_id); //for Heron - ANT

  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  /*t9102*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL

#undef DMM_FUNCTION



#define RANGE           5   /* for dmm */

#define MUX_NODE_PIN    2   /* 2 of 0 thru 8 */

#define RESOLUTION      1.0e-03   /* for dmm */

#define VOLTAGE_LEVEL   5.0e+00   /* drive lo level */

#define DMM_FUNCTION    DCV

/*t*/

//------------------------------------------------------------------------------

void t9103(int mod_id, int slot)

{

  /* [PINCARD] DR OUT V RANGE AND ACCURACY (5.0V DRIVE LO) */



  /* For path and test descriptions, see the documentation for test: 9100 */

  int channel_no;



  int driver;

  test_result_type result;





  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_dmm_pin(mod_id, slot);

  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  close_pin_gnd_relays(mod_id, slot);

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    channel_no = driver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pdrv_set_lo(mod_id, slot, channel_no, VOLTAGE_LEVEL);

    vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 0);

  }  /* for driver */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for driver */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    vth_mseq_neg_cpu_tsp(mod_id);

    measure_dmm(mod_id);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected DMM reading)", true);

    vth_mseq_ass_cpu_tsp(mod_id);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

  }  /* for driver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9103*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef VOLTAGE_LEVEL

#undef DMM_FUNCTION



#define RANGE           1   /* for dmm */

#define RESOLUTION      1.0e-06   /* for dmm */

#define DMM_FUNCTION    DCV

/*t*/

//------------------------------------------------------------------------------

void t9104(int mod_id, int slot)

{

  /*GROUND DIFFERENCE TEST*/

  test_result_type result;






  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  dconnect_minus_swd_gnd(mod_id);

  close_pin_gnd_relays(mod_id, slot);
  flush_commands(mod_id); //fikri added 19/06/2024
  vth_aclose_rly(mod_id, K761);   /*SWDGND relay*/
  flush_commands(mod_id); //fikri added 19/06/2024

  vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

  flush_commands(mod_id); //fikri added 19/06/2024
  vth_mtmr_wait(mod_id, 1.0);  //fikri added 19/06/2024


  measure_dmm(mod_id);

  if (!get_result_log(mod_id, &result))

    display_prompt("No result in result log (Expected DMM reading)", true);



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  /*t9104*/

#undef RANGE

#undef RESOLUTION

#undef DMM_FUNCTION



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        50

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  1.75e+00

#define TRIGGER_LEVEL   1.75e+00

#define TIMEBASE_RANGE  90e-09

#define TIMEBASE_OFFSET  0.0e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20e+06

#define TCLK_FREQ       20e+06

#define AVERAGING       true

#define TIMEBASE_MODE   AUTOMATIC

/*t*/

//------------------------------------------------------------------------------

void t9105(int mod_id, int slot)

{

  /* [PINCARD] DR OUTPUT SLEW RATE (225V/uS) */



  /* For path and test descriptions, see the documentation for test: 9105 */

  /* DEBUG */

  int mask;

  double slew_time;

  double slew_voltage;

  double slew_rate;



  int driver;

  test_result_type result;





  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  /* DEBUG */

  mask = 224;

  /*MSG*/

  /*RQS*/

  /*ERR*/

  /* DEBUG */

  setup_osc_srq_mask(mod_id, mask);



  connect_osc_ch1_af2(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay      */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay      */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common connection */

  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, TCLK_FREQ);



  break_test_for_function_step_compatability(mod_id);

#include "t9105_vml.cmd"



  for (int edge = POS; edge >= NEG; --edge)

  {  /* for edge */

    setup_osc_trigger(mod_id, OSC_CHANNEL, edge, TRIGGER_LEVEL, AVERAGING);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      slew_rate = 0.0;

      slew_voltage = 0.0;

      slew_time = 1.0;



      sales_reset_sequencer(mod_id, slot);



      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      sales_start_sequencer(mod_id, slot);



      trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

      setup_osc_vmarkers_slew_rate(mod_id, edge);

      measure_osc(mod_id, DELTA_T, edge);

      if (get_result_nolog(mod_id, &result))

        slew_time = result.UU.Real_result;

      else

        display_prompt("Unable to vth_read rise time from the oscilloscope.",

                       true);



      measure_osc(mod_id, DELTA_V, edge);

      if (get_result_nolog(mod_id, &result))

        slew_voltage = result.UU.Real_result;

      else

        display_prompt("Unable to vth_read delta V from the oscilloscope.", true);



      vth_mseq_stop(mod_id, TIMEOUT);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      if (slew_time != 0)   /* To avoid divide by 0 */

        slew_time = slew_time * 1000000;   /* Convert seconds to uS */

      else

        slew_time = INT_MAX;

      slew_rate = slew_voltage / slew_time;

      result.UU.Real_result = slew_rate;

      log_result(mod_id, result);

    }  /* for driver */





  }  /* for edge */





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9105*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TIMEOUT

#undef INPUT_FREQ

#undef TCLK_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE



#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20e+06

#define TCLK_FREQ       20e+06

/*t*/

//------------------------------------------------------------------------------

void t9106(int mod_id, int slot)

{

  /* [PINCARD] DR OUTPUT SLEW RATE (100V/uS) */



  /* For path and test descriptions, see the documentation for test: 9105 */

  double slew_time;

  double slew_voltage;

  double slew_rate;

  int driver;



  test_result_type result;



  double voltage_max;

  double voltage_min;

  double vmax;

  double vmin;



  open_cntr(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_cntr_ch1_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   // XL to AF2 relay

  vth_aclose_rly(mod_id, K764);   // XL to AF2 relay

  vth_pclose_rly(mod_id, slot, KDCL);   // XL common connection

  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, TCLK_FREQ);



  break_test_for_function_step_compatability(mod_id);

#include "t9106_vml.cmd"



  for (int edge = POS; edge >= NEG; --edge)

  {  // for edge



  // setup counter

    vth_mhpib_wr(mod_id, 4, ":INP:ATT 10");    // x10 attenuation????????

    vth_mhpib_wr(mod_id, 4, ":INP:COUP DC");    // DC input coupling

    vth_mhpib_wr(mod_id, 4, ":INP:IMP 50");     // 50 ohm input impedance



    for (driver = 'A'; driver <= 'H'; driver++)

    {  // for driver

      slew_rate = 0.0;

      slew_voltage = 0.0;

      slew_time = 1.0;



      sales_reset_sequencer(mod_id, slot);

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      if (edge == POS)

        vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'RTIME'"); // rise time

      else

        vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'FTIME'"); // fall time



      vth_mhpib_wr(mod_id, 4, ":INIT:IMM"); // initiate measurement immediately

      sales_start_sequencer(mod_id, slot);

      slew_time = read_cntr(mod_id);

//      display_it(mod_id, "slew time = ", 0, slew_time);



       vth_mhpib_wr(mod_id, 4, ":CONF:MAX");

       vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'VOLT:MAX'");

       vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

       vmax = read_cntr(mod_id);

//       display_it(mod_id, "vmax = ", 0, vmax);



       vth_mhpib_wr(mod_id, 4, ":CONF:MIN");

       vth_mhpib_wr(mod_id, 4, ":SENSE:FUNC 'VOLT:MIN'");

       vth_mhpib_wr(mod_id, 4, ":INIT:IMM");

       vmin = read_cntr(mod_id);

//       display_it(mod_id, "vmin = ", 0, vmin);





       // we multiply by .1 because we need 10% of the voltage difference

       // since the voltage difference is taken with a 10% limit

       voltage_min = vmin + 0.1 * (vmax - vmin);

       voltage_max = vmax - 0.1 * (vmax - vmin);

       slew_voltage = voltage_max - voltage_min;

       //  display_it(mod_id, "slew_voltage = ", 0, slew_voltage);



      vth_mseq_stop(mod_id, TIMEOUT);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);





      if (slew_time == 0) slew_time = INT_MAX; /* To avoid divide by 0 */

      if (slew_time > 0)  slew_time *=(1000000);  /* Convert seconds to absolute value uS */

      if (slew_time <0)   slew_time *=(-1000000);  /* Convert seconds to absolute value uS */



      slew_rate = slew_voltage / slew_time;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = slew_rate;

      log_result(mod_id, result);

    }  // for driver





  }  // for edge





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  // t9106

#undef WHAT_STRING_

#undef TIMEOUT

#undef INPUT_FREQ

#undef TCLK_FREQ



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        50

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  1.75e+00

#define TRIGGER_LEVEL   1.75e+00

#define TIMEBASE_RANGE  200e-09

#define TIMEBASE_OFFSET  0.0e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20e+06

#define TCLK_FREQ       20e+06

#define AVERAGING       true

#define TIMEBASE_MODE   AUTOMATIC

/*t*/

//------------------------------------------------------------------------------

void t9107(int mod_id, int slot)

{

  /* [PINCARD] DR OUTPUT SLEW RATE (50V/uS) */



  /* For path and test descriptions, see the documentation for test: 9105 */

  double slew_time;

  double slew_voltage;

  double slew_rate;

  int driver;

  test_result_type result;



  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_osc_ch1_af2(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay      */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay      */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common connection */

  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, TCLK_FREQ);



  break_test_for_function_step_compatability(mod_id);

#include "t9107_vml.cmd"



  for (int edge = POS; edge >= NEG; --edge)

  {  /* for edge */

    setup_osc_trigger(mod_id, OSC_CHANNEL, edge, TRIGGER_LEVEL, AVERAGING);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      slew_rate = 0.0;

      slew_voltage = 0.0;

      slew_time = 1.0;



      sales_reset_sequencer(mod_id, slot);

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      sales_start_sequencer(mod_id, slot);



      trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

      setup_osc_vmarkers_slew_rate(mod_id, edge);

      measure_osc(mod_id, DELTA_T, edge);

      if (get_result_nolog(mod_id, &result))

        slew_time = result.UU.Real_result;

      else

        display_prompt("Unable to vth_read rise time from the oscilloscope.",

                       true);



      measure_osc(mod_id, DELTA_V, edge);

      if (get_result_nolog(mod_id, &result))

        slew_voltage = result.UU.Real_result;

      else

        display_prompt("Unable to vth_read delta v from the oscilloscope.", true);



      vth_mseq_stop(mod_id, TIMEOUT);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      if (slew_time == 0) slew_time = INT_MAX; /* To avoid divide by 0 */

      if (slew_time > 0)  slew_time *=(1000000);  /* Convert seconds to absolute value uS */

      if (slew_time <0)   slew_time *=(-1000000);  /* Convert seconds to absolute value uS */



      slew_rate = slew_voltage / slew_time;

      result.UU.Real_result = slew_rate;

      log_result(mod_id, result);

    }  /* for driver */





  }  /* for edge */





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9107*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TIMEOUT

#undef INPUT_FREQ

#undef TCLK_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE



#define NUM_READINGS    1

#define TIMEOUT         1.0e-03

#define CURRENT_LIMIT   100e-03

#define HIGH_TRIGGER_LEVEL  1.3

#define LOW_TRIGGER_LEVEL  1.3

#define INPUT_FREQ      20e+06

#define TCLK_FREQ       20e+06

/*t*/

//------------------------------------------------------------------------------

void t9111(int mod_id, int slot)

{

  /*DRIVE OUTPUT MINIMUM PULSE WIDTH*/

  int driver_no;

  int loop;

  double sum;

  double mean;



  double readings[NUM_READINGS];



  int driver;

  test_result_type result;



  open_cntr(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_cntr_start_af2(mod_id);



  vth_mhpib_wr(mod_id, 4, ":Input1:Imp 50");



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay         */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay         */

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common connection    */

  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, TCLK_FREQ);



  break_test_for_function_step_compatability(mod_id);



  for (int pulse = NEG; pulse <= POS; ++pulse)

  {  /*for pulse*/

    if (pulse == NEG)

    {

      setup_cntr_function(mod_id, NWID);

      setup_cntr_trg_levels(mod_id, LOW_TRIGGER_LEVEL, HIGH_TRIGGER_LEVEL);

    }

    else

    {

      setup_cntr_function(mod_id, PWID);

      setup_cntr_trg_levels(mod_id, HIGH_TRIGGER_LEVEL, LOW_TRIGGER_LEVEL);

    }





    for (driver = 'A'; driver <= 'H'; driver++)

    {

      driver_no = driver - 'A';

      sales_reset_sequencer(mod_id, slot);



      if (pulse == NEG)

      {

#include "t9111np_nd.cmd"

      }

      else /* pulse must equal pos */

      {

#include "t9111pp_nd.cmd"

      }



      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      vth_pdrv_set_il(mod_id, slot, driver_no, CURRENT_LIMIT);



      sales_start_sequencer(mod_id, slot);



      sum = 0.0;

      for (loop = 0; loop < NUM_READINGS; loop++)

      {  /* for */

        trigger_cntr(mod_id);

        readings[loop] = read_cntr(mod_id);



      }  /* for */





      vth_mseq_stop(mod_id, TIMEOUT);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      for (loop = 0; loop < NUM_READINGS; loop++)

        sum += readings[loop];

      mean = sum / NUM_READINGS;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = mean;

      log_result(mod_id, result);





    }  /* for driver */





  }  /*for pulse*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_cntr(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9111*/

#undef NUM_READINGS

#undef TIMEOUT

#undef CURRENT_LIMIT

#undef HIGH_TRIGGER_LEVEL

#undef LOW_TRIGGER_LEVEL

#undef INPUT_FREQ

#undef TCLK_FREQ



typedef int delay_type_;

typedef double delay_array[2];

#define RISING_EDGE     1

#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

#define TIMEOUT         1.0e-03



const delay_array GEN_DELAY = {85e-09, 185e-09};

const delay_array PROG_DELAY = {0e-09, 100e-09};



/*DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

void t9120(int mod_id, int slot)

{

  int mapped_slot;

  int edge;

  int driver;



  delay_type_ offset_cal;

  delay_type_ programmed_delays;



  double drvr_delay_actual;

  double skew;

  double offset[2];

  double ch_delta['H' + 1 - 'A'][4];



  test_result_type result;

  vth_mtmr_wait(mod_id, 3); //added for Heron P4

  if (slot > 11)

    mapped_slot = slot - 11;

  else

    mapped_slot = slot;

  OpenResourceManager(); //added by chuanho, 18jul2011
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);



  for (offset_cal = 0; offset_cal <= 1; offset_cal++)

  {  /*offset_cal*/

//    display_it(mod_id, "offset cal is = ", offset_cal, 0);

//    display_it(mod_id, "GEN_DELAY is = ", 0, GEN_DELAY[offset_cal]);

    setup_gen_trg_out_delay(mod_id, GEN_DELAY[offset_cal]);

    enable_gen_out(mod_id);

    trigger_cntr(mod_id);

    offset[offset_cal] = read_cntr_mean(mod_id);

    disable_gen_out(mod_id);

  }  /*offset_cal*/



  connect_gen_trg_clkrb(mod_id);

  connect_cntr_start_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mhsl_1_init_master(mod_id);

  all_modules_but_me(mod_id, &vth_mhsl_1_init_passive);

  vth_mhsl_2_init_master(mod_id);

  all_modules_but_me(mod_id, &vth_mhsl_2_init_passive);

  vth_mdig_set_clkrb_master(mod_id, TCLK_FREQ, TCLK_FREQ, RISING_EDGE);



  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    setup_gen_trg_out_delay(mod_id, GEN_DELAY[(programmed_delays-1)]);

    if (programmed_delays == 1)

    {

#include "t9120_nd.cmd"

    }

    else

    {

#include "t9120_d.cmd"

    }



    for (int slope = NEG; slope <= POS; ++slope)

    {  /*for slope*/

      if (slope == POS)

        edge = RISING;

      else

        edge = FALLING;

      setup_cntr_trigger_slopes(mod_id, slope, POS);

      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        enable_gen_out(mod_id);



        vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



        sales_reset_sequencer(mod_id, slot);

        sales_start_sequencer(mod_id, slot);



        trigger_cntr(mod_id);

        drvr_delay_actual = read_cntr_mean(mod_id);



/*MIKE

//        display_it(mod_id, "edge = ", edge, 0);

//        display_it(mod_id, "programmed_delays -1= ", programmed_delays-1, 0);

//        display_it(mod_id, "mapped_slot -1 = ", slot-1, 0);

        display_it(mod_id, "offset[programmed_delays-1] = ", 0, offset[programmed_delays-1]);

        display_it(mod_id, "clkrb_delay[mod_id] = ", 0, clkrb_delay[mod_id]);

        display_it(mod_id, "drvr_delay_actual = ", 0, drvr_delay_actual);

        display_it(mod_id, "af2_start_delay[mod_id]", 0, af2_start_delay[mod_id]);

        display_it(mod_id, "af2_system_delay[mod_id] = ", 0,  af2_system_delay[mod_id] );

        display_it(mod_id, "slot_delay[mapped_slot - 1][edge] = ", 0, slot_delay[mapped_slot - 1][edge]);

        display_it(mod_id, "channel_delay[driver - 'A'] = ", 0, channel_delay[driver - 'A']);

        display_it(mod_id, "PROG_DELAY[(programmed_delays-1)] = ", 0, PROG_DELAY[(programmed_delays-1)]);

*/



        ch_delta[driver - 'A']

          [slope] = offset[(programmed_delays-1)] + clkrb_delay[mod_id] -

            drvr_delay_actual - af2_start_delay[mod_id] -

            af2_system_delay[mod_id] - slot_delay[mapped_slot - 1]

            [edge] - channel_delay[driver - 'A'] - PROG_DELAY[(programmed_delays-1)];



        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = ch_delta[driver - 'A'][slope];

        log_result(mod_id, result);

        vth_mseq_stop(mod_id, TIMEOUT);

        disable_gen_out(mod_id);

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      }  /* for driver */



    }  /* for slope */



    for (driver = 'A'; driver <= 'H'; driver++)

    {  /*CALCULATE SKEW*/

      skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

      result.UU.Real_result = skew;

      log_result(mod_id, result);



    }  /*CALCULATE SKEW*/







  }  /* for programmed_delays */

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

    /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011


}  /*t9120*/

#undef RISING_EDGE

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef TIMEOUT



#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

/* system actual t9 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

#define GEN_DELAY_1     85e-09

#define GEN_DELAY_2     185e-09

#define PROG_DELAY1     0.0e-09

#define PROG_DELAY2     100e-09



/*DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

void t9121(int mod_id, int slot)

{

  int offset_cal;

  int programmed_delays;

  int edge;

  int driver;



  double drvr_delay_actual;

  double skew;



  double offset[2];

  double ch_delta['H' + 1 - 'A'][4];



  test_result_type result;

  OpenResourceManager(); //added by chuanho, 18jul2011
  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
	enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);

  setup_gen_trg_out_delay(mod_id, GEN_DELAY_1);

  for (offset_cal = 0; offset_cal <= 1; offset_cal++)

  {  /*offset_cal*/
    enable_gen_out(mod_id);

    trigger_cntr(mod_id);

    offset[offset_cal] = read_cntr_mean(mod_id);

    disable_gen_out(mod_id);



    setup_gen_trg_out_delay(mod_id, GEN_DELAY_2);



  }  /*offset_cal*/





  connect_gen_trg_clkrb(mod_id);

  connect_cntr_start_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  close_pin_gnd_relays(mod_id, slot);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[4][driver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, T0_ACTUAL);



  setup_gen_trg_out_delay(mod_id, GEN_DELAY_1);



  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    for (int slope = NEG; slope <= POS; ++slope)

    {  /*for slope*/

      if (slope == POS)

        edge = RISING;

      else

        edge = FALLING;



      setup_cntr_trigger_slopes(mod_id, slope, POS);

      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        enable_gen_out(mod_id);



        sales_reset_sequencer(mod_id, slot);



        if (programmed_delays == 1)

        {

#include "t9120_nd.cmd"

        }

        else

        {

#include "t9120_d.cmd"

        }



        vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



        sales_start_sequencer(mod_id, slot);



        trigger_cntr(mod_id);

        drvr_delay_actual = read_cntr_mean(mod_id);



        if (programmed_delays == 1)

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[mod_id] -

                      drvr_delay_actual - af2_start_delay[mod_id] -

                      af2_system_delay[mod_id] - slot_delay[slot - 1]

                      [edge] - channel_delay[driver - 'A'] - PROG_DELAY1;

        else

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[mod_id] -

                      drvr_delay_actual - af2_start_delay[mod_id] -

                      af2_system_delay[mod_id] - slot_delay[slot - 1]

                      [edge] - channel_delay[driver - 'A'] - PROG_DELAY2;



        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = ch_delta[driver - 'A'][slope];

        log_result(mod_id, result);

        vth_mseq_stop(mod_id, TIMEOUT);

        disable_gen_out(mod_id);

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      }  /* for driver */



    }  /* for slope */





    for (driver = 'A'; driver <= 'H'; driver++)

    {  /*CALCULATE SKEW*/

      skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

      result.UU.Real_result = skew;

      log_result(mod_id, result);



    }  /*CALCULATE SKEW*/







    setup_gen_trg_out_delay(mod_id, GEN_DELAY_2);



  }  /* for programmed_delays */

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9121*/

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef T0_ACTUAL

#undef TIMEOUT

#undef GEN_DELAY_1

#undef GEN_DELAY_2

#undef PROG_DELAY1

#undef PROG_DELAY2



#define SYN_FREQ____    5000000

#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

/* system actual t9 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

#define BLANK_LINE      ""

//------------------------------------------------------------------------------

void t9122(int mod_id, int slot)

{

  /*DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

  int programmed_delays;

  test_result_type result;

  int driver;

  char buffer[81];

  OpenResourceManager(); //added by chuanho, 18jul2011

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_gen(mod_id);

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  connect_syn_out_gen_ext(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    setup_33250A_freq(mod_id, SYN_FREQ____);
  else
    setup_syn_freq(mod_id, SYN_FREQ____);
  /*--------------------------------------------*/

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_clkrb(mod_id);

  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  close_pin_gnd_relays(mod_id, slot);

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    close_pin_drvr_load_rlys(mod_id, slot, driver);

  }  /* for */

  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, T0_ACTUAL);

  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    sales_reset_sequencer(mod_id, slot);

    if (get_result_nolog(mod_id, &result))

      display_prompt("Unexpected Result Pending", true);

    display_prompt(BLANK_LINE, true);

    if (programmed_delays == 1)

    {

      display_prompt("Outputting 0 ns delay edges", true);

#include "t9120_nd.cmd"

    }

    else

    {

      display_prompt("Outputting 100 ns delay edges", true);

#include "t9120_d.cmd"

    }

    sales_start_sequencer(mod_id, slot);



    if (get_result_nolog(mod_id, &result))

      display_prompt("Unexpected Result Pending", true);

    display_prompt("Press <Return> or <Enter> when ready to continue", true);

    display_prompt(BLANK_LINE, true);

    get_user_answer(buffer, 80);



    vth_mseq_stop(mod_id, TIMEOUT);

  }  /* for programmed_delays */

  vth_pinit(mod_id, slot);

  vth_mopen_all_rlys(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_gen(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9122*/

#undef SYN_FREQ____

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef T0_ACTUAL

#undef TIMEOUT

#undef BLANK_LINE



#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

/* system actual t9 value */

#define TIMEOUT         1.0e-03

#define GEN_DELAY1      85e-09

#define GEN_DELAY2      185e-09

#define PROG_DELAY1     0.0e+00

#define PROG_DELAY2     100e-09

//------------------------------------------------------------------------------

void t9125(int *ms_list)

{

  /*MASTER/SLAVE DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

  int mapped_slot;

  int links_to_master;



  int programmed_delays;

  int offset_cal;

  int master_mod_id;

  int slave_mod_id;

  int slave_slot;



  double drvr_delay_actual;

  double skew;



  double offset[2];

  double ch_delta['H' + 1 - 'A'][4];



  int edge;

  test_result_type result;

  int driver;


  vth_mtmr_wait(3, 10); //added for Heron P4

  all_modules(&vth_mod_init_dgn);

  all_modules(&close_mac_mk2202);

  all_modules(&flush_commands);



/*

  display_it(2, "ms_list[0] = ", ms_list[0], ms_list[0]);

  display_it(2, "ms_list[1] = ", ms_list[1], ms_list[1]);

  display_it(2, "ms_list[2] = ", ms_list[2], ms_list[2]);

  display_it(2, "ms_list[3] = ", ms_list[3], ms_list[3]);

  display_it(2, "ms_list[4] = ", ms_list[4], ms_list[4]);

  display_it(2, "ms_list[5] = ", ms_list[5], ms_list[5]);

 */





// Disregard the following comments and reordering now that the vml code has been

// converted to 10.x and C++. It all works correctly now. 1998/06/05 Roger Coffin



// mjs - this reordering of the array had to be done so that the vml files included

//below would still work. they still use the old pascal array indexes so the arrays

//had to be reordered back to the pascal way

/*

  ms_list[4] = ms_list[3];

  ms_list[3] = ms_list[2];

  ms_list[2] = ms_list[1];

  ms_list[1] = ms_list[0];

*/

  master_mod_id = ms_list[0];

  slave_mod_id = ms_list[2];

  slave_slot = ms_list[3];

/*

  display_it(2, "ms_list[0] = ", ms_list[0], ms_list[0]);

  display_it(2, "ms_list[1] = ", ms_list[1], ms_list[1]);

  display_it(2, "ms_list[2] = ", ms_list[2], ms_list[2]);

  display_it(2, "ms_list[3] = ", ms_list[3], ms_list[3]);

  display_it(2, "ms_list[4] = ", ms_list[4], ms_list[4]);

  display_it(2, "ms_list[5] = ", ms_list[5], ms_list[5]);

*/

  if (slave_slot > 11)

    mapped_slot = slave_slot - 11;

  else

    mapped_slot = slave_slot;

  links_to_master = slave_links_to_master(master_mod_id, slave_mod_id);



//display_it(2, "links_to_master = ", links_to_master, links_to_master);

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(master_mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(master_mod_id);
	setup_33250A_defaults(master_mod_id);
  }
  else
    open_syn(master_mod_id);
  /*--------------------------------------------*/

  open_gen(master_mod_id);

  //open_mux(master_mod_id);
  open_34980A(master_mod_id);

  open_cntr(master_mod_id);

  connect_syn_out_gen_ext(master_mod_id);

  setup_gen_levels(master_mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(master_mod_id);

  connect_gen_out_cntr_stop(master_mod_id);

  setup_gen_trg_out_delay(master_mod_id, GEN_DELAY1);



  for (offset_cal = 0; offset_cal <= 1; offset_cal++)

  {  /*offset_cal*/

    enable_gen_out(master_mod_id);

    trigger_cntr(master_mod_id);

    offset[offset_cal] = read_cntr_mean(master_mod_id);

    disable_gen_out(master_mod_id);

    setup_gen_trg_out_delay(master_mod_id, GEN_DELAY2);

  }  /*offset_cal*/



  connect_gen_trg_clkrb(master_mod_id);

  connect_cntr_start_af2(slave_mod_id);

  all_modules(&flush_commands);





  /* MASTER MODULE SETUP COMMANDS */



  vth_mclose_rly(master_mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(master_mod_id, MK2903);   /* clkrsg path relay */

  vth_mtclk_clkrb_mux(master_mod_id);

  vth_mtclk_sel_ris_edge(master_mod_id);

  vth_mtclk_set_freq(master_mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mhsl_en_out_tclk(master_mod_id);

  vth_mopen_rly(master_mod_id, MK2202);

  vth_mclose_rly(master_mod_id, MK2201);   /* hsl divider network */

  vth_mtclk_set_cal_adv_time(master_mod_id, 0);



  /* SLAVE MODULE SETUP COMMANDS */



  vth_mtclk_tclkina_mux(slave_mod_id);

  vth_mtclk_sel_ris_edge(slave_mod_id);

  vth_mtclk_set_freq(slave_mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_cal_adv_time(slave_mod_id, links_to_master);



  /* SLAVE AIM SETUP */



  vth_aclose_rly(slave_mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(slave_mod_id, K764);   /* XL to AF2 path */



  /* SLAVE PIN SETUP */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(slave_mod_id, slave_slot, PIN_KD_RLYS[driver - 'A']);

  }  /* for */

  vth_pclose_rly(slave_mod_id, slave_slot, KDCL);



  flush_commands(master_mod_id);

  flush_commands(slave_mod_id);



  setup_gen_trg_out_delay(slave_mod_id, GEN_DELAY1);



  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    for (int slope = NEG; slope <= POS; ++slope)

    {  /* for slope */

      if (slope == POS)

        edge = RISING;

      else

        edge = FALLING;



      setup_cntr_trigger_slopes(slave_mod_id, slope, POS);

      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        enable_gen_out(slave_mod_id);

        sales_reset_sequencer(slave_mod_id, slave_slot);



  flush_commands(master_mod_id);

  flush_commands(slave_mod_id);



        if (programmed_delays == 1)

        {

#include "t9125_nd.cmd"

        }

        else

        {

#include "t9125_d.cmd"

        }



        vth_pclose_rly(slave_mod_id, slave_slot, PIN_KGL_RLYS[driver - 'A']);



        sales_start_sequencer(slave_mod_id, slave_slot);



//display_prompt("about to trigger counter", true);

        trigger_cntr(slave_mod_id);

        drvr_delay_actual = read_cntr_mean(slave_mod_id);

//display_it(2, "drvr_delay_actual = ", drvr_delay_actual, drvr_delay_actual);



        if (programmed_delays == 1)

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[master_mod_id] -

              drvr_delay_actual - af2_start_delay[slave_mod_id] -

              af2_system_delay[slave_mod_id] - slot_delay[mapped_slot - 1]

              [edge] - channel_delay[driver - 'A'] - PROG_DELAY1;

        else

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[master_mod_id] -

              drvr_delay_actual - af2_start_delay[slave_mod_id] -

              af2_system_delay[slave_mod_id] - slot_delay[mapped_slot - 1]

              [edge] - channel_delay[driver - 'A'] - PROG_DELAY2;





        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = ch_delta[driver - 'A'][slope];



        log_result(slave_mod_id, result);

        vth_mseq_stop(slave_mod_id, TIMEOUT);

        disable_gen_out(slave_mod_id);



        vth_popen_rly(slave_mod_id, slave_slot, PIN_KGL_RLYS[driver - 'A']);

      }  /* for driver */



    }  /* for slope */





    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* CALCULATE SKEW */

      skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

      result.UU.Real_result = skew;

      log_result(slave_mod_id, result);



    }  /* CALCULATE SKEW */





    setup_gen_trg_out_delay(slave_mod_id, GEN_DELAY2);



  }  /* for programmed_delays */





  vth_pinit(slave_mod_id, slave_slot);

//  vth_minit(master_mod_id);

  vth_minit(slave_mod_id);

  vth_ainit(slave_mod_id);

    /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(master_mod_id);
  else
    close_syn(master_mod_id);
  /*--------------------------------------------*/

  close_gen(slave_mod_id);

  //close_mux(slave_mod_id);
  close_34980A(slave_mod_id);

  close_cntr(slave_mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9125*/

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef TIMEOUT

#undef GEN_DELAY1

#undef GEN_DELAY2

#undef PROG_DELAY1

#undef PROG_DELAY2



#define LINKS_TO_MASTER  1

#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

/* system actual t9 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

#define GEN_DELAY1      85e-09

#define GEN_DELAY2      185e-09

#define PROG_DELAY1     0.0e+00

#define PROG_DELAY2     100e-09

//------------------------------------------------------------------------------

void t9126(int *ms_list)

{

  /*MASTER/SLAVE DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

  int programmed_delays;

  int offset_cal;

  int master_mod_id;

  int slave_mod_id;

  int slave_slot;



  double drvr_delay_actual;

  double skew;



  double offset[2];

  double ch_delta['H' + 1 - 'A'][4];



  int edge;

  test_result_type result;

  int driver;



// mjs - this reordering of the array had to be done so that the vml files included

//below would still work. they still use the old pascal array indexes so the arrays

//had to be reordered back to the pascal way



  ms_list[4] = ms_list[3];

  ms_list[3] = ms_list[2];

  ms_list[2] = ms_list[1];

  ms_list[1] = ms_list[0];



  master_mod_id = ms_list[1];

  slave_mod_id = ms_list[3];

  slave_slot = ms_list[4];

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(master_mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(master_mod_id);
	setup_33250A_defaults(master_mod_id);
  }
  else
    open_syn(master_mod_id);
  /*--------------------------------------------*/

  open_gen(master_mod_id);

  //open_mux(master_mod_id);
  open_34980A(master_mod_id);

  open_cntr(master_mod_id);

  connect_syn_out_gen_ext(master_mod_id);

  setup_gen_levels(master_mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(master_mod_id);

  connect_gen_out_cntr_stop(master_mod_id);

  setup_gen_trg_out_delay(master_mod_id, GEN_DELAY1);

  for (offset_cal = 0; offset_cal <= 1; offset_cal++)

  {  /*offset_cal*/

    enable_gen_out(master_mod_id);

    trigger_cntr(master_mod_id);

    offset[offset_cal] = read_cntr_mean(master_mod_id);

    disable_gen_out(master_mod_id);

    setup_gen_trg_out_delay(master_mod_id, GEN_DELAY2);

  }  /*offset_cal*/

  connect_gen_trg_clkrb(master_mod_id);

  connect_cntr_start_af2(slave_mod_id);

  vth_mtclk_set_adv_time(master_mod_id, T0_ACTUAL);

  all_modules(&flush_commands);

  vth_mtclk_set_cal_adv_time(slave_mod_id, LINKS_TO_MASTER);

  /* MASTER MODULE SETUP COMMANDS */

  vth_mclose_rly(master_mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(master_mod_id, MK2903);   /* clkrsg path relay */

  vth_mtclk_clkrb_mux(master_mod_id);

  vth_mtclk_sel_ris_edge(master_mod_id);

  vth_mtclk_set_freq(master_mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mhsl_en_out_tclk(master_mod_id);

  vth_mclose_rly(master_mod_id, MK2201);   /* hsl divider network */

  /* SLAVE MODULE SETUP COMMANDS */

  vth_mclose_rly(slave_mod_id, MK2202);   /* hsl input enable */

  vth_mtclk_tclkina_mux(slave_mod_id);

  vth_mtclk_sel_ris_edge(slave_mod_id);

  vth_mtclk_set_freq(slave_mod_id, TCLK_FREQ, TCLK_FREQ);

  /* SLAVE AIM SETUP */

  vth_aclose_rly(slave_mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(slave_mod_id, K764);   /* XL to AF2 path */

  /* SLAVE PIN SETUP */

  close_pin_gnd_relays(slave_mod_id, slave_slot);

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(slave_mod_id, slave_slot, PIN_KD_RLYS[driver - 'A']);

    vth_pclose_rly(slave_mod_id, slave_slot, PIN_DRVR_RLYS[8][driver - 'A']);

  }  /* for */

  vth_pclose_rly(slave_mod_id, slave_slot, KDCL);

  flush_commands(master_mod_id);

  flush_commands(slave_mod_id);

  setup_gen_trg_out_delay(slave_mod_id, GEN_DELAY1);

  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    for (int slope = NEG; slope <= POS; ++slope)

    {  /* for slope */

      if (slope == POS)

        edge = RISING;

      else

        edge = FALLING;



      setup_cntr_trigger_slopes(slave_mod_id, slope, POS);

      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        enable_gen_out(slave_mod_id);



        sales_reset_sequencer(slave_mod_id, slave_slot);



        if (programmed_delays == 1)

        {

#include "t9125_nd.cmd"

        }

        else

        {

#include "t9125_d.cmd"

        }

        vth_pclose_rly(slave_mod_id, slave_slot, PIN_KGL_RLYS[driver - 'A']);



        sales_start_sequencer(slave_mod_id, slave_slot);



        trigger_cntr(slave_mod_id);

        drvr_delay_actual = read_cntr_mean(slave_mod_id);



        if (programmed_delays == 1)

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[master_mod_id] -

              drvr_delay_actual - af2_start_delay[slave_mod_id] -

              af2_system_delay[slave_mod_id] - slot_delay[slave_slot - 1]

              [edge] - channel_delay[driver - 'A'] - PROG_DELAY1;

        else

          ch_delta[driver - 'A']

            [slope] = offset[programmed_delays - 1] + clkrb_delay[master_mod_id] -

              drvr_delay_actual - af2_start_delay[slave_mod_id] -

              af2_system_delay[slave_mod_id] - slot_delay[slave_slot - 1]

              [edge] - channel_delay[driver - 'A'] - PROG_DELAY2;



        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = ch_delta[driver - 'A'][slope];

        log_result(slave_mod_id, result);

        vth_mseq_stop(slave_mod_id, TIMEOUT);

        disable_gen_out(slave_mod_id);

        vth_popen_rly(slave_mod_id, slave_slot, PIN_KGL_RLYS[driver - 'A']);

      }  /* for driver */



    }  /* for slope */





    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* CALCULATE SKEW */

      skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

      result.UU.Real_result = skew;

      log_result(slave_mod_id, result);



    }  /* CALCULATE SKEW */







    setup_gen_trg_out_delay(slave_mod_id, GEN_DELAY2);



  }  /* for programmed_delays */

  vth_pinit(slave_mod_id, slave_slot);

  vth_minit(master_mod_id);

  vth_minit(slave_mod_id);

  vth_ainit(slave_mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(slave_mod_id);
  else
    close_syn(slave_mod_id);
  /*--------------------------------------------*/

  close_gen(slave_mod_id);

  //close_mux(slave_mod_id);
  close_34980A(slave_mod_id);

  close_cntr(slave_mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9126*/

#undef LINKS_TO_MASTER

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef T0_ACTUAL

#undef TIMEOUT

#undef GEN_DELAY1

#undef GEN_DELAY2

#undef PROG_DELAY1

#undef PROG_DELAY2



#define TCLK_FREQ       5.0e+06

/* system actual t9 value */

#define TIMEOUT         1.0e-03

#define GEN_DELAY1      85e-09

#define BLANK_LINE      ""

//------------------------------------------------------------------------------

void t9127(int *ms_list)

{

  /*MASTER/SLAVE DRIVER EDGE PLACEMENT ACCURACY AND SKEW*/

  int links_to_master;

  int programmed_delays;

  int master_mod_id;

  int slave_mod_id;

  int slave_slot;

  test_result_type result;

  int driver;

  char buffer[81];



  all_modules(&vth_mod_init_dgn);

  all_modules(&close_mac_mk2202);

  all_modules(&flush_commands);



// mjs - this reordering of the array had to be done so that the vml files included

//below would still work. they still use the old pascal array indexes so the arrays

//had to be reordered back to the pascal way



  ms_list[4] = ms_list[3];

  ms_list[3] = ms_list[2];

  ms_list[2] = ms_list[1];

  ms_list[1] = ms_list[0];



  master_mod_id = ms_list[1];

  slave_mod_id = ms_list[3];

  slave_slot = ms_list[4];





  links_to_master = slave_links_to_master(master_mod_id, slave_mod_id);

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(master_mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(master_mod_id);
	setup_33250A_defaults(master_mod_id);
  }
  else
    open_syn(master_mod_id);
  /*--------------------------------------------*/

  open_gen(master_mod_id);

  //open_mux(master_mod_id);
  open_34980A(master_mod_id);

  open_cntr(master_mod_id);

  connect_syn_out_gen_ext(master_mod_id);

  connect_gen_trg_clkrb(master_mod_id);

  all_modules(&flush_commands);

  connect_cntr_start_af2(slave_mod_id);

  all_modules(&flush_commands);



  close_pin_gnd_relays(slave_mod_id, slave_slot);



  for (driver = 'A'; driver <= 'H'; driver++)

  {

    vth_pclose_rly(slave_mod_id, slave_slot, PIN_KD_RLYS[driver - 'A']);

    close_pin_drvr_load_rlys(slave_mod_id, slave_slot, driver);

  }



  /* MASTER MODULE SETUP COMMANDS */



  vth_mclose_rly(master_mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(master_mod_id, MK2903);   /* clkrsg path relay */

  vth_mtclk_clkrb_mux(master_mod_id);

  vth_mtclk_sel_ris_edge(master_mod_id);

  vth_mtclk_set_freq(master_mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mhsl_en_out_tclk(master_mod_id);

  vth_mopen_rly(master_mod_id, MK2202);

  vth_mclose_rly(master_mod_id, MK2201);   /* hsl divider network */

  vth_mtclk_set_cal_adv_time(master_mod_id, 0);



  /* SLAVE MODULE SETUP COMMANDS */



  vth_mtclk_tclkina_mux(slave_mod_id);

  vth_mtclk_sel_ris_edge(slave_mod_id);

  vth_mtclk_set_freq(slave_mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_cal_adv_time(slave_mod_id, links_to_master);



  /* SLAVE AIM SETUP */

  setup_gen_trg_out_delay(master_mod_id, GEN_DELAY1);



  flush_commands(master_mod_id);

  flush_commands(slave_mod_id);





  for (programmed_delays = 1; programmed_delays <= 2; programmed_delays++)

  {  /* for programmed_delays */

    enable_gen_out(slave_mod_id);



    sales_reset_sequencer(slave_mod_id, slave_slot);



    if (get_result_nolog(slave_mod_id, &result))

      display_prompt("Unexpected result Pending", true);

    display_prompt(BLANK_LINE, true);

    if (programmed_delays == 1)

    {  /* if */

      display_prompt("Outputting 0 ns delay edges", true);

#include "t9125_nd.cmd"

    }  /* if */

    else

    {  /* else */

      display_prompt("Outputting 100 ns delay edges", true);

#include "t9125_d.cmd"

    }  /* else */



    sales_start_sequencer(slave_mod_id, slave_slot);





    if (get_result_nolog(slave_mod_id, &result))

      display_prompt("Unexpected Result Pending", true);

    display_prompt("Press <Return> or <Enter> when ready to continue", true);

    display_prompt(BLANK_LINE, true);

    get_user_answer(buffer, 80);

    vth_mseq_stop(slave_mod_id, TIMEOUT);

  }  /* for programmed_delays */

  vth_pinit(slave_mod_id, slave_slot);

  vth_minit(master_mod_id);

  vth_minit(slave_mod_id);

  vth_ainit(slave_mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(slave_mod_id);
  else
    close_syn(slave_mod_id);
  /*--------------------------------------------*/

  close_gen(slave_mod_id);

  //close_mux(slave_mod_id);
  close_34980A(slave_mod_id);

  close_cntr(slave_mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9127*/

#undef TCLK_FREQ

#undef TIMEOUT

#undef GEN_DELAY1

#undef BLANK_LINE



/* pin 4 of 0-8 */

#define MUX_NODE_PIN    4

#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

#define GEN_DELAY_      100e-09

/* system actual t9 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

#define DC_SRC_VOLTAGE  7.0e+00

#define PROG_DELAY_     0.0e-09

//------------------------------------------------------------------------------

void t9129(int mod_id, int slot)

{

  /*TRI-STATE HIGH EDGE PLACEMENT ACCURACY AND SKEW*/

int mapped_slot;



  double drvr_delay_actual;

  double offset;

  double skew;



  double ch_delta['H' + 1 - 'A'][4];



  int edge;

  test_result_type result;

  int driver;





  if (slot > 11)

    mapped_slot = slot - 11;

  else

    mapped_slot = slot;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);

  setup_gen_trg_out_delay(mod_id, GEN_DELAY_);

  enable_gen_out(mod_id);

  trigger_cntr(mod_id);

  offset = read_cntr_mean(mod_id);

  disable_gen_out(mod_id);

  connect_gen_trg_clkrb(mod_id);

  connect_cntr_start_af2(mod_id);

  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][driver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);

  close_pin_gnd_relays(mod_id, slot);

  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, T0_ACTUAL);

  vth_aclose_rly(mod_id, K829);

  vth_asrc_dis_30ma_ilim(mod_id);

  vth_asrc_set_dc_ampl(mod_id, DC_SRC_VOLTAGE);

  for (int slope = NEG; slope <= POS; ++slope)

  {  /* for slope */

    if (slope == POS)

      edge = RISING;

    else

      edge = FALLING;

    setup_cntr_trigger_slopes(mod_id, slope, POS);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      enable_gen_out(mod_id);

      sales_reset_sequencer(mod_id, slot);

#include "t9129_vml.cmd"

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[driver - 'A']);

      vth_aclose_rly(mod_id, AIM_X_S_RLYS[driver - 'A']);

      vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

      vth_afc_en_src_out(mod_id);

      sales_start_sequencer(mod_id, slot);

      trigger_cntr(mod_id);

      vth_mtmr_wait(mod_id, 0.100);

      drvr_delay_actual = read_cntr_mean(mod_id);

      ch_delta[driver - 'A']

        [slope] = offset + clkrb_delay[mod_id] - drvr_delay_actual -

                  af2_start_delay[mod_id] - af2_system_delay[mod_id] -

                  slot_delay[mapped_slot - 1]

                  [edge] - channel_delay[driver - 'A'] - PROG_DELAY_;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = ch_delta[driver - 'A'][slope];

      log_result(mod_id, result);

      vth_mseq_stop(mod_id, TIMEOUT);

      disable_gen_out(mod_id);

      vth_afc_dis_src_out(mod_id);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[driver - 'A']);

      vth_aopen_rly(mod_id, AIM_X_S_RLYS[driver - 'A']);

    }  /* for driver */


  }  /* for slope */

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */

  for (slope = NEG; slope <= POS; ++slope)

  {  /* for slope */

    if (slope == POS)

      edge = RISING;

    else

      edge = FALLING;



    setup_cntr_trigger_slopes(mod_id, slope, POS);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      enable_gen_out(mod_id);



      sales_reset_sequencer(mod_id, slot);



#include "t9129_5uS.cmd"

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[driver - 'A']);

      vth_aclose_rly(mod_id, AIM_X_S_RLYS[driver - 'A']);

      vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

      vth_afc_en_src_out(mod_id);



      sales_start_sequencer(mod_id, slot);



      trigger_cntr(mod_id);

      vth_mtmr_wait(mod_id, 0.100);

      drvr_delay_actual = read_cntr_mean(mod_id);



      ch_delta[driver - 'A']

        [slope] = offset + clkrb_delay[mod_id] - drvr_delay_actual -

                  af2_start_delay[mod_id] - af2_system_delay[mod_id] -

                  slot_delay[mapped_slot - 1]

                  [edge] - channel_delay[driver - 'A'] - PROG_DELAY_;



      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = ch_delta[driver - 'A'][slope];

      log_result(mod_id, result);

      vth_mseq_stop(mod_id, TIMEOUT);

      disable_gen_out(mod_id);

      vth_afc_dis_src_out(mod_id);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[driver - 'A']);

      vth_aopen_rly(mod_id, AIM_X_S_RLYS[driver - 'A']);

    }  /* for driver */

  }  /* for slope */


  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9129*/

#undef MUX_NODE_PIN

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef GEN_DELAY_

#undef T0_ACTUAL

#undef TIMEOUT

#undef DC_SRC_VOLTAGE

#undef PROG_DELAY_



#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

#define GEN_DELAY_      100e-09

/* system actual t0 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

#define PROG_DELAY_     0.0e-09

//------------------------------------------------------------------------------

void t9130(int mod_id, int slot)

{

  /*TRI-STATE LOW EDGE PLACEMENT ACCURACY AND SKEW*/

int mapped_slot;



  double drvr_delay_actual;

  double offset;

  double skew;



  double ch_delta['H' + 1 - 'A'][4];



  int edge;

  test_result_type result;

  int driver;





  if (slot > 11)

    mapped_slot = slot - 11;

  else

    mapped_slot = slot;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);



  setup_gen_trg_out_delay(mod_id, GEN_DELAY_);



  enable_gen_out(mod_id);

  trigger_cntr(mod_id);

  offset = read_cntr_mean(mod_id);

  disable_gen_out(mod_id);



  connect_gen_trg_clkrb(mod_id);

  connect_cntr_start_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, T0_ACTUAL);



  for (int slope = NEG; slope <= POS; ++slope)

  {  /* for slope */

    if (slope == POS)

      edge = RISING;

    else

      edge = FALLING;



    setup_cntr_trigger_slopes(mod_id, slope, POS);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      enable_gen_out(mod_id);



      sales_reset_sequencer(mod_id, slot);



#include "t9130_vml.cmd"

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      sales_start_sequencer(mod_id, slot);



      trigger_cntr(mod_id);

      drvr_delay_actual = read_cntr_mean(mod_id);



      ch_delta[driver - 'A']

        [slope] = offset + clkrb_delay[mod_id] - drvr_delay_actual -

                  af2_start_delay[mod_id] - af2_system_delay[mod_id] -

                  slot_delay[mapped_slot - 1]

                  [edge] - channel_delay[driver - 'A'] - PROG_DELAY_;



      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = ch_delta[driver - 'A'][slope];

      log_result(mod_id, result);

      vth_mseq_stop(mod_id, TIMEOUT);

      disable_gen_out(mod_id);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    }  /* for driver */





  }  /* for slope */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */



  /* NOW EXECUTE TO HARD DRIVING CODE - drive high for 5uS */

  for (slope = NEG; slope <= POS; ++slope)

  {  /* for slope */

    if (slope == POS)

      edge = RISING;

    else

      edge = FALLING;



    setup_cntr_trigger_slopes(mod_id, slope, POS);

    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      enable_gen_out(mod_id);



      sales_reset_sequencer(mod_id, slot);



#include "t9130_5uS.cmd"

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      sales_start_sequencer(mod_id, slot);



      trigger_cntr(mod_id);

      drvr_delay_actual = read_cntr_mean(mod_id);



      ch_delta[driver - 'A']

        [slope] = offset + clkrb_delay[mod_id] - drvr_delay_actual -

                  af2_start_delay[mod_id] - af2_system_delay[mod_id] -

                  slot_delay[mapped_slot - 1]

                  [edge] - channel_delay[driver - 'A'] - PROG_DELAY_;



      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = ch_delta[driver - 'A'][slope];

      log_result(mod_id, result);

      vth_mseq_stop(mod_id, TIMEOUT);

      disable_gen_out(mod_id);

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    }  /* for driver */

  }  /* for slope */

  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    skew = ch_delta[driver - 'A'][POS] - ch_delta[driver - 'A'][NEG];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9130*/

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef GEN_DELAY_

#undef T0_ACTUAL

#undef TIMEOUT

#undef PROG_DELAY_



//------------------------------------------------------------------------------

void t9131(int /* mod_id */, int /* slot */)

{

  /* SALES RACK DIAGNOSTIC TEST */

  /* open instruments */



  /* run test connections */



  /* close instruments */



}  /*t9131*/



#define ABOVE_          0

#define BELOW           1

typedef double dr_level_array[2];

#define MUX_NODE_PIN    2

#define RANGE           300e-03

#define RESOLUTION      1.0e-03

#define DRIVER_LOAD_RESISTANCE  500e+00

const dr_level_array DRIVE_LO_LEVEL = {5.0, -3.5};

const dr_level_array DRIVE_HI_LEVEL = {5.0, -3.5};

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9132(int mod_id, int slot)

{

  /* [PINCARD] DRIVER TRI-STATE LEAKAGE CURRENT */



  /* For path and test descriptions, see the documentation for test: 9132 */

  int driver_no;



  double drive_lo;

  double drive_hi;

  double driver_tri_state_voltage;

  double driver_tri_state_current;



  test_result_type result;

  int driver;



  OpenResourceManager();


  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_500_ohm_load(mod_id);



  close_pin_gnd_relays(mod_id, slot);



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  for (int driver_level = ABOVE_; driver_level <= BELOW; ++driver_level)

  {  /* FOR EACH DRIVER LEVEL */

    /* The "if" statement that follows, skips subtests 8 through 15 for */

    /* compatibility with older tests that used subtests 8 through 15.  */

    if (present_subtest[mod_id - NO_TESTHEAD_NUMBER] == 8)

      present_subtest[mod_id - NO_TESTHEAD_NUMBER] = 16;



    drive_lo = DRIVE_LO_LEVEL[driver_level];

    drive_hi = DRIVE_HI_LEVEL[driver_level];



    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      driver_no = driver - 'A';

      vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

      vth_pdrv_set_lo(mod_id, slot, driver_no, drive_lo);

      vth_pdrv_set_hi(mod_id, slot, driver_no, drive_hi);

      vth_pfc_set_sttc_tsp(mod_id, slot, driver_no, 1);

      if (driver_level == ABOVE_)

        vth_pfc_set_sttc_dd(mod_id, slot, driver_no, 1);

      else

        vth_pfc_set_sttc_dd(mod_id, slot, driver_no, 0);

      vth_mtmr_wait(mod_id, STANDARD_WAIT_TIME);



      measure_dmm(mod_id);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        driver_tri_state_voltage = result.UU.Real_result;

        driver_tri_state_current = driver_tri_state_voltage / DRIVER_LOAD_RESISTANCE;

        result.UU.Real_result = driver_tri_state_current;

        log_result(mod_id, result);

      }  /*if*/

      else

        display_prompt("No result in result log (Expected dmm voltage)", true);



      vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    }  /* for driver */



  }  /* FOR DRIVER LEVEL */





  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /* t9132 */

#undef ABOVE_

#undef BELOW

#undef MUX_NODE_PIN

#undef RANGE

#undef RESOLUTION

#undef DRIVER_LOAD_RESISTANCE

#undef DMM_FUNCTION



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        50

#define CHANNEL_RANGE   5.0e+00

#define CHANNEL_OFFSET  2.0e+00

#define TRIGGER_LEVEL   2.0e+00

#define TIMEBASE_RANGE  20.0e-03

#define TIMEBASE_OFFSET  9.0e-03

#define TRIGGER_WAIT_TIME  2.25e+00

#define MEASURE_WAIT_TIME  0.75e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20.0e+06

#define AVERAGING       false

#define TIMEBASE_MODE   SINGLE

#define OSC_FUNCTION    WIDTH

/*   Which edge to measure?    */

#define EDGE            POS

//------------------------------------------------------------------------------

void t9133(int mod_id, int slot)

{

  /* DRIVER POWER LIMIT PROTECTION */

  double tclk_freq;



  test_result_type result;

  int driver;





  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  connect_osc_ch1_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load       */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);



    sales_reset_sequencer(mod_id, slot);



#include "t9133_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    sales_start_sequencer(mod_id, slot);



    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

    measure_osc(mod_id, OSC_FUNCTION, EDGE);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



  }  /*for driver*/







  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9133*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TRIGGER_WAIT_TIME

#undef MEASURE_WAIT_TIME

#undef TIMEOUT

#undef INPUT_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE

#undef OSC_FUNCTION

#undef EDGE



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        50

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  (-1.5e+00)

#define TRIGGER_LEVEL   (-1.5e+00)

#define TIMEBASE_RANGE  20.0e-03

#define TIMEBASE_OFFSET  9.0e-03

#define TRIGGER_WAIT_TIME  2.25e+00

#define MEASURE_WAIT_TIME  0.75e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20.0e+06

#define AVERAGING       false

#define TIMEBASE_MODE   SINGLE

#define OSC_FUNCTION    WIDTH

/*   Which edge to measure?    */

#define EDGE            NEG

//------------------------------------------------------------------------------

void t9134(int mod_id, int slot)

{

  /* DRIVER POWER LIMIT PROTECTION */

  double tclk_freq;



  test_result_type result;

  int driver;





  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  connect_osc_ch1_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load       */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);



    sales_reset_sequencer(mod_id, slot);



#include "t9134_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    sales_start_sequencer(mod_id, slot);



    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

    measure_osc(mod_id, OSC_FUNCTION, EDGE);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



  }  /*for driver*/







  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9134*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TRIGGER_WAIT_TIME

#undef MEASURE_WAIT_TIME

#undef TIMEOUT

#undef INPUT_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE

#undef OSC_FUNCTION

#undef EDGE



#define SAMPLE_RANGE    10

#define SAMPLE_LEVEL    10

#define SAMPLE_SLOPE    POS

#define SAMPLE_INTERVAL  50.0e-9

/* 1 period + 800ns */

#define SAMPLE_DELAY    1.2808e-3

#define SAMPLE_SIZE     5

#define TIMEOUT         10e-03

#define INPUT_FREQ      20e+06

#define COUPLING        50

//------------------------------------------------------------------------------

void t9135(int mod_id, int slot)

{

  /* [PINCARD] DRIVER OUTPUT IMPEDANCE (SOURCING 700mA) */



  /* For path and test descriptions, see the documentation for test: 9135 */

  int i;

  arrform waveform;

  double volts_noload;

  double volts_load;

  /* Calculated from measured V's*/

  double delta_v_cal;

  /* Calculated from measured V's*/

  double delta_i_cal;

  /* Calculated from measured V's*/

  double driver_impedance;

  double tclk_freq;



  test_result_type result;

  int driver;



  /* ----------------------------------------------------------------------- */



  //open_mux(mod_id);
  open_34980A(mod_id);

  open_dmm50(mod_id);

//  vth_mtmr_wait(mod_id, 1);

//  vth_mhpib_wr(mod_id, 8, "RESET");



  connect_dmm50_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load relay */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  setup_ssdc50_fast(mod_id, SAMPLE_RANGE, SAMPLE_LEVEL, SAMPLE_SLOPE,

                    SAMPLE_INTERVAL, SAMPLE_DELAY, SAMPLE_SIZE);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    sales_reset_sequencer(mod_id, slot);

#include "t9135_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);



    clear_dmm50_memory(mod_id);

    capture_ddm50(mod_id, SAMPLE_SIZE, waveform, LEVEL);

    volts_noload = 0.0;

    for (i = 0; i < SAMPLE_SIZE; i++)

      volts_noload += waveform[i] / SAMPLE_SIZE;

    show_value(mod_id, "volts_noload", volts_noload);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

    sales_reset_sequencer(mod_id, slot);

#include "t9135_vml.cmd"

    sales_start_sequencer(mod_id, slot);



    clear_dmm50_memory(mod_id);

    // could potentially just use 3 individual readings

    // instead of using the capture sampling routine to

    // make 5 readings (overhead)  -mjs

    capture_ddm50(mod_id, SAMPLE_SIZE, waveform, LEVEL);

    volts_load = 0.0;

    for (i = 0; i < SAMPLE_SIZE; i++)

      volts_load += waveform[i] / SAMPLE_SIZE;

    show_value(mod_id, "volts_load", volts_load);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_popen_rly(mod_id, slot, KDCG);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);



    delta_v_cal = volts_noload - volts_load;



    delta_i_cal = volts_load / load_5_ohm_resistance[mod_id][slot - 1]

                  [driver - 'A'] - volts_noload / COUPLING;





    if (delta_i_cal != 0)

      driver_impedance = delta_v_cal / delta_i_cal;

    else

      driver_impedance = 10.0;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = driver_impedance;

    log_result(mod_id, result);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm50(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9135*/

#undef SAMPLE_RANGE

#undef SAMPLE_LEVEL

#undef SAMPLE_SLOPE

#undef SAMPLE_INTERVAL

#undef SAMPLE_DELAY

#undef SAMPLE_SIZE

#undef TIMEOUT

#undef INPUT_FREQ

#undef COUPLING



#define SAMPLE_RANGE    10

#define SAMPLE_LEVEL    (-10)

#define SAMPLE_SLOPE    NEG

#define SAMPLE_INTERVAL  50.0e-9

/* 1 period + 800ns */

#define SAMPLE_DELAY    1.2808e-3

#define SAMPLE_SIZE     5

#define TIMEOUT         10e-03

#define INPUT_FREQ      20e+06

#define COUPLING        50

//------------------------------------------------------------------------------

void t9136(int mod_id, int slot)

{

  /* [PINCARD] DRIVER OUTPUT IMPEDANCE (SINKING 500mA) */



  /* For path and test descriptions, see the documentation for test: 9135 */

  int i;

  arrform waveform;

  double volts_noload;

  double volts_load;

  /* Calculated from measured V's*/

  double delta_v_cal;

  /* Calculated from measured V's*/

  double delta_i_cal;

  /* Calculated from measured V's*/

  double driver_impedance;

  double tclk_freq;



  test_result_type result;

int driver;



  /* ----------------------------------------------------------------------- */



  //open_mux(mod_id);
open_34980A(mod_id);

  open_dmm50(mod_id);

//  vth_mtmr_wait(mod_id, 1);

//  vth_mhpib_wr(mod_id, 8, "RESET");



  connect_dmm50_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load relay */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  setup_ssdc50_fast(mod_id, SAMPLE_RANGE, SAMPLE_LEVEL, SAMPLE_SLOPE,

                    SAMPLE_INTERVAL, SAMPLE_DELAY, SAMPLE_SIZE);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    sales_reset_sequencer(mod_id, slot);

#include "t9136_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);



    clear_dmm50_memory(mod_id);

    capture_ddm50(mod_id, SAMPLE_SIZE, waveform, LEVEL);

    volts_noload = 0.0;

    for (i = 0; i < SAMPLE_SIZE; i++)

      volts_noload += waveform[i] / SAMPLE_SIZE;

    show_value(mod_id, "volts_noload", volts_noload);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

    sales_reset_sequencer(mod_id, slot);

#include "t9136_vml.cmd"

    sales_start_sequencer(mod_id, slot);



    clear_dmm50_memory(mod_id);

    // could potentially just use 3 individual readings

    // instead of using the capture sampling routine to

    // make 5 readings (overhead)  -mjs

    capture_ddm50(mod_id, SAMPLE_SIZE, waveform, LEVEL);

    volts_load = 0.0;

    for (i = 0; i < SAMPLE_SIZE; i++)

      volts_load += waveform[i] / SAMPLE_SIZE;

    show_value(mod_id, "volts_load", volts_load);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_popen_rly(mod_id, slot, KDCG);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);



    delta_v_cal = volts_noload - volts_load;



    delta_i_cal = volts_load / load_5_ohm_resistance[mod_id][slot - 1]

                  [driver - 'A'] - volts_noload / COUPLING;



    if (delta_i_cal != 0)

      driver_impedance = delta_v_cal / delta_i_cal;

    else

      driver_impedance = 10.0;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = driver_impedance;

    log_result(mod_id, result);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm50(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9136*/

#undef SAMPLE_RANGE

#undef SAMPLE_LEVEL

#undef SAMPLE_SLOPE

#undef SAMPLE_INTERVAL

#undef SAMPLE_DELAY

#undef SAMPLE_SIZE

#undef TIMEOUT

#undef INPUT_FREQ

#undef COUPLING



#define MUX_NODE_PIN    2

#define OSC_CHANNEL     1

#define COUNT           5

/* Parallel scope load        */

#define SCOPE_LOAD_RESISTANCE  50

#define SOURCING_CURRENT  250e-03

#define RESOLUTION      1.0e-03

#define CHANNEL_RANGE   5.0e+00

#define CHANNEL_OFFSET  2.25e+00

#define TRIGGER_LEVEL   2.25e+00

#define TIMEBASE_RANGE  3e-06

#define TIMEBASE_OFFSET  0.5e-06

#define CALIBRATION_VOLTAGE  4.0e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20e+06

#define AVERAGING       true

#define DMM_FUNCTION    DCV

#define TIMEBASE_MODE   AUTOMATIC

/*   Which peak to measure?    */

#define PEAK            POS

//------------------------------------------------------------------------------

void t9137(int mod_id, int slot)

{

  /* DRIVER OUTPUT IMPEDANCE (SOURCING 250mA) */

  int driver_no;



  double voltage_level;

  double dmm_actual_voltage;

  double osc_actual_load;

  /*   Calibration for o'scope   */

  double offset;

  /* Calculated from measured V's*/

  double driver_impedance;

  double tclk_freq;



  test_result_type result;

  int driver;





  open_dmm(mod_id);

  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);





  setup_osc_channel(mod_id, OSC_CHANNEL, SCOPE_LOAD_RESISTANCE, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, PEAK, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  offset = offset_calibration(mod_id, CALIBRATION_VOLTAGE);



  setup_dmm(mod_id, DMM_FUNCTION, CALIBRATION_VOLTAGE, RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_osc_ch1_af2(mod_id);



  close_pin_gnd_relays(mod_id, slot);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_rly(mod_id, K755);   /* 24.11 ohm load relay */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    driver_no = driver - 'A';

    sales_reset_sequencer(mod_id, slot);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    voltage_level = SOURCING_CURRENT * load_24_50_ohm_resistance[mod_id]

                    [slot - 1][driver - 'A'];

    vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

    vth_pfc_set_sttc_tsp(mod_id, slot, driver_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, driver_no, 1);

    vth_mseq_neg_cpu_tsp(mod_id);



    dmm_actual_voltage = 0.0;

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      dmm_actual_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);

    vth_mseq_ass_cpu_tsp(mod_id);



    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);



    sales_reset_sequencer(mod_id, slot);

#include "t9137_vml.cmd"

    vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);



    osc_actual_load = 0.0;

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    measure_osc(mod_id, VMAX, PEAK);

    if (get_result_nolog(mod_id, &result))

      osc_actual_load = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected osc volt)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);



    osc_actual_load -= offset;

    osc_actual_load *= load_24_ohm_ratio[mod_id][slot - 1][driver - 'A'];



    driver_impedance = (dmm_actual_voltage - osc_actual_load) *

                       load_24_50_ohm_resistance[mod_id][slot - 1]

                       [driver - 'A'] / osc_actual_load;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = driver_impedance;

    log_result(mod_id, result);



  }  /*for driver*/







  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9137*/

#undef MUX_NODE_PIN

#undef OSC_CHANNEL

#undef COUNT

#undef SCOPE_LOAD_RESISTANCE

#undef SOURCING_CURRENT

#undef RESOLUTION

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef CALIBRATION_VOLTAGE

#undef TIMEOUT

#undef INPUT_FREQ

#undef AVERAGING

#undef DMM_FUNCTION

#undef TIMEBASE_MODE

#undef PEAK



#define MUX_NODE_PIN    2

#define OSC_CHANNEL     1

#define COUNT           5

/* Parallel scope load        */

#define SCOPE_LOAD_RESISTANCE  50

#define SINKING_CURRENT  175e-03

#define RESOLUTION      1.0e-03

#define CHANNEL_RANGE   4.00e+00

#define CHANNEL_OFFSET  (-1.75e+00)

#define TRIGGER_LEVEL   (-1.50e+00)

#define TIMEBASE_RANGE  3e-06

#define TIMEBASE_OFFSET  0.5e-06

#define CALIBRATION_VOLTAGE  (-2.7e+00)

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20e+06

#define AVERAGING       true

#define DMM_FUNCTION    DCV

#define TIMEBASE_MODE   AUTOMATIC

/*   Which peak to measure?    */

#define PEAK            NEG

//------------------------------------------------------------------------------

void t9138(int mod_id, int slot)

{

  /* DRIVER OUTPUT IMPEDANCE (SINKING 175mA) */

  int driver_no;



  double voltage_level;

  double dmm_actual_voltage;

  double osc_actual_load;

  /*   Calibration for o'scope   */

  double offset;

  /* Calculated from measured V's*/

  double driver_impedance;

  double tclk_freq;



  test_result_type result;

  int driver;





  open_dmm(mod_id);

  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, SCOPE_LOAD_RESISTANCE, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, PEAK, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  offset = offset_calibration(mod_id, CALIBRATION_VOLTAGE);



  setup_dmm(mod_id, DMM_FUNCTION, CALIBRATION_VOLTAGE, RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_osc_ch1_af2(mod_id);



  close_pin_gnd_relays(mod_id, slot);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_rly(mod_id, K755);   /* 24.11 ohm load relay */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    driver_no = driver - 'A';

    sales_reset_sequencer(mod_id, slot);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    voltage_level = -1 * SINKING_CURRENT * load_24_50_ohm_resistance[mod_id]

                    [slot - 1][driver - 'A'];

    vth_pdrv_set_lo(mod_id, slot, driver_no, voltage_level);

    vth_pfc_set_sttc_tsp(mod_id, slot, driver_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, driver_no, 0);

    vth_mseq_neg_cpu_tsp(mod_id);



    dmm_actual_voltage = 0.0;

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      dmm_actual_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);

    vth_mseq_ass_cpu_tsp(mod_id);



    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);



    sales_reset_sequencer(mod_id, slot);

#include "t9138_vml.cmd"

    vth_pdrv_set_lo(mod_id, slot, driver_no, voltage_level);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);



    osc_actual_load = 0.0;

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    measure_osc(mod_id, VMAX, PEAK);

    if (get_result_nolog(mod_id, &result))

      osc_actual_load = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected osc volt)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);



    osc_actual_load -= offset;

    osc_actual_load *= load_24_ohm_ratio[mod_id][slot - 1][driver - 'A'];



    driver_impedance = (dmm_actual_voltage - osc_actual_load) *

                       load_24_50_ohm_resistance[mod_id][slot - 1]

                       [driver - 'A'] / osc_actual_load;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = driver_impedance;

    log_result(mod_id, result);



  }  /*for driver*/







  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9138*/

#undef MUX_NODE_PIN

#undef OSC_CHANNEL

#undef COUNT

#undef SCOPE_LOAD_RESISTANCE

#undef SINKING_CURRENT

#undef RESOLUTION

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef CALIBRATION_VOLTAGE

#undef TIMEOUT

#undef INPUT_FREQ

#undef AVERAGING

#undef DMM_FUNCTION

#undef TIMEBASE_MODE

#undef PEAK



#define TIMEOUT         1.0e-01

#define INPUT_FREQ      20e+06

#define SAMPLE_RANGE    10

#define SAMPLE_LEVEL    10

#define SAMPLE_SLOPE    POS

#define SAMPLE_INTERVAL  100e-09

#define SAMPLE_DELAY    1.26e-3   /*about 1 period of 1.28ms */

#define SAMPLE_SIZE     256

//------------------------------------------------------------------------------

void t9140(int mod_id, int slot)

{

  /* MAXIMUM DRIVE CURRENT (SOURCING >700mA) */

  double dmm_actual_voltage;

  double five_ohm_equivalent;

  /* Calculated from measured V  */

  double drive_current;

  double tclk_freq;



  test_result_type result;

  int driver;



  /* ----------------------------------------------------------------------- */


  OpenResourceManager();

  open_dmm50(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  /* setup dmm50 */



  connect_dmm50_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load relay */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);


  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);

  break_test_for_function_step_compatability(mod_id);


  setup_ssdc50_fast(mod_id, SAMPLE_RANGE, SAMPLE_LEVEL, SAMPLE_SLOPE,

                    SAMPLE_INTERVAL, SAMPLE_DELAY, SAMPLE_SIZE);


  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    sales_reset_sequencer(mod_id, slot);

#include "t9140_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);


    dmm_actual_voltage = 0.0;

    clear_dmm50_memory(mod_id);

    /* trigger_dmm50(mod_id);  */

    /* if this doesn't trigger, try using TARM SGL instead */

    vth_mhpib_wr(mod_id, 8, "TARM SGL");

     calculate_dmm50_stats(mod_id);

    vth_mtmr_wait(mod_id, 0.5);

    flush_commands(mod_id); //added fikri 15/5/2024

    read_dmm50_stats(mod_id, SALES_MAX);

    if (get_result_nolog(mod_id, &result))

      dmm_actual_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dr out volt)", true);



    show_value(mod_id, "maximum", dmm_actual_voltage);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    five_ohm_equivalent = load_5_ohm_resistance[mod_id][slot - 1]

        [driver - 'A'] * 50 / (load_5_ohm_resistance[mod_id][slot - 1]

                               [driver - 'A'] + 50);

    show_value(mod_id, "5 ohm equivalent", five_ohm_equivalent);



    drive_current = dmm_actual_voltage / five_ohm_equivalent;

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = drive_current;

    log_result(mod_id, result);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);

  close_dmm50(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /*t9140*/

#undef TIMEOUT

#undef INPUT_FREQ

#undef SAMPLE_RANGE

#undef SAMPLE_LEVEL

#undef SAMPLE_SLOPE

#undef SAMPLE_INTERVAL

#undef SAMPLE_DELAY

#undef SAMPLE_SIZE



#define TIMEOUT         5.0e-03

#define INPUT_FREQ      20e+06

#define SAMPLE_RANGE    10

#define SAMPLE_LEVEL    (-10)

#define SAMPLE_SLOPE    NEG

#define SAMPLE_INTERVAL  100e-09

#define SAMPLE_DELAY    1.26e-3

#define SAMPLE_SIZE     256

//------------------------------------------------------------------------------

void t9141(int mod_id, int slot)

{

  /* MAXIMUM DRIVE CURRENT (SINKING >500mA) */

  double dmm_actual_voltage;

  double five_ohm_equivalent;

  /* Calculated from measured V  */

  double drive_current;

  double tclk_freq;

  test_result_type result;

  int driver;


  OpenResourceManager(); //added by fikri, 25062024
  open_dmm50(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_dmm50_af2(mod_id);

  vth_cfxt_unlock(); // added sri

  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K756);   /* 5 ohm load relay */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  setup_ssdc50_fast(mod_id, SAMPLE_RANGE, SAMPLE_LEVEL, SAMPLE_SLOPE,

                    SAMPLE_INTERVAL, SAMPLE_DELAY, SAMPLE_SIZE);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    sales_reset_sequencer(mod_id, slot);

#include "t9141_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    sales_start_sequencer(mod_id, slot);



    dmm_actual_voltage = 0.0;



    clear_dmm50_memory(mod_id);

    vth_mhpib_wr(mod_id, 8, "TARM SGL");



    calculate_dmm50_stats(mod_id);



    read_dmm50_stats(mod_id, SALES_MIN);

    if (get_result_nolog(mod_id, &result))

      dmm_actual_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dr out volt)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    five_ohm_equivalent = load_5_ohm_resistance[mod_id][slot - 1]

        [driver - 'A'] * 50 / (load_5_ohm_resistance[mod_id][slot - 1]

                               [driver - 'A'] + 50);



    drive_current = fabs(dmm_actual_voltage / five_ohm_equivalent);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = drive_current;

    log_result(mod_id, result);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);

  close_dmm50(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager(); //added by fikri, 25062024


}  /*t9141*/

#undef TIMEOUT

#undef INPUT_FREQ

#undef SAMPLE_RANGE

#undef SAMPLE_LEVEL

#undef SAMPLE_SLOPE

#undef SAMPLE_INTERVAL

#undef SAMPLE_DELAY

#undef SAMPLE_SIZE



#define RANGE           30

#define MUX_NODE_PIN    2

#define RESOLUTION      10e-03

#define SOURCING_IL     60e-03

#define SOURCING_NO_IL  200e-03

#define LOW_CURRENT_SPEC  50e-03

#define HI_CURRENT_SPEC  70e-03

#define MIN_FAIL        10e-03

#define MAX_FAIL        100e-03

#define ADDED_CURRENT_RANGE  5e-03

#define WAIT_TIME       500e-06

#define HISTORICAL_MEAN  59e-03

#define HISTORICAL_STD  2e-03

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9142(int mod_id, int slot)

{

  /* LOW LEVEL CURRENT LIMIT SOURCING  */

  int driver_no;



  double high_bounds;

  double low_bounds;

  double high_guess;

  double low_guess;



  double dmm_actual_voltage;

  double current_current;

  double current_increment;

  double drive_current;

  double voltage_level;



  boolean limit_occurred;

  boolean found_interval;

  boolean found_high;

  boolean found_low;



  a_word_type this_word;

  test_result_type result;

  int driver;



  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  low_bounds = LOW_CURRENT_SPEC - ADDED_CURRENT_RANGE;

  high_bounds = HI_CURRENT_SPEC + ADDED_CURRENT_RANGE;



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K755);   /* 24.5 ohm load    */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    driver_no = driver - 'A';

    vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);

    close_pin_gnd_relays(mod_id, slot);



    found_high = false;

    found_low = false;

    found_interval = false;

    current_current = HISTORICAL_MEAN;

    current_increment = HISTORICAL_STD;

    high_guess = high_bounds;

    low_guess = low_bounds;



    voltage_level = current_current * load_24_ohm_resistance[mod_id][slot - 1]

                    [driver - 'A'];

    vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

    vth_pdrv_set_il(mod_id, slot, driver_no, SOURCING_IL);

    vth_pfc_set_sttc_tsp(mod_id, slot, driver_no, 0);

    vth_pfc_set_sttc_dd(mod_id, slot, driver_no, 1);

    vth_mseq_neg_cpu_tsp(mod_id);



    while (high_guess - low_guess > 2.0 && current_current < high_bounds &&

           current_current > low_bounds)

    {  /* while */

      voltage_level = current_current * load_24_ohm_resistance[mod_id]

                      [slot - 1][driver - 'A'];

      vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

      vth_mtmr_wait(mod_id, WAIT_TIME);

      vth_pdrv_clr_err(mod_id, slot);

      limit_occurred = false;

      vth_prd_cell(mod_id, slot, POVR_PWR_AND_CRRNT);

      if (get_result_nolog(mod_id, &result))

      {  /*process_result*/

        this_word.data = result.UU.Integer_result;

        if (P_getbits_US(this_word.bits, driver_no, 0) == 0)

//        if (P_getbits_US(this_word.bits, 15 - driver_no, 0) == 0)

          limit_occurred = true;

      }  /*process_result*/

      else

        display_prompt("No result in result log (Expected pin cell)", true);



      if (limit_occurred)

      {

        found_high = true;

        high_guess = current_current;

      }

      else

      {

        found_low = true;

        low_guess = current_current;

      }



      if (found_high && found_low)

        found_interval = true;



      if (found_interval)

        current_increment /= 2;

      else

      {

        if (fabs(HISTORICAL_MEAN - current_current) > 3 * HISTORICAL_STD)

          current_increment *= 2;

      }



      if (limit_occurred)

        current_current -= current_increment;

      else

        current_current += current_increment;



    }  /* while */





    if (current_current >= high_bounds)

      current_current = MAX_FAIL;

    if (current_current <= low_bounds)

      current_current = MIN_FAIL;

    if (found_interval)

    {  /*found_interval*/

      current_current = (high_guess + low_guess) / 2;

      voltage_level = current_current * load_24_ohm_resistance[mod_id]

                      [slot - 1][driver - 'A'];

      vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

      vth_pdrv_set_il(mod_id, slot, driver_no, SOURCING_NO_IL);

      vth_mtmr_wait(mod_id, WAIT_TIME);

      vth_pdrv_clr_err(mod_id, slot);

      measure_dmm(mod_id);

      if (get_result_nolog(mod_id, &result))

        dmm_actual_voltage = result.UU.Real_result;

      else

        display_prompt("No result in result log (Expected dr out volt)", true);

    }  /*found_interval*/

    else

      dmm_actual_voltage = current_current * load_24_ohm_resistance[mod_id]

                           [slot - 1][driver - 'A'];



    vth_mseq_ass_cpu_tsp(mod_id);

    vth_pfc_set_sttc_tsp(mod_id, slot, driver_no, 1);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][driver - 'A']);



    drive_current = dmm_actual_voltage / load_24_ohm_resistance[mod_id]

                    [slot - 1][driver - 'A'];

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = drive_current;

    log_result(mod_id, result);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9142*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef SOURCING_IL

#undef SOURCING_NO_IL

#undef LOW_CURRENT_SPEC

#undef HI_CURRENT_SPEC

#undef MIN_FAIL

#undef MAX_FAIL

#undef ADDED_CURRENT_RANGE

#undef WAIT_TIME

#undef HISTORICAL_MEAN

#undef HISTORICAL_STD

#undef DMM_FUNCTION



#define RANGE           30

#define MUX_NODE_PIN    2

#define RESOLUTION      10e-03

#define SINKING_IL      40e-03

#define LOW_CURRENT_SPEC  35e-03

#define HI_CURRENT_SPEC  125e-03

#define ADDED_CURRENT_RANGE  5e-03

#define COARSE_CURRENT_INCREMENT  10e-03

#define FINE_CURRENT_INCREMENT  1e-03

#define WAIT_TIME       500e-06

#define WAIT_FOR_POWER_LIMIT_TIME  100e-03

#define DMM_FUNCTION    DCV



/* static variables for t9143: */

struct LOC_t9143

{

  int mod_id;

  int slot;



  int driver_no;



  a_word_type this_word;

  test_result_type result;

  int driver;

} ;



static void apply_voltage(double volts, boolean *limit_occurred, struct LOC_t9143 *LINK)

{

  double i=0;

  double j=0;

  double k=0;



  flush_commands(LINK->mod_id);

  vth_pdrv_set_lo(LINK->mod_id, LINK->slot, LINK->driver_no, volts);

  vth_pdrv_clr_err(LINK->mod_id, LINK->slot);

  vth_mtmr_wait(LINK->mod_id, WAIT_TIME);

  vth_prd_cell(LINK->mod_id, LINK->slot, POVR_PWR_AND_CRRNT);



  if (get_result_nolog(LINK->mod_id, &LINK->result))

  {

    LINK->this_word.data = LINK->result.UU.Integer_result;



    if (debug_9143) display_prompt("In apply_voltage...", true);



    if (debug_9143) display_it(LINK->mod_id, "LINK->this_word.bits = ", LINK->this_word.bits, LINK->this_word.bits);



    if (debug_9143) display_it(LINK->mod_id, "for bit # = ", LINK->driver_no, LINK->driver_no);



    if (P_getbits_US(LINK->this_word.bits, LINK->driver_no, 0) == 0)

    {

      if (debug_9143)  display_prompt("condition evaluated TRUE", true);

      *limit_occurred = true;

    }

    else

    {

      if (debug_9143)  display_prompt("condition evaluated FALSE", true);

      *limit_occurred = false;

    }

  }

  else

    if (debug_9143)      display_prompt("No result in result log (Expected pin cell)", true);



}  /*apply_voltage*/



static void check_power_curr_clear(double volts, boolean *cleared, struct LOC_t9143 *LINK)

{

  vth_pdrv_set_lo(LINK->mod_id, LINK->slot, LINK->driver_no, volts);

//  vth_mtmr_wait(LINK->mod_id, 3*WAIT_FOR_POWER_LIMIT_TIME);  //mjs

  vth_pdrv_clr_err(LINK->mod_id, LINK->slot);

  vth_mtmr_wait(LINK->mod_id, WAIT_FOR_POWER_LIMIT_TIME);  //mjs

  trigger_dmm(LINK->mod_id);

  vth_prd_cell(LINK->mod_id, LINK->slot, POVR_PWR_AND_CRRNT);

  if (get_result_nolog(LINK->mod_id, &LINK->result))

  {

    LINK->this_word.data = LINK->result.UU.Integer_result;



    if (debug_9143) display_it(2, "8+link->driver_no", (8+LINK->driver_no), 0);



    if (debug_9143) display_it(2, "link->driver_no", (LINK->driver_no), 0);



    if (debug_9143) display_it(2, "LINK->this_word.data", LINK->this_word.data, 0);



    if (P_getbits_US(LINK->this_word.data, 8 + LINK->driver_no, 0) == 1 ||

        P_getbits_US(LINK->this_word.data, LINK->driver_no, 0) == 1)

    {

      *cleared = true;

      if (debug_9143)  display_prompt("true loop", true);

    }

    else

    {

      *cleared = false;

      if (debug_9143)  display_prompt("false loop", true);

    }

  }

  else

    display_prompt("No result in result log (Expected pin cell)", true);



}  /*check_power_curr_clear*/





static void find_curr_lim(double low_bound, double hi_bound, double mean, double sigma, double * current, boolean * found, struct LOC_t9143 * LINK)

{

  int olddirection;

  int direction;

  double volts;

  boolean too_high_curr;



  direction = 0;

  *found = false;

  *current = mean;

  do

  {

    olddirection = direction;

    flush_commands(LINK->mod_id);

    volts = -1 * *current * load_24_ohm_resistance[LINK->mod_id][LINK->slot - 1][LINK->driver - 'A'];



    if (debug_9143) display_prompt("find_curr_lim", true);



    if (debug_9143) display_it(2, "volts = ", 0, volts);



    if (debug_9143) display_it(2, "load_24_ohm_resistance = ", 0, load_24_ohm_resistance[LINK->mod_id][LINK->slot - 1][LINK->driver - 'A'] );



    if (debug_9143) display_it(2, "first *current = ", 0, *current);

      apply_voltage(volts, &too_high_curr, LINK);



    if (too_high_curr)

    {

      if (debug_9143) display_prompt("too_high_curr is TRUE", true);

      direction = -1;

    }

    else

    {

      if (debug_9143) display_prompt("too_high_curr is FALSE", true);

      direction = 1;

    }



    *current += direction * sigma;



    if (debug_9143) display_it(2, "first *current = ", 0, *current);



    if (direction == 1 && olddirection == -1)

    {

      if (debug_9143) display_prompt("setting *found to TRUE", true);

      *found = true;

    }



    /* current is on "high" end of trigger since already incremented */

    if (debug_9143) display_it(2, "hi_bound = ", 0, hi_bound);



    if (debug_9143) display_it(2, "low_bound = ", 0, low_bound);

  } while (!(*found || *current > hi_bound || *current < low_bound));



}  /*find_curr_lim*/



//------------------------------------------------------------------------------

void t9143(int mod_id, int slot)

{

  /* LOW LEVEL CURRENT LIMIT SINKING  */



  /*Substantial modifications to search algorithm by Richard DeVore Oct 1, 1990*/

  /*More modifications to fix algorithm by Jim and Richard DeVore Oct 16, 1990*/

  struct LOC_t9143 V;

  double low_current_range;

  double hi_current_range;

  double dmm_actual_voltage;

  double current_current;

  double current_increment;

  double drive_current;

  double voltage_level;

  double mean;

  double sigma;   /* used to target accurately */

  boolean limit_occurred;

  boolean power_or_c_limit_cleared;



  V.mod_id = mod_id;

  V.slot = slot;

  mean = 73.3e-03;

  sigma = 5.0e-03;   /*used to quickly locate current limit*/



  open_dmm(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);



  low_current_range = LOW_CURRENT_SPEC - ADDED_CURRENT_RANGE;

  hi_current_range = HI_CURRENT_SPEC + ADDED_CURRENT_RANGE;

  current_increment = COARSE_CURRENT_INCREMENT;



  setup_dmm(V.mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  connect_dmm_pin(V.mod_id, V.slot);



  vth_aclose_trp_chg_rly(V.mod_id);   /* Aim load common  */

  vth_aclose_rly(V.mod_id, K755);   /* 24.5 ohm load    */



  vth_pclose_rly(V.mod_id, V.slot, KDCG);   /* XG common relay  */

  close_pin_gnd_relays(V.mod_id, V.slot);



  flush_commands(V.mod_id);



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)

  {  /* DO THIS FOR EVERY DRIVER ON THE CARD */

    V.driver_no = V.driver - 'A';

    vth_pclose_rly(V.mod_id, V.slot, PIN_KD_RLYS[V.driver - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[V.driver - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[MUX_NODE_PIN][V.driver - 'A']);



    current_current = low_current_range;

    voltage_level = -1 * current_current * load_24_ohm_resistance[V.mod_id]

                    [V.slot - 1][V.driver - 'A'];



    flush_commands(V.mod_id);

    vth_pdrv_set_lo(V.mod_id, V.slot, V.driver_no, voltage_level);

    vth_pdrv_set_il(V.mod_id, V.slot, V.driver_no, SINKING_IL);

    vth_pfc_set_sttc_tsp(V.mod_id, V.slot, V.driver_no, 0);

    vth_pfc_set_sttc_dd(V.mod_id, V.slot, V.driver_no, 0);

    vth_mseq_neg_cpu_tsp(V.mod_id);

    flush_commands(V.mod_id);





    /*PART 1: Looking for CURRENT limit to occur the first time */

    find_curr_lim(low_current_range, hi_current_range, mean, sigma,

                  &current_current, &limit_occurred, &V);

if (debug_9143) display_it(2, "find_curr_lim::current_current = ", 0, current_current);

//mjs changed this

//    current_current = .0733;

//    display_it(2, "find_curr_lim::current_current = ", 0, current_current);

    /*END PART 1: Looking for CURRENT limit to occur the first time */



    /*PART 2: Looking for NO CURRENT limit - only if one occurred the first time */

    if (limit_occurred)

    {  /*measure the voltage at which limit occurred*/

      do

      {   /*STEP THE VOLTAGE LEVEL UNTIL A LIMIT DOES NOT OCCUR*/

        current_current -= current_increment;

        voltage_level = -1 * current_current * load_24_ohm_resistance[V.mod_id]

                        [V.slot - 1][V.driver - 'A'];

if (debug_9143) display_it(2, "step 2 volts = ", 0, voltage_level);

if (debug_9143) display_it(2, "step2::current_current = ", 0, current_current);

        apply_voltage(voltage_level, &limit_occurred, &V);

      } while (limit_occurred && current_current > low_current_range);



      /*PART 3: Searching for 2nd CURRENT limit iff part 2 ended with no limit*/

      if (!limit_occurred)

      {  /* Look for CURRENT limit a second time because of hysteresis */

        current_increment = FINE_CURRENT_INCREMENT;

        do

        {   /*STEP THE VOLTAGE LEVEL BACK BECAUSE OF HYSTERESIS*/

          current_current += current_increment;

          voltage_level = -1 * current_current * load_24_ohm_resistance[V.mod_id]

                          [V.slot - 1][V.driver - 'A'];

if (debug_9143) display_it(2, "step 3 volts = ", 0, voltage_level);

if (debug_9143) display_it(2, "step3::current_current = ", 0, current_current);

          apply_voltage(voltage_level, &limit_occurred, &V);

          if (limit_occurred)

          {  /*over current test*/

            do

            {   /*Step voltage until POWER L or CURRENT L NOT occur*/

              current_current -= current_increment;

              voltage_level = -1 * current_current *

                              load_24_ohm_resistance[V.mod_id][V.slot - 1]

                              [V.driver - 'A'];

if (debug_9143) display_it(2, "check_power volts = ", 0, voltage_level);

if (debug_9143) display_it(2, "check_power::current_current = ", 0, current_current);

              check_power_curr_clear(voltage_level, &power_or_c_limit_cleared,

                                     &V);

            } while (!(power_or_c_limit_cleared ||

                       current_current <= low_current_range));

            read_dmm(V.mod_id);

            if (get_result_nolog(V.mod_id, &V.result))

              dmm_actual_voltage = V.result.UU.Real_result;

            else

              display_prompt("No result in result log (Expected dr out volt)",

                             true);

          }  /*over current test*/



          /*Part 4: Current limit has occured a 2nd time -        */

          /*        Now Looking for POWER or CURRENT to NOT occur */



        } while (!(limit_occurred || current_current >= hi_current_range));

        if (current_current >= hi_current_range)

        {

          /* Part 3 : Current Limit did not occur the second time !  */

          /* Set the dmm voltage value to the highest voltage tested */

          dmm_actual_voltage = voltage_level;

        }



      }  /* Look for current limit a second time because of hysteresis */

      else

      {

        /* Limit occurred always in PART 2: voltage =< min current voltage */

        dmm_actual_voltage = voltage_level;



      }



    }  /* measure the voltage at which the limit occurred */

    else

    {

      /* No current limit occurred in PART 1: voltage >= max current voltage */

      dmm_actual_voltage = voltage_level;

    }



    vth_mseq_ass_cpu_tsp(V.mod_id);

    vth_pfc_set_sttc_tsp(V.mod_id, V.slot, V.driver_no, 1);

    vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[V.driver - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KD_RLYS[V.driver - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[MUX_NODE_PIN][V.driver - 'A']);



    drive_current = fabs(dmm_actual_voltage / load_24_ohm_resistance[V.mod_id]

                         [V.slot - 1][V.driver - 'A']);

    V.result.Measurement_class = CLASS_REAL;

    V.result.UU.Real_result = drive_current;

    log_result(V.mod_id, V.result);



  }  /* DO THIS FOR EVERY DRIVER ON THE CARD */



  vth_pinit(V.mod_id, V.slot);

  vth_ainit(V.mod_id);



  close_dmm(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);



}  /*t9143*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef SINKING_IL

#undef LOW_CURRENT_SPEC

#undef HI_CURRENT_SPEC

#undef ADDED_CURRENT_RANGE

#undef COARSE_CURRENT_INCREMENT

#undef FINE_CURRENT_INCREMENT

#undef WAIT_TIME

#undef WAIT_FOR_POWER_LIMIT_TIME

#undef DMM_FUNCTION



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        50

#define LOW_BOUNDS      300e-03

#define HIGH_BOUNDS     700e-03

#define MIN_FAIL        100e-03

#define MAX_FAIL        999e-03

#define CURRENT_RESOLUTION  5e-03

#define HISTORICAL_MEAN  530e-03

#define HISTORICAL_STD  5e-03

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  1.5e+00

#define TRIGGER_LEVEL   1.5e+00

#define TIMEBASE_RANGE  20e-06

#define TIMEBASE_OFFSET  6e-06

#define CALIBRATION_VOLTAGE  2.5e+00

#define SOURCING_IL     500e-03

#define SOURCING_IL_MAX  700e-03

#define TIMEOUT         1.0e-03

#define WAIT_TIME       100e-03

#define INPUT_FREQ      20e+06

#define AVERAGING       true

#define TIMEBASE_MODE   AUTOMATIC

/*   Which peak to measure?    */

#define PEAK            POS

//------------------------------------------------------------------------------

void t9144(int mod_id, int slot)

{

  /* HIGH LEVEL CURRENT LIMIT SOURCING */

  int driver_no;



  double voltage_level;

  double osc_actual_voltage;

  /*   Calibration for o'scope   */

  double offset;

  double actual_current;

  double tclk_freq;



  boolean i_limit_occurred;



  a_word_type this_word;

  test_result_type result;

  int driver;



  double current_guess;

  double current_increment;

  double high_guess;

  double low_guess;

  boolean found_interval;

  boolean found_high;

  boolean found_low;





  open_osc(mod_id);

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, PEAK, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  offset = offset_calibration(mod_id, CALIBRATION_VOLTAGE);



  connect_osc_ch1_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K756);   /* Aim load 5 ohms  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  break_test_for_function_step_compatability(mod_id);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    driver_no = driver - 'A';



    i_limit_occurred = false;

    found_high = false;

    found_low = false;

    found_interval = false;



    current_guess = HISTORICAL_MEAN;

    current_increment = HISTORICAL_STD;

    high_guess = HIGH_BOUNDS;

    low_guess = LOW_BOUNDS;



    vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

    vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    break_test_for_function_step_compatability(mod_id);



    while (high_guess - low_guess > 2 * CURRENT_RESOLUTION &&

           current_guess > LOW_BOUNDS && current_guess < HIGH_BOUNDS)

    {  /*while*/

      i_limit_occurred = false;

      voltage_level = current_guess * load_5_ohm_resistance[mod_id][slot - 1]

                      [driver - 'A'];

      sales_reset_sequencer(mod_id, slot);

#include "t9144_vml.cmd"

      vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

      vth_pdrv_set_il(mod_id, slot, driver_no, SOURCING_IL);

      vth_mtmr_wait(mod_id, WAIT_TIME);

      sales_start_sequencer(mod_id, slot);

      vth_mtmr_wait(mod_id, WAIT_TIME);

      vth_mseq_stop(mod_id, TIMEOUT);

      vth_prd_cell(mod_id, slot, POVR_PWR_AND_CRRNT);

      if (get_result_nolog(mod_id, &result))

      {  /*process_result*/

        this_word.data = result.UU.Integer_result;

        if (P_getbits_US(this_word.bits, driver_no, 0) == 0)

          i_limit_occurred = true;

      }  /*process_result*/

      else

        display_prompt("No result in result log (Expected pin cell)", true);



      if (i_limit_occurred)

      {

        found_high = true;

        high_guess = current_guess;

      }

      else

      {

        found_low = true;

        low_guess = current_guess;

      }



      if (found_high && found_low)

        found_interval = true;



      if (found_interval)

        current_increment /= 2;

      else

      {

        if (fabs(HISTORICAL_MEAN - current_guess) > 3 * HISTORICAL_STD)

          current_increment *= 2;

      }



      if (i_limit_occurred)

        current_guess -= current_increment;

      else

        current_guess += current_increment;



    }  /*while*/





    if (current_guess >= HIGH_BOUNDS)

      current_guess = MAX_FAIL;

    if (current_guess <= LOW_BOUNDS)

      current_guess = MIN_FAIL;

    if (found_interval)

      current_guess = (high_guess + low_guess) / 2;





    voltage_level = current_guess * load_5_ohm_resistance[mod_id][slot - 1]

                    [driver - 'A'];

    sales_reset_sequencer(mod_id, slot);

#include "t9144_vml.cmd"

    vth_pdrv_set_il(mod_id, slot, driver_no, SOURCING_IL_MAX);

    vth_pdrv_set_hi(mod_id, slot, driver_no, voltage_level);

    vth_mtmr_wait(mod_id, WAIT_TIME);

    sales_start_sequencer(mod_id, slot);

    osc_actual_voltage = 0.0;

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    measure_osc(mod_id, VMAX, PEAK);

    if (get_result_nolog(mod_id, &result))

      osc_actual_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log(Expected osc reading)", true);

    vth_mseq_stop(mod_id, TIMEOUT);

    osc_actual_voltage -= offset;

    osc_actual_voltage *= load_5_ohm_ratio[mod_id][slot - 1][driver - 'A'];

    actual_current = osc_actual_voltage / load_5_ohm_resistance[mod_id]

                     [slot - 1][driver - 'A'];

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_current;

    log_result(mod_id, result);



    vth_popen_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



  }  /*for driver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9144*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef LOW_BOUNDS

#undef HIGH_BOUNDS

#undef MIN_FAIL

#undef MAX_FAIL

#undef CURRENT_RESOLUTION

#undef HISTORICAL_MEAN

#undef HISTORICAL_STD

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef CALIBRATION_VOLTAGE

#undef SOURCING_IL

#undef SOURCING_IL_MAX

#undef TIMEOUT

#undef WAIT_TIME

#undef INPUT_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE

#undef PEAK



/* #define OSC_CHANNEL     1 */

/* #define TRIGGER_LEVEL   2.0e+00 */

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20.0e+06

#define CURRENT_LIMIT   60.0e-03

#define TRIGGER_WAIT_TIME  2.85e+00

/* #define MEASURE_WAIT_TIME  2.00e+00 */

/* #define AVERAGING       false */

/* #define OSC_FUNCTION    WIDTH */

/*   Which edge to measure?    */

/* #define EDGE            POS */

//------------------------------------------------------------------------------

void t9145(int mod_id, int slot)

{

  /* DRIVER POWER LIMIT PROTECTION */

  double tclk_freq;



  FILE *infile;



  test_result_type result;

  int driver;

  int driver_no;



//new variables

  double interval;

  int i;

  int counter;

  arrform waveform;

  int num_samples;

  double pwidth;



  infile = NULL;

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  connect_osc_ch1_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K755);   /* 24.5 ohm load    */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



//  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE = POS, TRIGGER_LEVEL= 2, AVERAGING);

    interval = 20E-6;

    num_samples = 1500;  // number of samples to make with the dmm

    // get the dmm ready to catch the voltage on its way from 10v to 20v

    setup_dmm_digitizing(mod_id, DMM_ADDRESS, 10, interval, num_samples, 1.4E-6, 1E-3, 2, POS);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    driver_no = driver - 'A';

    vth_pdrv_set_il(mod_id, slot, driver_no, CURRENT_LIMIT);

//    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);



    sales_reset_sequencer(mod_id, slot);



#include "t9145_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    sales_start_sequencer(mod_id, slot);



    flush_commands(mod_id);

//    display_prompt("waiting for measurement", true);

//    wait_for_dmm_measurement(mod_id);  // wait for the dmm to see the trigger

    display_prompt("Getting DMM_voltage", true);

    get_dmm_volt(mod_id, DMM_ADDRESS, num_samples, waveform, 0);



//Now get the pulse width of the signal by counting how many samples are in

//the signal from 1.75V to 1.75V

    counter = 0;

    for(i=0; i < num_samples; i++)

    {

      if (waveform[i] > 1.75)

        counter += 1;

    }

    pwidth = counter * interval;

    display_it(mod_id, "pwidth = ", counter, pwidth);

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = pwidth;

    log_result(mod_id, result);





//    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

/*    measure_osc(mod_id, OSC_FUNCTION, EDGE);

  if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);

*/



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



  }  /*for driver*/







  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



  if (infile != NULL)

    fclose(infile);

}  /*t9145*/

/* #undef OSC_CHANNEL */

/* #undef TRIGGER_LEVEL */

#undef TIMEOUT

#undef INPUT_FREQ

#undef CURRENT_LIMIT

#undef TRIGGER_WAIT_TIME

/* #undef MEASURE_WAIT_TIME */

/* #undef AVERAGING */

/* #undef OSC_FUNCTION */

/* #undef EDGE */



#define OSC_CHANNEL     1

#define COUNT           5

#define COUPLING        1000000

#define CHANNEL_RANGE   4.0e+00

#define CHANNEL_OFFSET  (-1.50e+00)

#define TRIGGER_LEVEL   (-1.5e+00)

#define TIMEBASE_RANGE  200e-03

#define TIMEBASE_OFFSET  90e-03

#define TRIGGER_WAIT_TIME  2.85e+00

#define MEASURE_WAIT_TIME  2.00e+00

#define TIMEOUT         1.0e-03

#define INPUT_FREQ      20.0e+06

#define AVERAGING       false

#define TIMEBASE_MODE   SINGLE

#define OSC_FUNCTION    WIDTH

/*   Which edge to measure?    */

#define EDGE            NEG

//------------------------------------------------------------------------------

void t9146(int mod_id, int slot)

{

  /* DRIVER POWER LIMIT PROTECTION */

  double tclk_freq;



  test_result_type result;

  int driver;



  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  connect_osc_ch1_af2(mod_id);



  vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */



  vth_pclose_rly(mod_id, slot, KDCG);   /* XG common relay  */

  vth_aclose_trp_chg_rly(mod_id);   /* Aim load common  */

  vth_aclose_rly(mod_id, K755);   /* 24.5 ohm load    */



  for (driver = 'A'; driver <= 'H'; driver++)

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /*for driver*/

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);



    sales_reset_sequencer(mod_id, slot);



#include "t9146_vml.cmd"

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



    sales_start_sequencer(mod_id, slot);



    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

    measure_osc(mod_id, OSC_FUNCTION, EDGE);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);



    vth_mseq_stop(mod_id, TIMEOUT);

    vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



  }  /*for driver*/



  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9146*/

#undef OSC_CHANNEL

#undef COUNT

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TRIGGER_WAIT_TIME

#undef MEASURE_WAIT_TIME

#undef TIMEOUT

#undef INPUT_FREQ

#undef AVERAGING

#undef TIMEBASE_MODE

#undef OSC_FUNCTION

#undef EDGE



#define RANGE           5

#define MUX_NODE_PIN    2

#define DMM_RESOLUTION  1.000e-03

#define DMM_FUNCTION    DCV

#define LOW_BOUNDS      5.50

#define HIGH_BOUNDS     10.2

#define HISTORICAL_MEAN  9.17

#define HISTORICAL_STD  0.10

#define RESOLUTION      0.02



/* static variables for t9147: */

struct LOC_t9147

{

  int mod_id;

  int slot;

  int driver;

} ;



static void close_the_relays(struct LOC_t9147 *LINK)

{

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KDC_RLYS[LINK->driver - 'A']);

      /* Xn connect relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KX_RLYS[LINK->driver - 'A']);

      /* Xn to receiver relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_DRVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KD_RLYS[LINK->driver - 'A']);

      /* Driver connect relay */

}



//------------------------------------------------------------------------------

void t9147(int mod_id, int slot)

{

  /* DRIVER OVER VOLTAGE LIMIT ACCURACY */

  struct LOC_t9147 V;



  double test_voltage;

  double voltage_increment;

  double actual_voltage;



  boolean v_limit_occurred;

  boolean found_interval;

  boolean found_high;

  boolean found_low;



  double high_guess;

  double low_guess;



  a_word_type this_word;

  test_result_type result;







  V.mod_id = mod_id;

  V.slot = slot;

  open_dmm(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);



  setup_dmm(V.mod_id, DMM_FUNCTION, static_cast<double>(RANGE), DMM_RESOLUTION);

  connect_dmm_pin(V.mod_id, V.slot);

  vth_aclose_rly(V.mod_id, K806);   /* Aim source to S bus */



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)   /* S bus to Xn busses */

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.driver - 'A']);



  vth_afc_en_src_out(V.mod_id);



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)

  {  /*for driver*/

    vth_asrc_set_dc_ampl(V.mod_id, LOW_BOUNDS);

    vth_pinit(V.mod_id, V.slot);



    v_limit_occurred = false;

    found_high = false;

    found_low = false;

    found_interval = false;

    test_voltage = HISTORICAL_MEAN;

    voltage_increment = HISTORICAL_STD;

    high_guess = HIGH_BOUNDS;

    low_guess = LOW_BOUNDS;



    close_the_relays(&V);

    while (high_guess - low_guess > 2 * RESOLUTION &&

           test_voltage > LOW_BOUNDS && test_voltage < HIGH_BOUNDS)

    {  /*while*/

      show_value(V.mod_id, "test voltage", test_voltage);

      vth_asrc_set_dc_ampl(V.mod_id, test_voltage);

      vth_mtmr_wait(V.mod_id, 0.050);



      vth_prd_stat(V.mod_id, V.slot);

      if (get_result_nolog(V.mod_id, &result))

      {  /*process result*/

        this_word.data = result.UU.Integer_result;

// mjs -- changed the bit number checked from 10 to 5 to reflect mucked up pascal code

        if (P_getbits_US(this_word.bits, 5, 0) == 0)

          v_limit_occurred = true;

        else

          v_limit_occurred = false;



      }  /*process result*/

      else

        display_prompt("No result in result log (Expected dig stat)", true);



      if (v_limit_occurred)

      {

        found_high = true;

        high_guess = test_voltage;

        vth_pdrv_clr_err(V.mod_id, V.slot);

        close_the_relays(&V);

      }

      else

      {

        found_low = true;

        low_guess = test_voltage;

      }



      if (found_high && found_low)

        found_interval = true;

      if (found_interval)

        voltage_increment /= 2;

      else

      {

        if (fabs(HISTORICAL_MEAN - test_voltage) > 3 * HISTORICAL_STD)

          voltage_increment *= 2;

      }



      if (v_limit_occurred)

        test_voltage -= voltage_increment;

      else

        test_voltage += voltage_increment;



    }  /*while*/





    if (!found_interval)

    {

      actual_voltage = test_voltage;

      display_prompt("error, not found interval", true);

    }

    else

    {  /*measure the acutal voltage*/

      show_value(V.mod_id, "final voltage", test_voltage);

      flush_commands(V.mod_id);

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_pin_gnd_relays(V.mod_id, V.slot);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.driver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.driver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

                 [V.driver - 'A']);

      vth_mtmr_wait(V.mod_id, 0.050);

      measure_dmm(V.mod_id);

      if (get_result_nolog(V.mod_id, &result))

        actual_voltage = result.UU.Real_result;

      else

        display_prompt("No result in result log (Expected dmm reading)", true);

    }  /*measure the acutal voltage*/



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_voltage;

    log_result(V.mod_id, result);



  }  /*for driver*/





  vth_ainit(V.mod_id);

  close_dmm(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);



}  /*t9147*/

#undef RANGE

#undef MUX_NODE_PIN

#undef DMM_RESOLUTION

#undef DMM_FUNCTION

#undef LOW_BOUNDS

#undef HIGH_BOUNDS

#undef HISTORICAL_MEAN

#undef HISTORICAL_STD

#undef RESOLUTION



#define RANGE           5

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define MIN_TEST_VOLTAGE  (-4.0e+00)

#define MAX_TEST_VOLTAGE  (-7.0e+00)

#define FINEST_INCREMENT  1.00e-03

#define STARTING_INCREMENT  512e-03

#define DMM_FUNCTION    DCV



/* static variables for t9148: */

struct LOC_t9148

{

  int mod_id;

  int slot;

  int driver;

};



static void close_the_relays_(struct LOC_t9148 *LINK)

{

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KDC_RLYS[LINK->driver - 'A']);

      /* Xn connect relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KX_RLYS[LINK->driver - 'A']);

      /* Xn to receiver relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_DRVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KD_RLYS[LINK->driver - 'A']);

      /* Driver connect relay */

}



//------------------------------------------------------------------------------

void t9148(int mod_id, int slot)

{

  /* DRIVER UNDER VOLTAGE LIMIT PROTECTION */

  struct LOC_t9148 V;

  double voltage_increment;

  double actual_voltage;

  double source_voltage;



  boolean v_limit_occurred;



  a_word_type this_word;

  test_result_type result;







  V.mod_id = mod_id;

  V.slot = slot;

  open_dmm(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);



  setup_dmm(V.mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(V.mod_id, V.slot);

  vth_aclose_rly(V.mod_id, K806);   /* Aim source to S bus */



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)   /* S bus to Xn busses */

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.driver - 'A']);



  vth_afc_en_src_out(V.mod_id);



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)

  {  /*for driver*/

    vth_asrc_set_dc_ampl(V.mod_id, MIN_TEST_VOLTAGE);

    vth_pinit(V.mod_id, V.slot);



    source_voltage = MIN_TEST_VOLTAGE;

    voltage_increment = STARTING_INCREMENT;

    v_limit_occurred = false;

    close_the_relays_(&V);

    while (!v_limit_occurred && source_voltage >= MAX_TEST_VOLTAGE)

    {  /*search for limit level*/

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_mtmr_wait(V.mod_id, 0.050);

      vth_prd_stat(V.mod_id, V.slot);

      if (!get_result_nolog(V.mod_id, &result))

      {  /*process the result*/

        display_prompt("No result in result log (Expected dig stat)", true);

        continue;

      }  /*process the result*/



      this_word.data = result.UU.Integer_result;

//mjs - changed bits number from 10 to 5

      if (P_getbits_US(this_word.bits, 5, 0) != 0)

      {  /* limit_occurred */

        source_voltage -= voltage_increment;

        continue;

      }  /* limit_occurred */

      v_limit_occurred = true;

      if (voltage_increment <= FINEST_INCREMENT)

        continue;

      v_limit_occurred = false;

      source_voltage += voltage_increment;

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_the_relays_(&V);

      voltage_increment /= 2;

    }  /*search for limit level*/



    if (!v_limit_occurred)

      actual_voltage = INT_MAX;

    else

    {  /*measure the acutal voltage*/

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_pin_gnd_relays(V.mod_id, V.slot);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.driver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.driver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

                 [V.driver - 'A']);

      measure_dmm(V.mod_id);

      if (get_result_nolog(V.mod_id, &result))

        actual_voltage = result.UU.Real_result;

      else

        display_prompt("No result in result log (Expected dmm reading)", true);

    }  /*measure the acutal voltage*/



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_voltage;

    log_result(V.mod_id, result);



  }  /*for driver*/







  vth_ainit(V.mod_id);



  close_dmm(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);



}  /*t9148*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef MIN_TEST_VOLTAGE

#undef MAX_TEST_VOLTAGE

#undef FINEST_INCREMENT

#undef STARTING_INCREMENT

#undef DMM_FUNCTION



#define MUX_NODE_PIN    2

#define MIN_TEST_VOLTAGE  5.500e+00

#define MAX_TEST_VOLTAGE  10.200e+00

#define FINEST_INCREMENT  10.0e-03

#define STARTING_INCREMENT  640.0e-03



/* static variables for t9149: */

struct LOC_t9149

{

  int mod_id;

  int slot;

  int driver;

} ;



static void close_the_relays__(struct LOC_t9149 *LINK)

{

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KDC_RLYS[LINK->driver - 'A']);

      /* Xn connect relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KX_RLYS[LINK->driver - 'A']);

      /* Xn to receiver relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_DRVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

             [LINK->driver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KD_RLYS[LINK->driver - 'A']);

      /* Driver connect relay */

}



//------------------------------------------------------------------------------

void t9149(int mod_id, int slot)

{

  /* DRIVER OVER VOLTAGE LIMIT ACCURACY */



  /* Debug test with all of the sales rack stuff taken out to allow bench */

  /* troubleshooting.  Logs the value the AIM source was set to as opposed */

  /* to the value that was read back from the DMM. */

  struct LOC_t9149 V;



  double voltage_increment;

  double actual_voltage;

  double source_voltage;



  boolean v_limit_occurred;



  a_word_type this_word;

  test_result_type result;







  V.mod_id = mod_id;

  V.slot = slot;

  vth_aclose_rly(V.mod_id, K806);   /* Aim source to S bus */



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)   /* S bus to Xn busses */

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.driver - 'A']);



  vth_afc_en_src_out(V.mod_id);

  vth_asrc_dis_30ma_ilim(V.mod_id);



  for (V.driver = 'A'; V.driver <= 'H'; V.driver++)

  {  /*for driver*/

    vth_asrc_set_dc_ampl(V.mod_id, MIN_TEST_VOLTAGE);

    vth_pinit(V.mod_id, V.slot);



    source_voltage = MIN_TEST_VOLTAGE;

    voltage_increment = STARTING_INCREMENT;

    v_limit_occurred = false;

    close_the_relays__(&V);

    while (!v_limit_occurred && source_voltage <= MAX_TEST_VOLTAGE)

    {  /*search for limit level*/

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_the_relays__(&V);

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_mtmr_wait(V.mod_id, 0.050);

      vth_prd_stat(V.mod_id, V.slot);

      if (!get_result_nolog(V.mod_id, &result))

      {  /*process the result*/

        display_prompt("No result in result log (Expected dig stat)", true);

        continue;

      }  /*process the result*/



      this_word.data = result.UU.Integer_result;

      if (P_getbits_US(this_word.bits, 10, 0) != 0)

      {  /* limit_occurred */

        source_voltage += voltage_increment;

        continue;

      }  /* limit_occurred */

      v_limit_occurred = true;

      if (voltage_increment <= FINEST_INCREMENT)

        continue;

      v_limit_occurred = false;

      source_voltage -= voltage_increment;

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_the_relays__(&V);

      voltage_increment /= 2;

    }  /*search for limit level*/



    if (!v_limit_occurred)

      actual_voltage = INT_MAX;

    else

      actual_voltage = source_voltage;



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_voltage;

    log_result(V.mod_id, result);



  }  /*for driver*/







  vth_ainit(V.mod_id);



}  /*t9149*/

#undef MUX_NODE_PIN

#undef MIN_TEST_VOLTAGE

#undef MAX_TEST_VOLTAGE

#undef FINEST_INCREMENT

#undef STARTING_INCREMENT



#define DMM_FUNCTION    DCV

/* pin 2 of 0 through 8 */

#define MUX_NODE_PIN    2

/* where to load waveform */

#define BLOCK           0

/* 8k low pass filter */

#define FILTER          7

/* Maximum sc ram vector */

#define VECTOR_LENGTH   126

/* Total number of vectors */

#define STEPS           128  //orig

#define RANGE           10.0e+00

#define RESOLUTION      1.0e-03

#define INPUT_FREQ      20e+06



/*  orig*/

#define RECEIVER_RANGE_P_P  0.4e+00

#define DC_OFFSET_VOLTAGE  5.0e+00

#define STOP_WAIT       0.7e+00

//------------------------------------------------------------------------------

void t9150(int mod_id, int slot)

{

  /*RECEIVER VOLTAGE ACCURACY - RECEIVE HIGH - +5v*/

  int receiver_no;

  int number_of_bytes;

  int byte_no;

  int vector;

  int gth_first_transition;

  int gtl_first_transition;

  int gth_last_transition;

  int gtl_last_transition;

  int expected_value;

  char filename[81];



  double tclk_freq;

  double ac_rms_amplitude;

  double increment;

  double initial_voltage;

  double final_voltage;



  boolean encountered_invalid_gth;

  boolean encountered_invalid_gtl;



  int rresp;

  int werr;

  int gtl;

  int receiver;

  a_byte_type this_byte;

  test_result_type result;

  buffer_record_type *b_ptr;

  double vfirst_gth[4]['H' + 1 - 'A'];

  double vfirst_gtl[4]['H' + 1 - 'A'];

  double vlast_gth[4]['H' + 1 - 'A'];

  double vlast_gtl[4]['H' + 1 - 'A'];


  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  initial_voltage = 0.0;

  final_voltage = 0.0;

  increment = 0.0;



  ac_rms_amplitude = RECEIVER_RANGE_P_P / sqrt(2.0) / 2;



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  tclk_freq = INPUT_FREQ / 64;



  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);

  sprintf(filename, "%ssales_step", testwhere_path);

  vth_aarb_ram_ld_file(mod_id, BLOCK, filename);

  //vth_aarb_ram_ld_file(mod_id, BLOCK, "step");

  vth_ascat_cpu_init(mod_id);



  vth_asrc_sel_fltr(mod_id, FILTER);

  vth_ascat_sel_freq(mod_id, 0);   /* Select frequency A        */

//  vth_ascat_set_a_freq(mod_id, 1024);   //richard == cafe

    vth_ascat_set_a_freq(mod_id, 512);   /* 512Hz uses every location */

  vth_ascat_en_arb_ss(mod_id);

  vth_ascat_run_en(mod_id);



  vth_asrc_set_ampl(mod_id, ac_rms_amplitude, DC_OFFSET_VOLTAGE);



  vth_afc_en_src_out(mod_id);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);

  vth_aclose_rly(mod_id, K806);   /*Aim source to S bus */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);

        /*S bus to X busses   */

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /*X busses disconnect */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /*X busses to mint    */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /*receiver connection */

    /*Now connect the source voltage to the mint pins for dmm access       */

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /*for receiver*/

  vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);   /*Wait for relays to close*/



  for (int ramp = NEG; ramp <= POS; ++ramp)

  {  /*for ramp*/
    vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      initial_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    sales_reset_sequencer(mod_id, slot);



#include "t9150_vml.cmd"



    vth_pfc_sel_arcv0(mod_id, slot, 0, 3);   /*ARCV0 = RRESP CHANNEL A*/

    vth_pfc_sel_arcv1(mod_id, slot, 0, 4);   /*ARCV1 = WERR  CHANNEL A*/



    sales_start_sequencer(mod_id, slot);



    vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

    vth_pfc_rst_sc_all(mod_id);   /*Reset the sc ram to enable reading */



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      final_voltage = result.UU.Real_result;

      increment = (final_voltage - initial_voltage) / STEPS;

    }  /*if*/

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      receiver_no = receiver - 'A';



      vth_pfc_get_act_rcv_sc_ram(mod_id, slot, receiver_no, 1, VECTOR_LENGTH);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        b_ptr = static_cast(buffer_record_type*,result.UU.Byte_ptr);

        number_of_bytes = b_ptr->Length;

        gth_first_transition = 0;

        gtl_first_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 1;

        else

          expected_value = 0;

/* debug routine for receiver */

/******************************************************************************/

//        unsigned int rcvr_byte_no;

//        FILE *sc_ram_file;

//        sc_ram_file = NULL;

//        sc_ram_file = fopen("sc_ram", "a");

//        fprintf(sc_ram_file, "===============================================\n");

//        fprintf(sc_ram_file, "RECEIVER %c\n", receiver);

//

//        for (rcvr_byte_no = 0; rcvr_byte_no < number_of_bytes; rcvr_byte_no++)

//        {

//          this_byte.data = b_ptr->Buffer[rcvr_byte_no];

//          fprintf(sc_ram_file, "%-d\n", this_byte.data);

//        }

//

//        fclose(sc_ram_file);

/******************************************************************************/







        for (byte_no = 0; byte_no < number_of_bytes; byte_no++)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];





          for (vector = 0; vector <= 3; vector++)

          {

            if (!encountered_invalid_gth)

            {



              if (P_getbits_US((2*this_byte.data), (vector * 2 + 1), 0) == expected_value)

              {

                gth_first_transition++;

              }

              else

              {

                encountered_invalid_gth = true;

              }



            }



            if (P_getbits_US((2*this_byte.data), (vector * 2), 0) == 0)

            {

              werr = 0;

            }

            else

            {

              werr = 1;

            }



            if (P_getbits_US((2*this_byte.data), (vector * 2 + 1), 0) == 0)

            {

              rresp = 0;

            }

            else

            {

              rresp = 1;

            }



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_first_transition++;

              else

              {

                encountered_invalid_gtl = true;



              }

            }



          }  /*if*/

        }  /*for*/



        gth_last_transition = 0;

        gtl_last_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 0;

        else

          expected_value = 1;

        for (byte_no = number_of_bytes - 1; byte_no >= 0; byte_no--)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 3; vector >= 0; vector--)

          {

            if (!encountered_invalid_gth)

            {



              if (P_getbits_US((2*this_byte.data), (vector * 2 + 1), 0) == expected_value)

              {

                gth_last_transition++;

              }

              else

              {

                encountered_invalid_gth = true;

              }

            }

            if (P_getbits_US((2*this_byte.data), (vector * 2), 0) == 0)

            {

              werr = 0;

            }

            else

            {

              werr = 1;

            }



            if (P_getbits_US((2*this_byte.data), (vector * 2 + 1), 0) == 0)

            {

              rresp = 0;

            }

            else

            {

              rresp = 1;

            }



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_last_transition++;

              else

                encountered_invalid_gtl = true;

            }



          }  /*if*/

        }  /*for*/



        gth_last_transition = 129 - gth_last_transition;

        gtl_last_transition = 129 - gtl_last_transition;



      }  /*if*/

      else

        display_prompt("No result in result log (Excepted SC RAM states)",

                       true);

      vfirst_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_first_transition * increment;

      vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024
      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = vfirst_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);



      vlast_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_last_transition * increment;



      vfirst_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_first_transition * increment;



      vlast_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_last_transition * increment;



    }  /*for receiver*/





    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vfirst_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



  }  /*for ramp*/







  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTH hysterisis for each receiver */

    result.UU.Real_result = vfirst_gth[POS][receiver - 'A'] - vfirst_gth[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTL hysterisis for each receiver */

    result.UU.Real_result = vfirst_gtl[POS][receiver - 'A'] - vfirst_gtl[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  /*t9150*/

#undef DMM_FUNCTION

#undef MUX_NODE_PIN

#undef BLOCK

#undef FILTER

#undef VECTOR_LENGTH

#undef STEPS

#undef RANGE

#undef RESOLUTION

#undef INPUT_FREQ

#undef RECEIVER_RANGE_P_P

#undef DC_OFFSET_VOLTAGE

#undef STOP_WAIT



#define DMM_FUNCTION    DCV

/* pin 2 of 0 through 8 */

#define MUX_NODE_PIN    2

/* where to load waveform */

#define BLOCK           0

/* 8k low pass filter */

#define FILTER          7

/* Maximum sc ram vector */

#define VECTOR_LENGTH   126

/* Total number of vectors */

#define STEPS           128

#define RANGE           10.0e+00

#define RESOLUTION      1.0e-03

#define INPUT_FREQ      20e+06

#define RECEIVER_RANGE_P_P  0.4e+00

#define DC_OFFSET_VOLTAGE  4.0e+00

#define STOP_WAIT       0.7e+00

//------------------------------------------------------------------------------

void t9151(int mod_id, int slot)

{

  /*RECEIVER VOLTAGE ACCURACY w/PULL UP 4.0v*/

  int receiver_no;

  int number_of_bytes;

  int byte_no;

  int vector;

  int gth_first_transition;

  int gtl_first_transition;

  int gth_last_transition;

  int gtl_last_transition;

  int expected_value;

  char filename[81];

  double tclk_freq;

  double ac_rms_amplitude;

  double increment;

  double initial_voltage;

  double final_voltage;



  boolean encountered_invalid_gth;

  boolean encountered_invalid_gtl;



  int rresp;

  int werr;

  int gtl;

  int receiver;

  a_byte_type this_byte;

  test_result_type result;

  buffer_record_type *b_ptr;

  double vfirst_gth[4]['H' + 1 - 'A'];

  double vfirst_gtl[4]['H' + 1 - 'A'];

  double vlast_gth[4]['H' + 1 - 'A'];

  double vlast_gtl[4]['H' + 1 - 'A'];






  OpenResourceManager();
  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  initial_voltage = 0.0;

  final_voltage = 0.0;

  increment = 0.0;



  ac_rms_amplitude = RECEIVER_RANGE_P_P / sqrt(2.0) / 2;



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);



  sprintf(filename, "%ssales_step", testwhere_path);

  vth_aarb_ram_ld_file(mod_id, BLOCK, filename);

  //vth_aarb_ram_ld_file(mod_id, BLOCK, "step");

  vth_ascat_cpu_init(mod_id);



  vth_asrc_sel_fltr(mod_id, FILTER);

  vth_ascat_sel_freq(mod_id, 0);   /* Select frequency A        */

  vth_ascat_set_a_freq(mod_id, 512);   /* 512Hz uses every location */

  vth_ascat_en_arb_ss(mod_id);

  vth_ascat_run_en(mod_id);



  vth_asrc_set_ampl(mod_id, ac_rms_amplitude, DC_OFFSET_VOLTAGE);



  vth_afc_en_src_out(mod_id);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);

  vth_aclose_rly(mod_id, K806);   /*Aim source to S bus */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);

        /*S bus to X busses   */

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /*X busses disconnect */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /*X busses to mint    */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /*receiver connection */

    /*Now connect the source voltage to the mint pins for dmm access       */

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /*for receiver*/

  vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);   /*Wait for relays to close*/



  for (int ramp = NEG; ramp <= POS; ++ramp)

  {  /*for ramp*/

    vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024
    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      initial_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    sales_reset_sequencer(mod_id, slot);



#include "t9151_vml.cmd"



    vth_pfc_sel_arcv0(mod_id, slot, 0, 3);   /*ARCV0 = RRESP CHANNEL A*/

    vth_pfc_sel_arcv1(mod_id, slot, 0, 4);   /*ARCV1 = WERR  CHANNEL A*/



    for (receiver = '\0'; receiver <= 'H' - 65; receiver++)

    {

      receiver_no = receiver;

      vth_prcv_dis_pdwn(mod_id, slot, receiver_no);

      vth_prcv_en_pup(mod_id, slot, receiver_no);

    }



    sales_start_sequencer(mod_id, slot);



    vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

    vth_pfc_rst_sc_all(mod_id);   /*Reset the sc ram to enable reading */



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      final_voltage = result.UU.Real_result;

      increment = (final_voltage - initial_voltage) / STEPS;

    }  /*if*/

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      receiver_no = receiver - 'A';



      vth_pfc_get_act_rcv_sc_ram(mod_id, slot, receiver_no, 1, VECTOR_LENGTH);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        b_ptr = static_cast(buffer_record_type*,result.UU.Byte_ptr);

        number_of_bytes = b_ptr->Length;

        gth_first_transition = 0;

        gtl_first_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 1;

        else

          expected_value = 0;



        for (byte_no = 0; byte_no < number_of_bytes; byte_no++)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 0; vector <= 3; vector++)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_first_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_first_transition++;

              else

              {

                encountered_invalid_gtl = true;



              }

            }

          }  /*if*/

        }  /*for*/





        gth_last_transition = 0;

        gtl_last_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 0;

        else

          expected_value = 1;

        for (byte_no = number_of_bytes - 1; byte_no >= 0; byte_no--)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 3; vector >= 0; vector--)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_last_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_last_transition++;

              else

                encountered_invalid_gtl = true;

            }



          }  /*if*/

        }  /*for*/



        gth_last_transition = 129 - gth_last_transition;

        gtl_last_transition = 129 - gtl_last_transition;



      }  /*if*/

      else

        display_prompt("No result in result log (Excepted SC RAM states)",

                       true);

      vfirst_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_first_transition * increment;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = vfirst_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

      vlast_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_last_transition * increment;

      vfirst_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_first_transition * increment;

      vlast_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_last_transition * increment;



    }  /*for receiver*/





    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vfirst_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



  }  /*for ramp*/







  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTH hysterisis for each receiver */

    result.UU.Real_result = vfirst_gth[POS][receiver - 'A'] - vfirst_gth[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTL hysterisis for each receiver */

    result.UU.Real_result = vfirst_gtl[POS][receiver - 'A'] - vfirst_gtl[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
   CloseResourceManager();


}  /*t9151*/

#undef DMM_FUNCTION

#undef MUX_NODE_PIN

#undef BLOCK

#undef FILTER

#undef VECTOR_LENGTH

#undef STEPS

#undef RANGE

#undef RESOLUTION

#undef INPUT_FREQ

#undef RECEIVER_RANGE_P_P

#undef DC_OFFSET_VOLTAGE

#undef STOP_WAIT



#define DMM_FUNCTION    DCV

/* pin 2 of 0 through 8 */

#define MUX_NODE_PIN    2

/* where to load waveform */

#define BLOCK           0

/* 8k low pass filter */

#define FILTER          7

/* Maximum sc ram vector */

#define VECTOR_LENGTH   126

/* Total number of vectors */

#define STEPS           128

#define RANGE           5.0e+00

#define RESOLUTION      1.0e-03

#define INPUT_FREQ      20e+06

#define RECEIVER_RANGE_P_P  0.4e+00

#define DC_OFFSET_VOLTAGE  (-3.5e+00)

#define STOP_WAIT       0.7e+00

//------------------------------------------------------------------------------

void t9152(int mod_id, int slot)

{

  /*RECEIVER VOLTAGE ACCURACY - RECEIVE HIGH - -3.5v*/

  int receiver_no;

  int number_of_bytes;

  int byte_no;

  int vector;

  int gth_first_transition;

  int gtl_first_transition;

  int gth_last_transition;

  int gtl_last_transition;

  int expected_value;



  char filename[81];



  double tclk_freq;

  double ac_rms_amplitude;

  double increment;

  double initial_voltage;

  double final_voltage;



  boolean encountered_invalid_gth;

  boolean encountered_invalid_gtl;



  int rresp;

  int werr;

  int gtl;

  int receiver;

  a_byte_type this_byte;

  test_result_type result;

  buffer_record_type *b_ptr;

  double vfirst_gth[4]['H' + 1 - 'A'];

  double vfirst_gtl[4]['H' + 1 - 'A'];

  double vlast_gth[4]['H' + 1 - 'A'];

  double vlast_gtl[4]['H' + 1 - 'A'];






  OpenResourceManager();

  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  initial_voltage = 0.0;

  final_voltage = 0.0;

  increment = 0.0;



  ac_rms_amplitude = RECEIVER_RANGE_P_P / sqrt(2.0) / 2;



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);

  sprintf(filename, "%ssales_step", testwhere_path);

  vth_aarb_ram_ld_file(mod_id, BLOCK, filename);

  //vth_aarb_ram_ld_file(mod_id, BLOCK, "step");

  vth_ascat_cpu_init(mod_id);



  vth_asrc_sel_fltr(mod_id, FILTER);

  vth_ascat_sel_freq(mod_id, 0);   /* Select frequency A        */

  vth_ascat_set_a_freq(mod_id, 512);   /* 512Hz uses every location */

  vth_ascat_en_arb_ss(mod_id);

  vth_ascat_run_en(mod_id);



  vth_asrc_set_ampl(mod_id, ac_rms_amplitude, DC_OFFSET_VOLTAGE);



  vth_afc_en_src_out(mod_id);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);

  vth_aclose_rly(mod_id, K806);   /*Aim source to S bus */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);

        /*S bus to X busses   */

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /*X busses disconnect */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /*X busses to mint    */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /*receiver connection */

    /*Now connect the source voltage to the mint pins for dmm access       */

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /*for receiver*/

  vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);   /*Wait for relays to close*/



  for (int ramp = NEG; ramp <= POS; ++ramp)

  {  /*for ramp*/

	vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024
	vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      initial_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    sales_reset_sequencer(mod_id, slot);



#include "t9152_vml.cmd"



    vth_pfc_sel_arcv0(mod_id, slot, 0, 3);   /*ARCV0 = RRESP CHANNEL A*/

    vth_pfc_sel_arcv1(mod_id, slot, 0, 4);   /*ARCV1 = WERR  CHANNEL A*/



    sales_start_sequencer(mod_id, slot);



    vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

    vth_pfc_rst_sc_all(mod_id);   /*Reset the sc ram to enable reading */



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      final_voltage = result.UU.Real_result;

      increment = (final_voltage - initial_voltage) / STEPS;

    }  /*if*/

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      receiver_no = receiver - 'A';



      vth_pfc_get_act_rcv_sc_ram(mod_id, slot, receiver_no, 1, VECTOR_LENGTH);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        b_ptr = static_cast(buffer_record_type*,result.UU.Byte_ptr);

        number_of_bytes = b_ptr->Length;

        gth_first_transition = 0;

        gtl_first_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 1;

        else

          expected_value = 0;



        for (byte_no = 0; byte_no < number_of_bytes; byte_no++)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 0; vector <= 3; vector++)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_first_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_first_transition++;

              else

              {

                encountered_invalid_gtl = true;



              }

            }

          }  /*if*/

        }  /*for*/





        gth_last_transition = 0;

        gtl_last_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 0;

        else

          expected_value = 1;

        for (byte_no = number_of_bytes - 1; byte_no >= 0; byte_no--)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 3; vector >= 0; vector--)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_last_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_last_transition++;

              else

                encountered_invalid_gtl = true;

            }



          }  /*if*/

        }  /*for*/



        gth_last_transition = 129 - gth_last_transition;

        gtl_last_transition = 129 - gtl_last_transition;



      }  /*if*/

      else

        display_prompt("No result in result log (Excepted SC RAM states)",

                       true);

      vfirst_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_first_transition * increment;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = vfirst_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

      vlast_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_last_transition * increment;

      vfirst_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_first_transition * increment;

      vlast_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_last_transition * increment;



    }  /*for receiver*/





    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vfirst_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



  }  /*for ramp*/







  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTH hysterisis for each receiver */

    result.UU.Real_result = vfirst_gth[POS][receiver - 'A'] - vfirst_gth[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTL hysterisis for each receiver */

    result.UU.Real_result = vfirst_gtl[POS][receiver - 'A'] - vfirst_gtl[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();



}  /*t9152*/

#undef DMM_FUNCTION

#undef MUX_NODE_PIN

#undef BLOCK

#undef FILTER

#undef VECTOR_LENGTH

#undef STEPS

#undef RANGE

#undef RESOLUTION

#undef INPUT_FREQ

#undef RECEIVER_RANGE_P_P

#undef DC_OFFSET_VOLTAGE

#undef STOP_WAIT



#define DMM_FUNCTION    DCV

/* pin 2 of 0 through 8 */

#define MUX_NODE_PIN    2

/* where to load waveform */

#define BLOCK           0

/* 8k low pass filter */

#define FILTER          7

/* Maximum sc ram vector */

#define VECTOR_LENGTH   126

/* Total number of vectors */

#define STEPS           128

#define RANGE           5.0e+00

#define RESOLUTION      1.0e-03

#define INPUT_FREQ      20e+06

#define RECEIVER_RANGE_P_P  0.4e+00

#define DC_OFFSET_VOLTAGE  (-2.5e+00)

#define STOP_WAIT       0.7e+00

//------------------------------------------------------------------------------

void t9153(int mod_id, int slot)

{

  /*RECEIVER VOLTAGE ACCURACY - RECEIVE HIGH - -3.5v*/

  int receiver_no;

  int number_of_bytes;

  int byte_no;

  int vector;

  int gth_first_transition;

  int gtl_first_transition;

  int gth_last_transition;

  int gtl_last_transition;

  int expected_value;

  int rresp;

  int werr;

  int gtl;

  int receiver;



  char filename[81];



  double tclk_freq;

  double ac_rms_amplitude;

  double increment;

  double initial_voltage;

  double final_voltage;

  double vfirst_gth[4]['H' + 1 - 'A'];

  double vfirst_gtl[4]['H' + 1 - 'A'];

  double vlast_gth[4]['H' + 1 - 'A'];

  double vlast_gtl[4]['H' + 1 - 'A'];



  boolean encountered_invalid_gth;

  boolean encountered_invalid_gtl;



  a_byte_type this_byte;

  test_result_type result;

  buffer_record_type *b_ptr;


  OpenResourceManager();
  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  initial_voltage = 0.0;

  final_voltage = 0.0;

  increment = 0.0;



  ac_rms_amplitude = RECEIVER_RANGE_P_P / sqrt(2.0) / 2;



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);

  connect_dmm_pin(mod_id, slot);



  tclk_freq = INPUT_FREQ / 64;

  vth_mtclk_clk_20m_mux(mod_id);

  vth_mtclk_set_freq(mod_id, INPUT_FREQ, tclk_freq);

  sprintf(filename, "%ssales_step", testwhere_path);

  vth_aarb_ram_ld_file(mod_id, BLOCK, filename);

  //vth_aarb_ram_ld_file(mod_id, BLOCK, "step");

  vth_ascat_cpu_init(mod_id);



  vth_asrc_sel_fltr(mod_id, FILTER);

  vth_ascat_sel_freq(mod_id, 0);   /* Select frequency A        */

  vth_ascat_set_a_freq(mod_id, 512);   /* 512Hz uses every location */

  vth_ascat_en_arb_ss(mod_id);

  vth_ascat_run_en(mod_id);



  vth_asrc_set_ampl(mod_id, ac_rms_amplitude, DC_OFFSET_VOLTAGE);



  vth_afc_en_src_out(mod_id);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);

  vth_aclose_rly(mod_id, K806);   /*Aim source to S bus */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);

        /*S bus to X busses   */

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /*X busses disconnect */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /*X busses to mint    */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /*receiver connection */

    /*Now connect the source voltage to the mint pins for dmm access       */

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /*for receiver*/

  vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);   /*Wait for relays to close*/



  for (int ramp = NEG; ramp <= POS; ++ramp)

  {  /*for ramp*/
    vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024
    vth_mtmr_wait(mod_id, 0.3); //added fikri 29/5/2024

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

      initial_voltage = result.UU.Real_result;

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    sales_reset_sequencer(mod_id, slot);



#include "t9153_vml.cmd"



    vth_pfc_sel_arcv0(mod_id, slot, 0, 3);   /*ARCV0 = RRESP CHANNEL A*/

    vth_pfc_sel_arcv1(mod_id, slot, 0, 4);   /*ARCV1 = WERR  CHANNEL A*/



    for (receiver = '\0'; receiver <= 'H' - 65; receiver++)

    {

      receiver_no = receiver;

      vth_prcv_dis_pup(mod_id, slot, receiver_no);

      vth_prcv_en_pdwn(mod_id, slot, receiver_no);

    }

    sales_start_sequencer(mod_id, slot);



    vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

    vth_pfc_rst_sc_all(mod_id);   /*Reset the sc ram to enable reading */



    for (receiver = 'A'; receiver <= 'H'; receiver++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      final_voltage = result.UU.Real_result;

      increment = (final_voltage - initial_voltage) / STEPS;

    }  /*if*/

    else

      display_prompt("No result in result log (Expected dmm voltage)", true);



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      receiver_no = receiver - 'A';



      vth_pfc_get_act_rcv_sc_ram(mod_id, slot, receiver_no, 1, VECTOR_LENGTH);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        b_ptr = static_cast(buffer_record_type*, result.UU.Byte_ptr);

        number_of_bytes = b_ptr->Length;

        gth_first_transition = 0;

        gtl_first_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 1;

        else

          expected_value = 0;



        for (byte_no = 0; byte_no < number_of_bytes; byte_no++)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 0; vector <= 3; vector++)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_first_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_first_transition++;

              else

              {

                encountered_invalid_gtl = true;



              }

            }

          }  /*if*/

        }  /*for*/





        gth_last_transition = 0;

        gtl_last_transition = 0;

        encountered_invalid_gth = false;

        encountered_invalid_gtl = false;

        if (ramp == NEG)

          expected_value = 0;

        else

          expected_value = 1;

        for (byte_no = number_of_bytes - 1; byte_no >= 0; byte_no--)

        {  /*for*/

          this_byte.data = b_ptr->Buffer[byte_no];

          for (vector = 3; vector >= 0; vector--)

          {

            if (!encountered_invalid_gth)

            {

              if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) ==

                  expected_value)

                gth_last_transition++;

              else

                encountered_invalid_gth = true;

            }



            if (P_getbits_US((2*this_byte.data), vector * 2, 0) == 0)

              werr = 0;

            else

              werr = 1;

            if (P_getbits_US((2*this_byte.data), vector * 2 + 1, 0) == 0)

              rresp = 0;

            else

              rresp = 1;



            gtl = exclusive_or(werr, rresp);



            if (!encountered_invalid_gtl)

            {

              if (gtl == expected_value)

                gtl_last_transition++;

              else

                encountered_invalid_gtl = true;

            }



          }  /*if*/

        }  /*for*/



        gth_last_transition = 129 - gth_last_transition;

        gtl_last_transition = 129 - gtl_last_transition;



      }  /*if*/

      else

        display_prompt("No result in result log (Excepted SC RAM states)",

                       true);

      vfirst_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_first_transition * increment;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = vfirst_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

      vlast_gth[ramp]

        [receiver - 'A'] = initial_voltage + gth_last_transition * increment;

      vfirst_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_first_transition * increment;

      vlast_gtl[ramp]

        [receiver - 'A'] = initial_voltage + gtl_last_transition * increment;



    }  /*for receiver*/





    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gth[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vfirst_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /*for receiver*/

      result.UU.Real_result = vlast_gtl[ramp][receiver - 'A'];

      log_result(mod_id, result);

    }  /*for receiver*/



  }  /*for ramp*/







  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTH hysterisis for each receiver */

    result.UU.Real_result = vfirst_gth[POS][receiver - 'A'] - vfirst_gth[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    /* calculte the GTL hysterisis for each receiver */

    result.UU.Real_result = vfirst_gtl[POS][receiver - 'A'] - vfirst_gtl[NEG]

                            [receiver - 'A'];



    log_result(mod_id, result);

  }  /*for receiver*/





  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
  CloseResourceManager();


}  /*t9153*/

#undef DMM_FUNCTION

#undef MUX_NODE_PIN

#undef BLOCK

#undef FILTER

#undef VECTOR_LENGTH

#undef STEPS

#undef RANGE

#undef RESOLUTION

#undef INPUT_FREQ

#undef RECEIVER_RANGE_P_P

#undef DC_OFFSET_VOLTAGE

#undef STOP_WAIT



#define PS_CHANNEL      1

#define DUT_VOLTS       5.25

#define DUT_OV          20.0

#define DUT_CURRENT     1.00

#define VALID_CARD_ID   33

#define STOP_TIME       1.0e-03

#define WAIT_TIME       1.0e-03

#define TEST_FREQ       10e+06

#define DRV_HI_VOLTS    4.5e+00

#define DRV_LO_VOLTS    0.2e+00

#define DRV_IL          0.1e+00

#define RCV_HI_VOLTS    2.0e+00

#define RCV_LO_VOLTS    0.8e+00

#define STARTING_GTL    1.0e+00

#define GTL_INCREMENT   2.5e-02

#define GTH             1

#define GTL             0

#define MIN_GTL_SEARCH  0.0e00

//------------------------------------------------------------------------------

void t9155(int mod_id, int slot)

{

  /*REQUIRES A SPECIAL FIXTURE Receiver Ringing Clamp Test*/

  int card_id;

int channel;

  int channel_no;

  test_result_type result;

  double gtl_voltage;

  double tic_freq;

  double low_found;

  double high_found;

  boolean found;





  vth_prd_cell(mod_id, slot, PCARD_ID);

  if (get_result_nolog(mod_id, &result))

    card_id = result.UU.Integer_result;

  else

    display_prompt("No result in result log (Expected pin cell)", true);



  if (card_id == VALID_CARD_ID)

  {  /*null test*/

    /* Setup the dut supply to power the latches in the fixture */

    open_dut_ps(mod_id);

    setup_dut_ps(mod_id, PS_CHANNEL, DUT_VOLTS, DUT_OV, DUT_CURRENT);





    /*Stop the sequencer*/

    vth_mseq_stop(mod_id, STOP_TIME);



    /*Set up the user clock and enable it onto the mint pins*/

    vth_mclose_rly(mod_id, MK2801);

    vth_mclose_rly(mod_id, MK2802);

    vth_mdclk_en_uclk(mod_id);

    vth_mdclk_0_set_freq(mod_id, TEST_FREQ);



    close_pin_gnd_relays(mod_id, slot);



    for (channel = 'A'; channel <= 'H'; channel++)

    {  /*for each channel*/

      vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[channel - 'A']);

          /*receiver connection */

      vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

          /*driver connection */

      switch (channel)

      {



      case 'A':

      case 'B':

      case 'E':

      case 'F':  /*for channels A,B,E, and F*/

        vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[8][channel - 'A']);

        vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[7][channel - 'A']);

        break;

        /*for channels A,B,E, and F*/



      case 'C':

      case 'D':

      case 'G':

      case 'H':  /*for channels C,D,G, and H*/

        vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[0][channel - 'A']);

        vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[1][channel - 'A']);

        break;

        /*for channels C,D,G, and H*/

      default:

        assert(false);

        break;



      }/*case*/

      channel_no = channel - 'A';

      vth_pdrv_set_hi(mod_id, slot, channel_no, DRV_HI_VOLTS);

      vth_pdrv_set_lo(mod_id, slot, channel_no, DRV_LO_VOLTS);

      vth_pdrv_set_il(mod_id, slot, channel_no, DRV_IL);

      vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

      vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

      vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

      vth_prcv_set_hi(mod_id, slot, channel_no, RCV_HI_VOLTS);

      vth_prcv_set_lo(mod_id, slot, channel_no, RCV_LO_VOLTS);



    }  /*for each channel*/



    vth_mseq_neg_cpu_tsp(mod_id);



    /*Enable the arcv lines from pin card onto the mother card*/

    vth_pen_arcv0(mod_id, slot);

    vth_pen_arcv1(mod_id, slot);



    /*Enable the arcv lines from the mother card into the TIC*/

    vth_mmbd_en_arcv(mod_id);

    vth_mtic_a_arcv0_mux(mod_id);

    vth_mtic_b_arcv1_mux(mod_id);

    vth_mclose_rly(mod_id, MK1601);

    vth_mclose_rly(mod_id, MK1606);



    vth_prcv_en_clamp_all_slot(mod_id);



    for (channel = '\0'; channel <= 'H' - 65; channel++)

    {  /*for channel*/

      channel_no = channel;

      vth_pfc_sel_arcv1(mod_id, slot, channel_no, GTH);

      vth_mtmr_wait(mod_id, WAIT_TIME);   /*Let everything settle out*/

      vth_mtic_freq_b_meas(mod_id);

      if (!get_result_log(mod_id, &result))

        display_prompt("No result in result log (Expected TIC meas)", true);

    }  /*for channel*/



    low_found = 0.0;

    high_found = TEST_FREQ + TEST_FREQ;



    for (channel = '\0'; channel <= 'H' - 65; channel++)

    {  /*for channel*/

      channel_no = channel;

      vth_pfc_sel_arcv0(mod_id, slot, channel_no, GTL);

      gtl_voltage = STARTING_GTL;

      found = false;

      do

      {

        vth_prcv_set_lo(mod_id, slot, channel_no, gtl_voltage);

        vth_mtmr_wait(mod_id, WAIT_TIME);   /*Let each channel settle out*/

        vth_mtic_freq_a_meas(mod_id);

        if (get_result_nolog(mod_id, &result))

        {

          tic_freq = result.UU.Real_result;

          if (tic_freq < low_found || tic_freq > high_found)

            found = true;

        }

        else

          display_prompt("No result in result log (Expected TIC meas)", true);

        gtl_voltage -= GTL_INCREMENT;

      } while (!(found || gtl_voltage < MIN_GTL_SEARCH));

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = gtl_voltage + GTL_INCREMENT;

      log_result(mod_id, result);

      vth_prcv_set_lo(mod_id, slot, channel_no, RCV_LO_VOLTS);

    }  /*for channel*/



    vth_mseq_ass_cpu_tsp(mod_id);

    vth_pfc_dis_arcv0(mod_id, slot, channel_no);

    vth_pfc_dis_arcv1(mod_id, slot, channel_no);



    close_dut_ps(mod_id);



  }  /*null test*/



  /*do the test*/



  /*do the test*/

}  /*t9155*/

#undef PS_CHANNEL

#undef DUT_VOLTS

#undef DUT_OV

#undef DUT_CURRENT

#undef VALID_CARD_ID

#undef STOP_TIME

#undef WAIT_TIME

#undef TEST_FREQ

#undef DRV_HI_VOLTS

#undef DRV_LO_VOLTS

#undef DRV_IL

#undef RCV_HI_VOLTS

#undef RCV_LO_VOLTS

#undef STARTING_GTL

#undef GTL_INCREMENT

#undef GTH

#undef GTL

#undef MIN_GTL_SEARCH



#define PS_CHANNEL      1

#define DUT_VOLTS       5.25

#define DUT_OV          20.0

#define DUT_CURRENT     1.00

#define VALID_CARD_ID   33

#define STOP_TIME       1.0e-03

#define WAIT_TIME       1.0e-03

#define TEST_FREQ       1e+06

#define DRV_HI_VOLTS    4.5e+00

#define DRV_LO_VOLTS    0.2e+00

#define DRV_IL          0.1e+00

#define RCV_HI_VOLTS    2.0e+00

#define RCV_LO_VOLTS    0.8e+00

#define STARTING_GTL    1.0e+00

#define GTL_INCREMENT   2.5e-02

#define GTH             1

#define GTL             0

#define MIN_GTL_SEARCH  0.0e00

//------------------------------------------------------------------------------

void t9156(int mod_id, int slot)

{

  /*REQUIRES A SPECIAL FIXTURE Receiver Ringing Clamp Test*/

  int card_id;

  int channel;

  int channel_no;

  test_result_type result;

  double gtl_voltage;

  double tic_freq;

  double low_found;

  double high_found;

  boolean found;





  vth_prd_cell(mod_id, slot, PCARD_ID);

  if (get_result_nolog(mod_id, &result))

    card_id = result.UU.Integer_result;

  else

    display_prompt("No result in result log (Expected pin cell)", true);



  if (card_id == VALID_CARD_ID)

  {  /*null test*/

    /* Setup the dut supply to power the latches in the fixture */

    open_dut_ps(mod_id);

    setup_dut_ps(mod_id, PS_CHANNEL, DUT_VOLTS, DUT_OV, DUT_CURRENT);





    /*Stop the sequencer*/

    vth_mseq_stop(mod_id, STOP_TIME);



    /*Set up the user clock and enable it onto the mint pins*/

    vth_mclose_rly(mod_id, MK2801);

    vth_mclose_rly(mod_id, MK2802);

    vth_mdclk_en_uclk(mod_id);

    vth_mdclk_0_set_freq(mod_id, TEST_FREQ);



    close_pin_gnd_relays(mod_id, slot);



    for (channel = 'A'; channel <= 'H'; channel++)

    {  /*for each channel*/

      vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[channel - 'A']);

          /*receiver connection */

      vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[channel - 'A']);

          /*driver connection */

      switch (channel)

      {



      case 'A':

      case 'B':

      case 'E':

      case 'F':  /*for channels A,B,E, and F*/

        vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[8][channel - 'A']);

        vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[7][channel - 'A']);

        break;

        /*for channels A,B,E, and F*/



      case 'C':

      case 'D':

      case 'G':

      case 'H':  /*for channels C,D,G, and H*/

        vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[0][channel - 'A']);

        vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[1][channel - 'A']);

        break;

        /*for channels C,D,G, and H*/

      default:

        assert(false);

        break;



      }/*case*/

      channel_no = channel - 'A';

      vth_pdrv_set_hi(mod_id, slot, channel_no, DRV_HI_VOLTS);

      vth_pdrv_set_lo(mod_id, slot, channel_no, DRV_LO_VOLTS);

      vth_pdrv_set_il(mod_id, slot, channel_no, DRV_IL);

      vth_pfc_set_sttc_dd(mod_id, slot, channel_no, 1);

      vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

      vth_pfc_set_sttc_tsp(mod_id, slot, channel_no, 0);

      vth_prcv_set_hi(mod_id, slot, channel_no, RCV_HI_VOLTS);

      vth_prcv_set_lo(mod_id, slot, channel_no, RCV_LO_VOLTS);



    }  /*for each channel*/



    vth_mseq_neg_cpu_tsp(mod_id);



    /*Enable the arcv lines from pin card onto the mother card*/

    vth_pen_arcv0(mod_id, slot);

    vth_pen_arcv1(mod_id, slot);



    /*Enable the arcv lines from the mother card into the TIC*/

    vth_mmbd_en_arcv(mod_id);

    vth_mtic_a_arcv0_mux(mod_id);

    vth_mtic_b_arcv1_mux(mod_id);

    vth_mclose_rly(mod_id, MK1601);

    vth_mclose_rly(mod_id, MK1606);



    vth_prcv_en_clamp_all_slot(mod_id);



    for (channel = '\0'; channel <= 'H' - 65; channel++)

    {  /*for channel*/

      channel_no = channel;

      vth_pfc_sel_arcv1(mod_id, slot, channel_no, GTH);

      vth_mtmr_wait(mod_id, WAIT_TIME);   /*Let everything settle out*/

      vth_mtic_freq_b_meas(mod_id);

      if (!get_result_log(mod_id, &result))

        display_prompt("No result in result log (Expected TIC meas)", true);

    }  /*for channel*/



    low_found = 0.0;

    high_found = TEST_FREQ + TEST_FREQ;



    for (channel = '\0'; channel <= 'H' - 65; channel++)

    {  /*for channel*/

      channel_no = channel;

      vth_pfc_sel_arcv0(mod_id, slot, channel_no, GTL);

      gtl_voltage = STARTING_GTL;

      found = false;

      do

      {

        vth_prcv_set_lo(mod_id, slot, channel_no, gtl_voltage);

        vth_mtmr_wait(mod_id, WAIT_TIME);   /*Let each channel settle out*/

        vth_mtic_freq_a_meas(mod_id);

        if (get_result_nolog(mod_id, &result))

        {

          tic_freq = result.UU.Real_result;

          if (tic_freq < low_found || tic_freq > high_found)

            found = true;

        }

        else

          display_prompt("No result in result log (Expected TIC meas)", true);

        gtl_voltage -= GTL_INCREMENT;

      } while (!(found || gtl_voltage < MIN_GTL_SEARCH));

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = gtl_voltage + GTL_INCREMENT;

      log_result(mod_id, result);

      vth_prcv_set_lo(mod_id, slot, channel_no, RCV_LO_VOLTS);

    }  /*for channel*/



    vth_mseq_ass_cpu_tsp(mod_id);

    vth_pfc_dis_arcv0(mod_id, slot, channel_no);

    vth_pfc_dis_arcv1(mod_id, slot, channel_no);



    close_dut_ps(mod_id);



  }  /*null test*/



  /*do the test*/



  /*do the test*/

}  /*t9156*/

#undef PS_CHANNEL

#undef DUT_VOLTS

#undef DUT_OV

#undef DUT_CURRENT

#undef VALID_CARD_ID

#undef STOP_TIME

#undef WAIT_TIME

#undef TEST_FREQ

#undef DRV_HI_VOLTS

#undef DRV_LO_VOLTS

#undef DRV_IL

#undef RCV_HI_VOLTS

#undef RCV_LO_VOLTS

#undef STARTING_GTL

#undef GTL_INCREMENT

#undef GTH

#undef GTL

#undef MIN_GTL_SEARCH



#define RANGE           3

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define RECEIVE_HI      2.0e+00

#define PULL_UP_LOAD_RESISTANCE  500e+00

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9160(int mod_id, int slot)

{

  /*RECEIVER INPUT CURRENT SOURCING*/

  int receiver_no;



  double pull_up_actual_voltage;

  double pull_up_current;



  test_result_type result;

int receiver;





  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_500_ohm_load(mod_id);



  close_pin_gnd_relays(mod_id, slot);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for receiver */

    receiver_no = receiver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_prcv_set_hi(mod_id, slot, receiver_no, RECEIVE_HI);

    vth_prcv_dis_pdwn(mod_id, slot, receiver_no);

    vth_prcv_en_pup(mod_id, slot, receiver_no);

    vth_mtmr_wait(mod_id, STANDARD_WAIT_TIME);



    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      pull_up_actual_voltage = result.UU.Real_result;

      pull_up_current = pull_up_actual_voltage / PULL_UP_LOAD_RESISTANCE;

      result.UU.Real_result = pull_up_current;

      log_result(mod_id, result);

    }  /*if*/

    else

      display_prompt("No result in result log (Expected rcvr pull up voltage)",

                     true);



    vth_prcv_dis_pup(mod_id, slot, receiver_no);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /* for receiver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9160 */

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef RECEIVE_HI

#undef PULL_UP_LOAD_RESISTANCE

#undef DMM_FUNCTION



#define RANGE           3

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define RECEIVE_LO      (-3.0e+00)

#define PULL_DN_LOAD_RESISTANCE  500e+00

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9161(int mod_id, int slot)

{

  /*RECEIVER INPUT CURRENT SINKING*/

  int receiver_no;



  double pull_dn_actual_voltage;

  double pull_dn_current;



  test_result_type result;

  int receiver;



  OpenResourceManager();


  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_500_ohm_load(mod_id);



  close_pin_gnd_relays(mod_id, slot);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for receiver */

    receiver_no = receiver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_prcv_set_lo(mod_id, slot, receiver_no, RECEIVE_LO);

    vth_prcv_dis_pup(mod_id, slot, receiver_no);

    vth_prcv_en_pdwn(mod_id, slot, receiver_no);

    vth_mtmr_wait(mod_id, STANDARD_WAIT_TIME);

    flush_commands(mod_id);

	measure_dmm(mod_id);


    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      pull_dn_actual_voltage = result.UU.Real_result;

      pull_dn_current = pull_dn_actual_voltage / PULL_DN_LOAD_RESISTANCE;

      result.UU.Real_result = pull_dn_current;

      log_result(mod_id, result);

    }  /*if*/

    else

      display_prompt("No result in result log (Expected rcvr pull dn voltage)",

                     true);



    vth_prcv_dis_pdwn(mod_id, slot, receiver_no);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /* for receiver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);
   CloseResourceManager();




}  /* t9161 */

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef RECEIVE_LO

#undef PULL_DN_LOAD_RESISTANCE

#undef DMM_FUNCTION





#define BELOW           0

#define ABOVE_          2

typedef double rx_level_array[3];

#define MUX_NODE_PIN    2

#define RANGE           300e-03

#define RESOLUTION      1.0e-03

#define RECEIVER_LOAD_RESISTANCE  500e+00

const rx_level_array RECEIVE_LO_LEVEL = {1.0, -2.0, -2.0};

const rx_level_array RECEIVE_HI_LEVEL = {2.0, 2.0, -1.0};

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9162(int mod_id, int slot)

{

  /*RECEIVER INPUT LEAKAGE CURRENT*/

  int receiver_no;



  double receive_lo;

  double receive_hi;

  double receiver_input_voltage;

  double receiver_input_current;



  test_result_type result;

  int receiver;

  OpenResourceManager();


  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);



  connect_dmm_pin(mod_id, slot);

  connect_500_ohm_load(mod_id);



  close_pin_gnd_relays(mod_id, slot);

  flush_commands(mod_id);


  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

     flush_commands(mod_id);


  for (int receiver_level = BELOW; receiver_level <= ABOVE_; ++receiver_level)

  {  /* FOR EACH RECEIVER LEVEL */

    receive_lo = RECEIVE_LO_LEVEL[receiver_level];

    receive_hi = RECEIVE_HI_LEVEL[receiver_level];

     flush_commands(mod_id);


    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /* for receiver */

      receiver_no = receiver - 'A';

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

      vth_prcv_set_lo(mod_id, slot, receiver_no, receive_lo);

      vth_prcv_set_hi(mod_id, slot, receiver_no, receive_hi);

      vth_prcv_dis_pdwn(mod_id, slot, receiver_no);

      vth_prcv_dis_pup(mod_id, slot, receiver_no);
      flush_commands(mod_id);

      vth_mtmr_wait(mod_id, STANDARD_WAIT_TIME);

      flush_commands(mod_id);
      vth_mtmr_wait(mod_id, 0.5);


      measure_dmm(mod_id);

      if (get_result_nolog(mod_id, &result))

      {  /*if*/

        receiver_input_voltage = result.UU.Real_result;

        receiver_input_current = receiver_input_voltage / RECEIVER_LOAD_RESISTANCE;

        result.UU.Real_result = receiver_input_current;

        log_result(mod_id, result);

      }  /*if*/

      else

        display_prompt("No result in result log (Expected dmm voltage)", true);



      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);
      flush_commands(mod_id);

    }  /* for receiver */



  }  /* FOR RECEIVER LEVEL */





  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  CloseResourceManager();


}  /* t9162 */

#undef BELOW

#undef ABOVE_

#undef MUX_NODE_PIN

#undef RANGE

#undef RESOLUTION

#undef RECEIVER_LOAD_RESISTANCE

#undef DMM_FUNCTION



#define RANGE           6

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define RECEIVE_HI      4.0e+00

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9165(int mod_id, int slot)

{

  /*RECEIVER INPUT CLAMP - PULL UP*/

  int receiver_no;



  test_result_type result;

  int receiver;





  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for receiver */

    receiver_no = receiver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_prcv_set_hi(mod_id, slot, receiver_no, RECEIVE_HI);

    vth_prcv_dis_pdwn(mod_id, slot, receiver_no);

    vth_prcv_en_pup(mod_id, slot, receiver_no);



    measure_dmm(mod_id);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected rcvr clamp voltage)",

                     true);



    vth_prcv_dis_pup(mod_id, slot, receiver_no);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /* for receiver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9165 */

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef RECEIVE_HI

#undef DMM_FUNCTION



#define RANGE           5

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define RECEIVE_LO      (-2.5e+00)

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9166(int mod_id, int slot)

{

  /*RECEIVER INPUT CLAMP - PULL DOWN*/

  int receiver_no;



  test_result_type result;

  int receiver;





  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for receiver */

    receiver_no = receiver - 'A';

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_prcv_set_lo(mod_id, slot, receiver_no, RECEIVE_LO);

    vth_prcv_dis_pup(mod_id, slot, receiver_no);

    vth_prcv_en_pdwn(mod_id, slot, receiver_no);



    measure_dmm(mod_id);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected rcvr pull dn voltage)",

                     true);



    vth_prcv_dis_pdwn(mod_id, slot, receiver_no);



    vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

  }  /* for receiver */



  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9166 */

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef RECEIVE_LO

#undef DMM_FUNCTION



#define RANGE           5

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define RECEIVE_HI      0.0e+00

#define RECEIVE_LO      0.0e+00

#define DMM_FUNCTION    DCV

#define UP              0

#define DOWN_           1

//------------------------------------------------------------------------------

void t9167(int mod_id, int slot)

{

  /*RECEIVER INPUT CLAMP @ 0V - PULL UP, THEN DOWN*/

  int receiver_no;

  test_result_type result;

  int receiver;



  open_dmm(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(mod_id, slot);



  close_pin_gnd_relays(mod_id, slot);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);



  for (int pull = UP; pull <= DOWN_; ++pull)

  {

    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /* for receiver */

      receiver_no = receiver - 'A';

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

      vth_prcv_set_lo(mod_id, slot, receiver_no, RECEIVE_LO);

      vth_prcv_set_hi(mod_id, slot, receiver_no, RECEIVE_HI);

      if (pull == UP)

      {  /*activate pull up*/

        vth_prcv_dis_pdwn(mod_id, slot, receiver_no);

        vth_prcv_en_pup(mod_id, slot, receiver_no);

      }  /*activate pull up*/

      else

      {  /*activate pull down*/

        vth_prcv_dis_pup(mod_id, slot, receiver_no);

        vth_prcv_en_pdwn(mod_id, slot, receiver_no);

      }  /*activate pull down*/





      measure_dmm(mod_id);

      if (!get_result_log(mod_id, &result))

        display_prompt("No result in result log (Expected rcvr pull dn voltage)",

                       true);





      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    }  /* for receiver */

  }





  vth_pinit(mod_id, slot);



  close_dmm(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /* t9167 */

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef RECEIVE_HI

#undef RECEIVE_LO

#undef DMM_FUNCTION

#undef UP

#undef DOWN_



/*V/uS*/

#define SLEW_RATE       225

#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.1e+00

#define GEN_HIGH_UNTERMINATED  1.75e+00

#define GEN_HIGH_TERMINATED  3.5e+00

/* Autocal delay setting */

#define T0_ACTUAL       160e-09

#define RX_SPEC         10e-09

#define SLOT_DELAY_NOM  8e-09

#define TIMEOUT         1.0e-03

#define STOP_WAIT       100e-03

#define DELAY_INCREMENT  1.0e-09

#define PROG_DELAY_     20e-09

#define TCLK_ADV_TIME   40e-09

#define SYNC_ADV_TIME   5.9e-09

#define SLEW_RATE_DELAY  4.0e-09

#define NON_INVERTED    0

#define INVERTED        1

//------------------------------------------------------------------------------

void t9170(int mod_id, int slot)

{

  /*Receiver Edge Accuracy and Skew*/

  int mux_node_pin;

  int receiver_no;



  double gen_delay;

  double transition_time;

  double expected_receive;

  double actual_receive;

  double cal_min_set;

  double cal_max_set;

  double cal_min_actual;

  double cal_max_actual;

  double rx_range;

  double skew;

  double delta_delay;

  double guessed_value;



  double offset[2];

  double gain[2];

  double ch_result['H' + 1 - 'A'][2];



  boolean expected_response;

  boolean edge_found;

  boolean rresp;

  boolean werr;

  boolean guessing;



  int loop;

  test_result_type result;

  int receiver;





  rx_range = 2 * RX_SPEC;

  delta_delay = af2_system_delay[mod_id] + (slot_delay[slot - 1]

          [RISING] + slot_delay[slot - 1]

          [FALLING]) / 2 + SLEW_RATE_DELAY - af2_clkrb_delay[mod_id];

  expected_receive = T0_ACTUAL + PROG_DELAY_ - TCLK_ADV_TIME;

  cal_min_set = expected_receive - delta_delay - rx_range - SLOT_DELAY_NOM;

  cal_min_set = (int)cal_min_set / 1e9;

  cal_max_set = expected_receive - delta_delay + rx_range - SLOT_DELAY_NOM;

  cal_max_set = (int)cal_max_set / 1e9;

  guessed_value = expected_receive - delta_delay - SLOT_DELAY_NOM + 5e-09;

  guessed_value = (int)guessed_value / 1e9;

  transition_time = (GEN_HIGH_TERMINATED - GEN_LOW) * 0.8 / SLEW_RATE;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);

  setup_gen_transition_times(mod_id, transition_time);



  for (loop = NON_INVERTED; loop <= INVERTED; ++loop)

  {  /* Measure the offset and gain for pos and neg generator output */

    setup_gen_trg_out_delay(mod_id, cal_min_set);

    enable_gen_out(mod_id);

    trigger_cntr(mod_id);

    cal_min_actual = read_cntr_mean(mod_id);

    setup_gen_trg_out_delay(mod_id, cal_max_set);

    trigger_cntr(mod_id);

    cal_max_actual = read_cntr_mean(mod_id);

    disable_gen_out(mod_id);



    offset[loop] = cal_min_actual;

    gain[loop] = (cal_max_actual - cal_min_actual) / (cal_max_set - cal_min_set);



    complement_gen_out(mod_id);

    setup_cntr_trigger_slopes(mod_id, POS, NEG);



  }  /* Measure the offset and gain for pos and neg generator output */





  no_complement_gen_out(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_UNTERMINATED);

  connect_gen_trg_clkrb(mod_id);

  connect_gen_out_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

    switch (receiver)

    {   /*Use mux_node_pins closest to the grounds*/



    case 'A':

    case 'B':

    case 'E':

    case 'F':

      mux_node_pin = 7;

      break;



    case 'C':

    case 'D':

    case 'G':

    case 'H':

      mux_node_pin = 0;

      break;

    default:

      assert(false);

      break;



    }/* case */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][receiver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][receiver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, TCLK_ADV_TIME + SYNC_ADV_TIME);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  for (loop = NON_INVERTED; loop <= INVERTED; ++loop)

  {  /* for */

    if (loop == NON_INVERTED)

    {  /* then */

      no_complement_gen_out(mod_id);

      expected_response = true;

    }  /* then */

    else

    {  /* else */

      complement_gen_out(mod_id);

      expected_response = false;

    }  /* else */

    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /* for receiver */

      receiver_no = receiver - 'A';

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);

      gen_delay = guessed_value;

      guessing = true;

      setup_gen_trg_out_delay(mod_id, gen_delay);

      enable_gen_out(mod_id);

      edge_found = false;

      werr = true;

      do

      {

        sales_reset_sequencer(mod_id, slot);



#include "t9170_vml.cmd"

        vth_pfc_sel_arcv0(mod_id, slot, receiver_no, 3);   /* ARCV0 = RRESP */

        vth_pfc_sel_arcv1(mod_id, slot, receiver_no, 4);   /* ARCV1 = WERR  */



        sales_start_sequencer(mod_id, slot);



        vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

        vth_mseq_stop(mod_id, TIMEOUT);

        vth_mmbd_rd_arcv0(mod_id);

        if (get_result_nolog(mod_id, &result))

        {

          if (result.UU.Integer_result == 1)

            rresp = true;

          else

            rresp = false;

        }

        if (rresp == expected_response)

        {

          if (guessing)

            gen_delay = cal_max_set + DELAY_INCREMENT;

          else

          {  /*read werr*/

            vth_mmbd_rd_arcv1(mod_id);

            if (get_result_nolog(mod_id, &result))

            {

              if (result.UU.Integer_result == 0)

                edge_found = true;

            }

          }  /*read werr*/

        }



        guessing = false;

        gen_delay -= DELAY_INCREMENT;

        setup_gen_trg_out_delay(mod_id, gen_delay);

      } while (!(edge_found || gen_delay < cal_min_set));

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);

      gen_delay += DELAY_INCREMENT;

      actual_receive = gain[loop] * (gen_delay - cal_min_set) + offset[loop] +

                       channel_delay[receiver - 'A'] + delta_delay;

      ch_result[receiver - 'A'][loop] = actual_receive - expected_receive;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = ch_result[receiver - 'A'][loop];

      if (!edge_found)   /* it never received */

        ch_result[receiver - 'A'][loop] = INT_MAX;

      log_result(mod_id, result);

    }  /* for */

    disable_gen_out(mod_id);

  }  /* for receiver */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for */

    skew = ch_result[receiver - 'A'][NON_INVERTED] - ch_result[receiver - 'A']

           [INVERTED];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /* t9170 */

#undef SLEW_RATE

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_UNTERMINATED

#undef GEN_HIGH_TERMINATED

#undef T0_ACTUAL

#undef RX_SPEC

#undef SLOT_DELAY_NOM

#undef TIMEOUT

#undef STOP_WAIT

#undef DELAY_INCREMENT

#undef PROG_DELAY_

#undef TCLK_ADV_TIME

#undef SYNC_ADV_TIME

#undef SLEW_RATE_DELAY

#undef NON_INVERTED

#undef INVERTED



#define TCLK_FREQ       5.0e+06

#define GEN_LOW_50      0.20e+00

#define GEN_HIGH_50     3.5e+00

#define RX_SPEC         10e-09

#define TIMEOUT         1.0e-03

#define STOP_WAIT       100e-03

#define PROG_DELAY_     20e-09

#define TCLK_ADV_TIME   40e-09

#define RES             1.0e-09

#define STARTING_INCREMENT  2.0e-09



/* static variables for t9171: */

struct LOC_t9171

{

  int mod_id;

  int slot;

  boolean rresp;

  boolean werr;

  boolean dummy;



  int receiver_no;

  double gen_delay;

  test_result_type result;

} ;



static void sample(struct LOC_t9171 *LINK)

{

  /* ------------------------------------------------------------------------ */

  /* Procedure sample sets up the generator delay to the value to be tested,  */

  /* enables the RRESP AND WERR signals onto the ARCV lines, starts and stops */

  /* the sequencer, and sets the return values for WERR and RRESP             */

  /* ------------------------------------------------------------------------ */

  setup_gen_trg_out_delay(LINK->mod_id, LINK->gen_delay);

  enable_gen_out(LINK->mod_id);

  sales_reset_sequencer(LINK->mod_id, LINK->slot);



  vth_pfc_sel_arcv0(LINK->mod_id, LINK->slot, LINK->receiver_no, 3);

      /* 3 = ARCV0 = RRESP */

  vth_pfc_sel_arcv1(LINK->mod_id, LINK->slot, LINK->receiver_no, 4);

      /* 4 = ARCV1 = WERR */



  sales_start_sequencer(LINK->mod_id, LINK->slot);

  vth_mseq_wait_on_stop(LINK->mod_id, STOP_WAIT);

  vth_mseq_stop(LINK->mod_id, TIMEOUT);



  vth_mmbd_rd_arcv1(LINK->mod_id);   /* vth_read WERR */

  LINK->dummy = get_result_nolog(LINK->mod_id, &LINK->result);

      /* get from result log */

  if (LINK->result.UU.Integer_result == 1)   /* WERR occurred */

    LINK->werr = true;

  else

  {  /* no WERR occurred */

    LINK->werr = false;

    vth_mmbd_rd_arcv0(LINK->mod_id);   /* get RRESP */

    LINK->dummy = get_result_nolog(LINK->mod_id, &LINK->result);

        /* get from result log */

    if (LINK->result.UU.Integer_result == 1)

      LINK->rresp = true;

    else

      LINK->rresp = false;

  }  /* no WERR occurred */

}  /* sample */



//------------------------------------------------------------------------------

void t9171(int mod_id, int slot)

{  /* main t9171 */

  /* [PINCARD] RX Edge Accuracy and Skew */



  /* For path and test descriptions, see the documentation for test: 9171 */

  struct LOC_t9171 V;



  int mapped_slot;



  boolean expected_response;

  boolean found;

  boolean hit;

  int direction;



  double t0_actual;

  double delay_inc;

  double expected_receive;

  double actual_receive;

  double min_gen_delay;

  double max_gen_delay;

  double min_gen_meas;

  double max_gen_meas;

  double rx_range;

  double skew;

  double delta_delay;



  double offset[2];

  double gain[2];

  double ch_result['H' + 1 - 'A'][2];



  int mux_node_pin;

  int edge;

  int receiver;



//  FILE *diagfile;   // diagnostic file to check how well the correction for this test works -- mjs

//  diagfile = NULL;



  //mjs 6/97

  double correction;   //correction factor because results of this test are dependent

                       // on the number and type of cards in module



/* the .435ns is the correction factor for 1 single density card.  it was observed from

   Report data that indicated the shift in this test.  it was calculated as follows:



   with 2 DD cards, mean for test was 1.12ns

   with 9 DD cards, mean for test was -4.97ns

   delta mean = 1.12 - -4.97 = 6.09ns

   delta cards = 9-2 = 7

   correction per DD card = 6.09ns / 7 = .87ns

   correction per SD card is thus .87ns /2 = .435ns

   */



//  correction = calc_mod_correction(mod_id, .435e-09);



    correction = calc_mod_correction(mod_id, .217e-09);



//mjs - changed the correction factor down to keep from going out of high end.

//      changed on 6/30 after seeing results for a module of single density cards

/*  diagfile = fopen("diag.mjs", "a");

  fprintf(diagfile, "===============================================\n", mod_id, slot);

  fprintf(diagfile, "TEST 9171/9871         module %2d   slot %2d \n\n", mod_id, slot);

  fprintf(diagfile, "single density correction constant = .2e-09\n");

  fprintf(diagfile, "calculated correction for Module %d is %1.12f\n", mod_id, correction);

*/



  V.mod_id = mod_id;

  V.slot = slot;

  if (V.slot > 11)

    mapped_slot = V.slot - 11;

  else

    mapped_slot = V.slot;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(V.mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(V.mod_id);
	setup_33250A_defaults(V.mod_id);
  }
  else
    open_syn(V.mod_id);
  /*--------------------------------------------*/

  open_gen(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);

  open_cntr(V.mod_id);

  /* t0_actual is different for mac10s and mac11s.  This value is provided by */

  /* AutoCal software.  AutoCal defines this constant as T0_TIME */

//assuming that ACME uses the same autocal constant that mac11 uses -- mjs 6/98

  if ((get_testhead_actual_card(V.mod_id, MAC_SLOT) == CONTROLPLUS) || (get_testhead_actual_card(V.mod_id, MAC_SLOT) == CONTROLXT))

    t0_actual = MAC_11_T0_ACTUAL;

  else

    t0_actual = MAC_10_T0_ACTUAL;



  /* rx_range is the +/- max value we will check to see if a receive occurred */

  rx_range = 2 * RX_SPEC;



  /* delta_delay is the difference between when the generator trig will get */

  /* to CLKRB and when the generator output will get to the receiver mint pin */

  /* The values are:                                                      */

  /*  AF2_system_delay = delay of AF2 cable for module (unique for each system) */

  /*  slot_delay = delay associated with slot differences (slot 2 = 0.0 delay */

  /*  rx_path_offset = AF2 to receiver delay less slot delay and channel delay */

  /*  AF2_CLKRB_delay = sales rack specific constant; diff AF2 to CLKRB delays */

  delta_delay = af2_system_delay[V.mod_id] +

                (slot_delay[mapped_slot - 1][RISING]

                 + slot_delay[mapped_slot - 1][FALLING]) / 2

                 + rx_path_offset - af2_clkrb_delay[V.mod_id];



//  display_it(mod_id, "af2_system_delay = ", 0, af2_system_delay[V.mod_id]);

//  display_it(mod_id, "slot_delay[mapped_slot - 1][RISING]", 0, slot_delay[mapped_slot - 1][RISING]);

//  display_it(mod_id, "slot_delay[mapped_slot - 1][FALLING]", 0, slot_delay[mapped_slot - 1][FALLING]);

//  display_it(mod_id, "rx_path_offset = ", 0, rx_path_offset);

//  display_it(mod_id, "af2_clkrb_delay = ", 0, af2_clkrb_delay[V.mod_id]);



  /* expected_receive is when the receiver strobe should occur at no error */

  /* prog_delay is the delay value that the rx is programmed to in the VML code */

  /* tclk_adv_time is the amount of time we advance the tclk (from CLKRB).  We */

  /*  set(picked) this value such that our receive will occur within the delay */

  /*  range of the generator. */

  expected_receive = t0_actual + PROG_DELAY_ - TCLK_ADV_TIME;



//  display_it(mod_id, "t0_actual = ", 0, t0_actual);

  /* The following section calculates the gain and offset associated with the */

  /* generator delay settings.  These values are used to increase the accuracy */

  /* of the results.  This 2 point calibration assumes the delay is linear.  */



  /* min/max_gen_delay are the values over which the receiver will be checked */

//  display_it(mod_id, "expected_receive = ", 0, expected_receive);

//  display_it(mod_id, "delta_delay = ", 0, delta_delay);

//  display_it(mod_id, "rx_range = ", 0, rx_range);



  min_gen_delay = nanotrunc(expected_receive - delta_delay - rx_range);

  max_gen_delay = nanotrunc(expected_receive - delta_delay + rx_range);



  /* Make the required connections.  The generator is synced to the synthesizer */

  /* to provide a more accurate (less jitter) timebase for the generator. */

  connect_syn_out_gen_ext(V.mod_id);

  connect_gen_trg_cntr_start(V.mod_id);

  connect_gen_out_cntr_stop(V.mod_id);



  setup_gen_levels(V.mod_id, GEN_LOW_50, GEN_HIGH_50);



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* Measure the offset and gain for pos and neg generator output */

    setup_gen_trg_out_delay(V.mod_id, min_gen_delay);

    enable_gen_out(V.mod_id);

    vth_mtmr_wait(V.mod_id, 0.3);

    trigger_cntr(V.mod_id);

    min_gen_meas = read_cntr_mean(V.mod_id);

    setup_gen_trg_out_delay(V.mod_id, max_gen_delay);

    vth_mtmr_wait(V.mod_id, 0.3);

    trigger_cntr(V.mod_id);

    max_gen_meas = read_cntr_mean(V.mod_id);

    disable_gen_out(V.mod_id);

    offset[edge] = min_gen_meas;

    gain[edge] = (max_gen_meas - min_gen_meas) / (max_gen_delay - min_gen_delay);

    complement_gen_out(V.mod_id);

    setup_cntr_trigger_slopes(V.mod_id, POS, NEG);

  }  /* Measure the offset and gain for pos and neg generator output */



  no_complement_gen_out(V.mod_id);

  setup_gen_levels(V.mod_id, GEN_LOW_50, GEN_HIGH_50);



  connect_gen_trg_clkrb(V.mod_id);

  connect_gen_out_af2(V.mod_id);



  vth_mclose_rly(V.mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(V.mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(V.mod_id, K753);   /* XL to AF2 path relay */

  vth_aclose_rly(V.mod_id, K764);   /* XL to AF2 path relay */



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for */

    vth_pclose_rly(V.mod_id, V.slot, PIN_KR_RLYS[receiver - 'A']);

    switch (receiver)

    {   /*Use mux_node_pins closest to the grounds*/



    case 'A':

    case 'B':

    case 'E':

    case 'F':

      mux_node_pin = 7;

      break;



    case 'C':

    case 'D':

    case 'G':

    case 'H':

      mux_node_pin = 0;

      break;

    default:

      assert(false);

      break;



    }/* case */

    vth_pclose_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux_node_pin][receiver - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux_node_pin + 1]

               [receiver - 'A']);

  }  /* for */



  close_pin_gnd_relays(V.mod_id, V.slot);

      /*ground all termination resistors */

  vth_pclose_rly(V.mod_id, V.slot, KDCL);



  /* Set up the TCLK generator to sync to the external CLKRB (gen trig) signal */

  vth_mtclk_clkrb_mux(V.mod_id);

  vth_mtclk_sel_ris_edge(V.mod_id);

  vth_mtclk_set_freq(V.mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(V.mod_id, TCLK_ADV_TIME);



  /* Enable the ARCV lines from pin to mother card and from mother card to mac */

  vth_pen_arcv0(V.mod_id, V.slot);

  vth_pen_arcv1(V.mod_id, V.slot);

  vth_mmbd_en_arcv(V.mod_id);



#include "t9170_vml.cmd"



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for edge */

    if (edge == RISING)

    {  /* then */

      no_complement_gen_out(V.mod_id);   /* Use at the rising edge */

      expected_response = true;

    }  /* then */

    else

    {  /* else */

      complement_gen_out(V.mod_id);   /* Use at the falling edge */

      expected_response = false;

    }  /* else */



    /* Recalculate delta_delay for the particular edge that we are testing */

    delta_delay = af2_system_delay[V.mod_id] + slot_delay[mapped_slot - 1]

                  [edge] + rx_path_offset - af2_clkrb_delay[V.mod_id];



    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /* for receiver */

      V.receiver_no = receiver - 'A';



      /* Two kgl relays are closed for each receiver.  This effectively puts */

      /* two 100 ohm load resistors in parallel to simulate a 50 ohm load. */

      vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A']);

      switch (receiver)

      {   /*Use mux_node_pins closest to the grounds*/



      case 'A':

      case 'C':

      case 'E':

      case 'G':

        vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A' + 1]);

        break;



      case 'B':

      case 'D':

      case 'F':

      case 'H':

        vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A' - 1]);

        break;

      default:

        assert(false);

        break;



      }/* case */



      delay_inc = STARTING_INCREMENT;

      direction = 0;

      hit = false;

      found = false;

      V.gen_delay = nanotrunc(expected_receive - delta_delay + 1e-09);



      do

      {



        sample(&V);   /* Sample sets the value of WERR and RRESP */



        /* If a WERR occurs, the current gen delay is the closest tested */

        /* value of gen delay to rx strobe */

        if (V.werr)

          found = true;

        else

        {  /* Do the non-window error procedure */

          /* Determine if 'hit' and set the direction of delay based on rresp */

          if (V.rresp == expected_response)

          {  /* increase the delay */

            if (direction < 0)   /* can never hit on first point */

              hit = true;

            direction = 1;   /* set direction to increase delay */

          }  /* increase the delay */

          else

          {  /* decrease the delay */

            if (direction > 0)   /* can never hit on first point */

              hit = true;

            direction = -1;   /* set direction to decrease delay */

          }  /* decrease the delay */



          /* Each time a 'hit' occurs, cut the delay increment in half. 'found' */

          /* will only be set true when a 'hit' occurs at the 'res'(resolution) */

          /* value of generator delay. */

          if (hit)

          {

            if (delay_inc <= RES)

              found = true;

            delay_inc /= 2;

          }



          /* On the final 'hit' value of gen delay, the gen delay value will */

          /* be adjusted by 1/2 the 'res' value in the proper direction to */

          /* effectively average the RRESP=0 and RRESP=1 values.  The rx strobe */

          /* occurred somewhere between the RRESP=0 and RRESP=1. */

          V.gen_delay += delay_inc * direction;



        }  /* Do the non-window error procedure */



      } while (!(found || V.gen_delay < min_gen_delay ||

                 V.gen_delay > max_gen_delay));



      disable_gen_out(V.mod_id);



      vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A']);

      switch (receiver)

      {   /*Use mux_node_pins closest to the grounds*/



      case 'A':

      case 'C':

      case 'E':

      case 'G':

        vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A' + 1]);

        break;



      case 'B':

      case 'D':

      case 'F':

      case 'H':

        vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[receiver - 'A' - 1]);

        break;

      default:

        assert(false);

        break;



      }/* case */



      /* calculate the actual receive, correct for gen error and channel delay */

      actual_receive = gain[edge] * (V.gen_delay - min_gen_delay) +

          offset[edge] + channel_delay[receiver - 'A'] + delta_delay;



      ch_result[receiver - 'A'][edge] = actual_receive - expected_receive;

      V.result.Measurement_class = CLASS_REAL;

      if (!found)

      {   /* it never received */

        display_prompt("**RECEIVE DOES NOT OCCUR WITHIN TEST RANGE**", true);

        ch_result[receiver - 'A'][edge] = INT_MAX;

      }





      //added the correction factor to test to correct for module configuration

      //see calculations above at top of test

      //mjs - 6/97

      V.result.UU.Real_result = ch_result[receiver - 'A'][edge] + correction;

      log_result(V.mod_id, V.result);



/*      if ((V.result.UU.Real_result - correction) <= -10e-09) //helped these subtests

      fprintf(diagfile, "+  before correction: %1.12f  after correction: %1.12f\n", (V.result.UU.Real_result - correction), V.result.UU.Real_result);

      if ((V.result.UU.Real_result) >= 10e-09) //hurt these subtests

      fprintf(diagfile, "-  before correction: %1.12f  after correction: %1.12f\n", (V.result.UU.Real_result - correction), V.result.UU.Real_result);

*/



    }  /* for receiver */

  }  /* for edge */



  /* Now log the rising to falling skew for each of the receivers */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for */

    skew = ch_result[receiver - 'A'][RISING] - ch_result[receiver - 'A'][FALLING];



/*    if ((skew <= -5e-09) || (skew >= 5e-09))  // +/- 5ns are the limits for the skew subtests

    {//had a failure so lets see if any of the results are out of line

      fprintf(diagfile, "=== Skew failure on chan %d =  %-+12.12e\n", receiver, skew);

      fprintf(diagfile, "    ch_result[receiver - 'A'][RISING] = %-+12.12e\n", ch_result[receiver - 'A'][RISING]);

      fprintf(diagfile, "    ch_result[receiver - 'A'][FALLING] = %-+12.12e\n", ch_result[receiver - 'A'][FALLING]);

      }*/



    V.result.UU.Real_result = skew;

    log_result(V.mod_id, V.result);

  }  /* for */


//  fclose(diagfile);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(V.mod_id);
  else
    close_syn(V.mod_id);
  /*--------------------------------------------*/

  close_gen(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);

  close_cntr(V.mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /* main t9171 */

#undef TCLK_FREQ

#undef GEN_LOW_50

#undef GEN_HIGH_50

#undef RX_SPEC

#undef TIMEOUT

#undef STOP_WAIT

#undef PROG_DELAY_

#undef TCLK_ADV_TIME

#undef RES

#undef STARTING_INCREMENT

typedef int delay_type__;

typedef int slew_type;

typedef double delay_array_[2];

typedef double slew_array[3];

typedef int side_type;



#define TCLK_FREQ       5.0e+06

#define GEN_LOW         0.0e+00

#define GEN_HIGH_TERMINATED  3.0e+00

/* system actual t0 value */

#define T0_ACTUAL       165.9e-9

#define TIMEOUT         1.0e-03

const delay_array_ GEN_DELAY_ = {150e-09, 250e-09};

const delay_array_ PROG_DELAY_ = {0e-09, 100e-09};

const slew_array THI_R = {1.5, 1.6, 1.4};

const slew_array TLO_R = {1.3, 1.4, 1.1};

const slew_array THI_F = {1.8, 2.0, 2.0};

const slew_array TLO_F = {1.6, 1.6, 1.8};

#define DGN_INFINITY    1e31

//------------------------------------------------------------------------------

void t9172(int mod_id, int slot)

{

  /*DRIVER EDGE PLACEMENT SLEW AND SKEW*/

  delay_type__ offset_cal;

  delay_type__ programmed_delays;

  slew_type slew;

  side_type side;

  int edge;



  double thi;

  double tlo;

  double position;

  double skew;

  double slew_rate;



  double offset[2];

  double raw[4][3]['H' + 1 - 'A'][2];



  int slope;

  test_result_type result;

  int driver;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  setup_gen_levels(mod_id, GEN_LOW, GEN_HIGH_TERMINATED);



  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);



  for (offset_cal = 0; offset_cal <= 1; offset_cal++)

  {  /*offset_cal*/

    setup_gen_trg_out_delay(mod_id, GEN_DELAY_[offset_cal]);

    enable_gen_out(mod_id);

    trigger_cntr(mod_id);

    offset[offset_cal] = read_cntr_mean(mod_id);

    /* the following line was added for delays > 1 tclk period. ABA */

    offset[offset_cal] += static_cast<int>(GEN_DELAY_[offset_cal] * TCLK_FREQ) / TCLK_FREQ;

    disable_gen_out(mod_id);

  }  /*offset_cal*/



  connect_gen_trg_clkrb(mod_id);

  connect_cntr_start_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);   /* XL to AF2 path */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  for (driver = 'A'; driver <= 'H'; driver++)

  {  /* for */

    vth_pclose_rly(mod_id, slot, PIN_KD_RLYS[driver - 'A']);

  }  /* for */

  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, T0_ACTUAL);



  /* measure slew rates at 0ns */



  programmed_delays = 1;

  setup_gen_trg_out_delay(mod_id, GEN_DELAY_[programmed_delays - 1]);



  for (slope = POS; slope >= NEG; --slope)

  {  /*for slope*/

    setup_cntr_trigger_slopes(mod_id, slope, POS);



    for (slew = 2; slew >= 0; slew--)

    {  /* for slew */

      if (slope == POS)

      {

        thi = THI_R[slew];

        tlo = TLO_R[slew];

        edge = RISING;

      }

      else

      {

        thi = THI_F[slew];

        tlo = TLO_F[slew];

        edge = FALLING;

      }

      switch (slew + 1)

      {



      case 1:

#include "t9172_d0s1.cmd"

        break;



      case 2:

#include "t9172_d0s2.cmd"

        break;



      case 3:

#include "t9172_d0s3.cmd"

        break;



      default:

        assert(false);

        break;



      }/* case slew_type */



      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        enable_gen_out(mod_id);

        sales_reset_sequencer(mod_id, slot);

        vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

        sales_start_sequencer(mod_id, slot);



        for (side = 1; side <= 2; side++)

        {  /* for side */

          if (side == 1 && slope == POS)   /* begin slew */

            setup_cntr_trg_levels(mod_id, tlo, 1.5);

          if (side == 2 && slope == POS)   /* end slew */

            setup_cntr_trg_levels(mod_id, thi, 1.5);

          if (side == 1 && slope == NEG)   /* begin down slew */

            setup_cntr_trg_levels(mod_id, thi, 1.5);

          if (side == 2 && slope == NEG)   /* end down slew */

            setup_cntr_trg_levels(mod_id, tlo, 1.5);



          trigger_cntr(mod_id);

          raw[slope][slew][driver - 'A'][side - 1] = read_cntr_mean(mod_id);



        }  /* for side */



        /*log position for highest slew rate*/

        if (slew + 1 == 3)

        {

          if (slope == POS)   /* extrapolate 1.1v crossing*/

            position = (raw[slope][slew][driver - 'A'][1] * (1.1 - tlo) + raw[slope]

                          [slew][driver - 'A']

                          [0] * (thi - 1.1)) / (thi - tlo);

          else  /* extrapolate 1.9v crossing*/

            position = (raw[slope][slew][driver - 'A'][1] * (1.9 - tlo) + raw[slope]

                          [slew][driver - 'A']

                          [0] * (thi - 1.9)) / (thi - tlo);



          position = offset[programmed_delays - 1] + clkrb_delay[mod_id] -

                     position - af2_start_delay[mod_id] -

                     af2_system_delay[mod_id] - slot_delay[slot - 1]

                     [edge] - channel_delay[driver - 'A'] -

                     PROG_DELAY_[programmed_delays - 1];

          result.Measurement_class = CLASS_REAL;

          result.UU.Real_result = position;

          log_result(mod_id, result);

        }



        vth_mseq_stop(mod_id, TIMEOUT);

        disable_gen_out(mod_id);

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);



      }  /* for driver */



      /*log slew rate*/

      for (driver = 'A'; driver <= 'H'; driver++)

      {  /* for driver */

        position = raw[slope][slew][driver - 'A'][0] - raw[slope][slew]

                   [driver - 'A'][1];

        if (position == 0)

          slew_rate = DGN_INFINITY;

        else

          slew_rate = fabs((thi - tlo) / position) / 1.0e+06;

        result.UU.Real_result = slew_rate;

        log_result(mod_id, result);

      }  /* for driver */



    }  /* for slew */



  }  /* for slope */



  /*log values of skew for highest slew rate*/

  for (driver = 'A'; driver <= 'H'; driver++)

  {

    /*extrapolate 1.1v crossing*/

    skew = (raw[POS][2][driver - 'A'][1] * (1.1 - TLO_R[2]) - raw[POS][2]

              [driver - 'A'][0] * (1.1 - THI_R[2])) / (THI_R[2] - TLO_R[2]) -

           (raw[NEG][2][driver - 'A'][1] * (1.9 - TLO_F[2]) - raw[NEG][2]

              [driver - 'A'][0] * (1.9 - THI_F[2])) / (THI_F[2] - TLO_F[2]);

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }





  /* log position for 100ns delay*/

  programmed_delays = 2;

  setup_gen_trg_out_delay(mod_id, GEN_DELAY_[programmed_delays - 1]);

  setup_cntr_trg_levels(mod_id, 1.5, 1.5);



#include "t9172_d1s3.cmd"



  for (slope = POS; slope >= NEG; --slope)

  {  /*for slope*/

    setup_cntr_trigger_slopes(mod_id, slope, POS);

    if (slope == POS)

      edge = RISING;

    else

      edge = FALLING;



    for (driver = 'A'; driver <= 'H'; driver++)

    {  /* for driver */

      enable_gen_out(mod_id);

      sales_reset_sequencer(mod_id, slot);

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[driver - 'A']);

      sales_start_sequencer(mod_id, slot);

      trigger_cntr(mod_id);

      raw[slope][2][driver - 'A'][0] = read_cntr_mean(mod_id);

      position = offset[programmed_delays - 1] + clkrb_delay[mod_id] - raw[slope]

                 [2][driver - 'A']

                 [0] - af2_start_delay[mod_id] - af2_system_delay[mod_id] -

                 slot_delay[slot - 1][edge] - channel_delay[driver - 'A'] -

                 PROG_DELAY_[programmed_delays - 1];

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = position;

      log_result(mod_id, result);

    }  /* for driver */

  }  /* for slope */

  /*log values of skew for 100ns delay*/

  for (driver = 'A'; driver <= 'H'; driver++)

  {

    skew = raw[POS][2][driver - 'A'][0] - raw[NEG][2][driver - 'A'][0];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }

  vth_pinit(mod_id, slot);

  vth_minit(mod_id);

  vth_ainit(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011

}  /*t9172*/

#undef TCLK_FREQ

#undef GEN_LOW

#undef GEN_HIGH_TERMINATED

#undef T0_ACTUAL

#undef TIMEOUT

#undef DGN_INFINITY



#define TCLK_FREQ       5.0e+06

#define GEN_LOW_50      0.20e+00

#define GEN_HIGH_50     3.5e+00

/* Autocal delay setting */

#define T0_ACTUAL       160e-09

#define RX_SPEC         10e-09

#define TIMEOUT         1.0e-03

#define STOP_WAIT       100e-03

#define DELAY_INCREMENT  1.0e-09

#define PROG_DELAY__    20e-09

#define TCLK_ADV_TIME   40e-09

#define SYNC_ADV_TIME   5.9e-09

//------------------------------------------------------------------------------

/* temporary version of 9171 that eliminates unwanted pathes */

void t9173(int mod_id, int slot)

{

  /*Receiver Edge Accuracy and Skew*/

  int mux_node_pin;

  int receiver_no;



  double gen_delay;

  double expected_receive;

  double actual_receive;

  double cal_min_set;

  double cal_max_set;

  double cal_min_actual;

  double cal_max_actual;

  double rx_range;

  double skew;

  double delta_delay;

  double guessed_value;



  double offset[2];

  double gain[2];

  double ch_result['H' + 1 - 'A'][2];



  boolean expected_response;

  boolean edge_found;

  boolean rresp;

  boolean werr;

  boolean guessing;



  int edge;

  test_result_type result;

  int receiver;

  int off_chan;



  rx_range = 2 * RX_SPEC;

  delta_delay = af2_system_delay[mod_id] + (slot_delay[slot - 1]

                    [RISING] + slot_delay[slot - 1]

                    [FALLING]) / 2 + rx_path_offset - af2_clkrb_delay[mod_id];

  expected_receive = T0_ACTUAL + PROG_DELAY__ - TCLK_ADV_TIME;

  cal_min_set = expected_receive - delta_delay - rx_range;

  cal_min_set = (int)cal_min_set / 1e9;

  cal_max_set = expected_receive - delta_delay + rx_range;

  cal_max_set = (int)cal_max_set / 1e9;

  guessed_value = expected_receive - delta_delay + 5e-09;

  guessed_value = (int)guessed_value / 1e9;

  OpenResourceManager(); //added by chuanho, 18jul2011

  open_33250A(mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(mod_id);
	setup_33250A_defaults(mod_id);
  }
  else
    open_syn(mod_id);
  /*--------------------------------------------*/

  open_gen(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_cntr(mod_id);

  connect_syn_out_gen_ext(mod_id);

  connect_gen_trg_cntr_start(mod_id);

  connect_gen_out_cntr_stop(mod_id);

  setup_gen_levels(mod_id, GEN_LOW_50, GEN_HIGH_50);



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* Measure the offset and gain for pos and neg generator output */

    setup_gen_trg_out_delay(mod_id, cal_min_set);

    enable_gen_out(mod_id);

    vth_mtmr_wait(mod_id, 0.3);

    trigger_cntr(mod_id);

    cal_min_actual = read_cntr_mean(mod_id);

    setup_gen_trg_out_delay(mod_id, cal_max_set);

    vth_mtmr_wait(mod_id, 0.3);

    trigger_cntr(mod_id);

    cal_max_actual = read_cntr_mean(mod_id);

    disable_gen_out(mod_id);



    offset[edge] = cal_min_actual;

    gain[edge] = (cal_max_actual - cal_min_actual) / (cal_max_set - cal_min_set);



    complement_gen_out(mod_id);

    setup_cntr_trigger_slopes(mod_id, POS, NEG);



  }  /* Measure the offset and gain for pos and neg generator output */





  no_complement_gen_out(mod_id);

  setup_gen_levels(mod_id, GEN_LOW_50, GEN_HIGH_50);

  close_pin_gnd_relays(mod_id, slot);

  connect_gen_trg_clkrb(mod_id);

  connect_gen_out_af2(mod_id);



  vth_mclose_rly(mod_id, MK2902);   /* clkrb path relay */

  vth_mclose_rly(mod_id, MK2903);   /* clkrsg path relay */

  vth_aclose_rly(mod_id, K753);

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 path */



  vth_pclose_rly(mod_id, slot, KDCL);



  vth_mtclk_clkrb_mux(mod_id);

  vth_mtclk_sel_ris_edge(mod_id);

  vth_mtclk_set_freq(mod_id, TCLK_FREQ, TCLK_FREQ);

  vth_mtclk_set_adv_time(mod_id, TCLK_ADV_TIME + SYNC_ADV_TIME);



  vth_mmbd_en_arcv(mod_id);

  vth_pen_arcv0(mod_id, slot);

  vth_pen_arcv1(mod_id, slot);



  for (edge = RISING; edge <= FALLING; ++edge)

  {  /* for */

    if (edge == RISING)

    {  /* then */

      no_complement_gen_out(mod_id);

      expected_response = true;

    }  /* then */

    else

    {  /* else */

      complement_gen_out(mod_id);

      expected_response = false;

    }  /* else */

    delta_delay = af2_system_delay[mod_id] + slot_delay[slot - 1]

                  [edge] + rx_path_offset - af2_clkrb_delay[mod_id];

    for (receiver = 'A'; receiver <= 'H'; receiver++)

    {  /* for receiver */

      vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

      switch (receiver)

      {   /*Use mux_node_pins closest to the grounds*/



      case 'A':

        mux_node_pin = 7;

        off_chan = 'B';

        break;



      case 'B':

        mux_node_pin = 7;

        off_chan = 'A';

        break;



      case 'C':

        mux_node_pin = 0;

        off_chan = 'D';

        break;



      case 'D':

        mux_node_pin = 0;

        off_chan = 'C';

        break;



      case 'E':

        mux_node_pin = 7;

        off_chan = 'F';

        break;



      case 'F':

        mux_node_pin = 7;

        off_chan = 'E';

        break;



      case 'G':

        mux_node_pin = 0;

        off_chan = 'H';

        break;



      case 'H':

        mux_node_pin = 0;

        off_chan = 'G';

        break;

      default:

        assert(false);

        break;



      }/* case */

      vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][receiver - 'A']);

      vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][off_chan - 'A']);

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1]

                 [receiver - 'A']);



      receiver_no = receiver - 'A';

      vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);



      /* The next 4 lines put two 100 ohm loads in parallel to create     */

      /* the desired 50 ohm load. Channels AB, CD, EF, and GH are paired. */

      if ((receiver & 1) > 0)

        vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A' + 1]);

      else

        vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A' - 1]);



      gen_delay = guessed_value;

      guessing = true;

      setup_gen_trg_out_delay(mod_id, gen_delay);

      enable_gen_out(mod_id);

      edge_found = false;

      werr = true;

      do

      {

        sales_reset_sequencer(mod_id, slot);



#include "t9170_vml.cmd"

        vth_pfc_sel_arcv0(mod_id, slot, receiver_no, 3);   /* ARCV0 = RRESP */

        vth_pfc_sel_arcv1(mod_id, slot, receiver_no, 4);   /* ARCV1 = WERR  */



        sales_start_sequencer(mod_id, slot);



        vth_mseq_wait_on_stop(mod_id, STOP_WAIT);

        vth_mseq_stop(mod_id, TIMEOUT);

        vth_mmbd_rd_arcv0(mod_id);

        if (get_result_nolog(mod_id, &result))

        {

          if (result.UU.Integer_result == 1)

            rresp = true;

          else

            rresp = false;

        }

        if (rresp == expected_response)

        {

          if (guessing)

            gen_delay = cal_max_set + DELAY_INCREMENT;

          else

          {  /*read werr*/

            vth_mmbd_rd_arcv1(mod_id);

            if (get_result_nolog(mod_id, &result))

            {

              if (result.UU.Integer_result == 0)

                edge_found = true;

            }

          }  /*read werr*/

        }



        guessing = false;

        gen_delay -= DELAY_INCREMENT;

        setup_gen_trg_out_delay(mod_id, gen_delay);

      } while (!(edge_found || gen_delay < cal_min_set));

      vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);

      if ((receiver & 1) > 0)

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A' + 1]);

      else

        vth_popen_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A' - 1]);

      vth_popen_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

      vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][receiver - 'A']);

      vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[mux_node_pin][off_chan - 'A']);

      vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][receiver - 'A']);

      gen_delay += DELAY_INCREMENT;

      actual_receive = gain[edge] * (gen_delay - cal_min_set) + offset[edge] +

                       channel_delay[receiver - 'A'] + delta_delay;

      ch_result[receiver - 'A'][edge] = actual_receive - expected_receive;

      result.Measurement_class = CLASS_REAL;



      /* DATA IS INVALID IF THE EXPECTED RESPONSE HAS OCCURRED AT THE MAX */

      /* CAL POINT (- one delay_increment because of the test structure.) */

      if ( number_equal(gen_delay, cal_max_set - DELAY_INCREMENT) )

        edge_found = false;



      if (!edge_found)   /* it never received */

      {  /*edge_not_found*/

        ch_result[receiver - 'A'][edge] = INT_MAX;

        display_prompt("*** Edge not found for this channel ***", true);

        display_prompt("*********** Data is not valid *********", true);

      }  /*edge_not_found*/

      result.UU.Real_result = ch_result[receiver - 'A'][edge];

      log_result(mod_id, result);

    }  /* for */

    disable_gen_out(mod_id);

  }  /* for receiver */

  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /* for */

    skew = ch_result[receiver - 'A'][RISING] - ch_result[receiver - 'A']

           [FALLING];

    result.UU.Real_result = skew;

    log_result(mod_id, result);

  }  /* for */

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(mod_id);
  else
    close_syn(mod_id);
  /*--------------------------------------------*/

  close_gen(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);

  close_cntr(mod_id);

  CloseResourceManager(); //added by chuanho, 18jul2011


}  /* t9173 */

#undef TCLK_FREQ

#undef GEN_LOW_50

#undef GEN_HIGH_50

#undef T0_ACTUAL

#undef RX_SPEC

#undef TIMEOUT

#undef STOP_WAIT

#undef DELAY_INCREMENT

#undef PROG_DELAY__

#undef TCLK_ADV_TIME

#undef SYNC_ADV_TIME



#define OSC_CHANNEL     1

#define COUNT           5

#define MUX_NODE_PIN    3

#define COUPLING        1000000

#define CHANNEL_RANGE   10.0e+00

#define CHANNEL_OFFSET  4.0e+00

#define TRIGGER_LEVEL   2.0e+00

#define TIMEBASE_RANGE  20e-03

#define TIMEBASE_OFFSET  5.0e-03

#define TRIGGER_WAIT_TIME  1.0e+00

#define MEASURE_WAIT_TIME  200e-03

#define SOURCE_VOLTAGE  7.0e+00

#define AVERAGING       false

#define TIMEBASE_MODE   SINGLE

#define OSC_FUNCTION    WIDTH

/*   Which edge to measure?    */

#define EDGE            POS

//------------------------------------------------------------------------------

void t9180(int mod_id, int slot)

{

  /* RECEIVER OVER VOLTAGE LIMIT PROTECTION */

  test_result_type result;

  int receiver;



  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  connect_osc_ch1_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K806);   /* Aim source to S bus */

  for (receiver = 'A'; receiver <= 'H'; receiver++)   /* S bus to Xn busses */

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);



  vth_afc_en_src_out(mod_id);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);   /* Wait for the scope */



    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /* Xn connect relay */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /* Xn to receiver relay */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /* Receiver connect relay */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);

        /* Receiver to XGL relay */

    vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */



    vth_asrc_set_dc_ampl(mod_id, SOURCE_VOLTAGE);

    vth_mtmr_wait(mod_id, 0.100);

    vth_asrc_set_dc_ampl(mod_id, 0.0);



    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

    measure_osc(mod_id, OSC_FUNCTION, EDGE);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);



    vth_pinit(mod_id, slot);



  }  /*for receiver*/







  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9180*/

#undef OSC_CHANNEL

#undef COUNT

#undef MUX_NODE_PIN

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TRIGGER_WAIT_TIME

#undef MEASURE_WAIT_TIME

#undef SOURCE_VOLTAGE

#undef AVERAGING

#undef TIMEBASE_MODE

#undef OSC_FUNCTION

#undef EDGE



#define OSC_CHANNEL     1

#define COUNT           5

#define MUX_NODE_PIN    3

#define COUPLING        1000000

#define CHANNEL_RANGE   8.0e+00

#define CHANNEL_OFFSET  (-3.5e+00)

#define TRIGGER_LEVEL   (-2.0e+00)

#define TIMEBASE_RANGE  20e-03

#define TIMEBASE_OFFSET  5.0e-03

#define TRIGGER_WAIT_TIME  1.0e+00

#define MEASURE_WAIT_TIME  200e-03

#define SOURCE_VOLTAGE  (-5.0e+00)

#define AVERAGING       false

#define TIMEBASE_MODE   SINGLE

#define OSC_FUNCTION    WIDTH

/*   Which edge to measure?    */

#define EDGE            NEG

//------------------------------------------------------------------------------

void t9181(int mod_id, int slot)

{

  /* RECEIVER UNDER VOLTAGE LIMIT PROTECTION */

  test_result_type result;

int receiver;







  open_osc(mod_id);

  //open_mux(mod_id);
  open_34980A(mod_id);



  setup_osc_channel(mod_id, OSC_CHANNEL, COUPLING, CHANNEL_RANGE,

                    CHANNEL_OFFSET);

  setup_osc_trigger(mod_id, OSC_CHANNEL, EDGE, TRIGGER_LEVEL, AVERAGING);

  setup_osc_timebase(mod_id, AVERAGING, COUNT, TIMEBASE_RANGE,

                     TIMEBASE_OFFSET, TIMEBASE_MODE);



  connect_osc_ch1_af2(mod_id);



  vth_aclose_rly(mod_id, K753);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K764);   /* XL to AF2 relay  */

  vth_aclose_rly(mod_id, K806);   /* Aim source to S bus */



  for (receiver = 'A'; receiver <= 'H'; receiver++)   /* S bus to Xn busses */

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[receiver - 'A']);



  vth_afc_en_src_out(mod_id);



  for (receiver = 'A'; receiver <= 'H'; receiver++)

  {  /*for receiver*/

    trigger_osc(mod_id, OSC_CHANNEL, AVERAGING);

    vth_mtmr_wait(mod_id, TRIGGER_WAIT_TIME);   /* Wait for the scope */



    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[receiver - 'A']);

        /* Xn connect relay */

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[receiver - 'A']);

        /* Xn to receiver relay */

    vth_pclose_rly(mod_id, slot, PIN_KR_RLYS[receiver - 'A']);

        /* Receiver connect relay */

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][receiver - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[receiver - 'A']);

        /* Receiver to XGL relay */

    vth_pclose_rly(mod_id, slot, KDCL);   /* XL common relay  */



    vth_asrc_set_dc_ampl(mod_id, SOURCE_VOLTAGE);

    vth_mtmr_wait(mod_id, 0.100);

    vth_asrc_set_dc_ampl(mod_id, 0.0);



    vth_mtmr_wait(mod_id, MEASURE_WAIT_TIME);

    measure_osc(mod_id, OSC_FUNCTION, EDGE);

    if (!get_result_log(mod_id, &result))

      display_prompt("No result in result log (Expected pulse width)", true);



    vth_pinit(mod_id, slot);



  }  /*for receiver*/







  vth_ainit(mod_id);



  close_osc(mod_id);

  close_34980A(mod_id);//close_mux(mod_id);



}  /*t9181*/

#undef OSC_CHANNEL

#undef COUNT

#undef MUX_NODE_PIN

#undef COUPLING

#undef CHANNEL_RANGE

#undef CHANNEL_OFFSET

#undef TRIGGER_LEVEL

#undef TIMEBASE_RANGE

#undef TIMEBASE_OFFSET

#undef TRIGGER_WAIT_TIME

#undef MEASURE_WAIT_TIME

#undef SOURCE_VOLTAGE

#undef AVERAGING

#undef TIMEBASE_MODE

#undef OSC_FUNCTION

#undef EDGE



#define RANGE           5

#define MUX_NODE_PIN    2

#define RESOLUTION      1.000e-03

#define MIN_TEST_VOLTAGE  5.500e+00

#define MAX_TEST_VOLTAGE  10.200e+00

#define FINEST_INCREMENT  1.000e-03

#define STARTING_INCREMENT  512e-03

#define DMM_FUNCTION    DCV



/* static variables for t9182: */

struct LOC_t9182

{

  int mod_id;

  int slot;

  int receiver;

};



static void close_the_relays___(struct LOC_t9182 *LINK)

{

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KDC_RLYS[LINK->receiver - 'A']);

      /* Xn connect relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KX_RLYS[LINK->receiver - 'A']);

      /* Xn to receiver relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

             [LINK->receiver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KR_RLYS[LINK->receiver - 'A']);

      /* receiver connect relay */

}



//------------------------------------------------------------------------------

void t9182(int mod_id, int slot)

{

  /* [PINCARD] RX POSITIVE OV LIMIT ACCURACY */



  /* For path and test descriptions, see the documentation for test: 9182 */

  struct LOC_t9182 V;

  double voltage_increment;

  double actual_voltage;

  double source_voltage;



  boolean v_limit_occurred;



  a_word_type this_word;

  test_result_type result;







  V.mod_id = mod_id;

  V.slot = slot;
  OpenResourceManager();

  open_dmm(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);


  setup_dmm(V.mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(V.mod_id, V.slot);

  vth_aclose_rly(V.mod_id, K806);   /* Aim source to S bus */



  for (V.receiver = 'A'; V.receiver <= 'H'; V.receiver++)

        /* S bus to Xn busses */

          vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.receiver - 'A']);



  vth_afc_en_src_out(V.mod_id);



  for (V.receiver = 'A'; V.receiver <= 'H'; V.receiver++)

  {  /*for receiver*/

    vth_asrc_set_dc_ampl(V.mod_id, MIN_TEST_VOLTAGE);

    vth_pinit(V.mod_id, V.slot);



    source_voltage = MIN_TEST_VOLTAGE;

    voltage_increment = STARTING_INCREMENT;

    v_limit_occurred = false;

    close_the_relays___(&V);

    while (!v_limit_occurred && source_voltage <= MAX_TEST_VOLTAGE)

    {  /*search for limit level*/

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_mtmr_wait(V.mod_id, 0.050);

      vth_prd_stat(V.mod_id, V.slot);

      if (!get_result_nolog(V.mod_id, &result))

      {  /*process the result*/

        display_prompt("No result in result log (Expected dig stat)", true);

        continue;

      }  /*process the result*/



      this_word.data = result.UU.Integer_result;

//mjs - changed bit number from 10 to 5

      if (P_getbits_US(this_word.bits, 5, 0) != 0)

      {  /* limit_occurred */

        source_voltage += voltage_increment;

        continue;

      }  /* limit_occurred */

      v_limit_occurred = true;

      if (voltage_increment <= FINEST_INCREMENT)

        continue;

      v_limit_occurred = false;

      source_voltage -= voltage_increment;

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_the_relays___(&V);

      voltage_increment /= 2;

    }  /*search for limit level*/



    if (!v_limit_occurred)

      actual_voltage = INT_MAX;

    else

    {  /*measure the acutal voltage*/

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_pin_gnd_relays(V.mod_id, V.slot);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.receiver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.receiver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

                 [V.receiver - 'A']);

      measure_dmm(V.mod_id);

      if (get_result_nolog(V.mod_id, &result))

        actual_voltage = result.UU.Real_result;

      else

        display_prompt("No result in result log (Expected dmm reading)", true);

    }  /*measure the acutal voltage*/



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_voltage;

    log_result(V.mod_id, result);



  }  /*for receiver*/







  vth_ainit(V.mod_id);



  close_dmm(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);
  CloseResourceManager();



}  /*t9182*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef MIN_TEST_VOLTAGE

#undef MAX_TEST_VOLTAGE

#undef FINEST_INCREMENT

#undef STARTING_INCREMENT

#undef DMM_FUNCTION



#define RANGE           5

#define MUX_NODE_PIN    2

#define RESOLUTION      1.0e-03

#define MIN_TEST_VOLTAGE  (-4.0e+00)

#define MAX_TEST_VOLTAGE  (-7.0e+00)

#define FINEST_INCREMENT  1.00e-03

#define STARTING_INCREMENT  512e-03

#define DMM_FUNCTION    DCV



/* static variables for t9183: */

struct LOC_t9183

{

  int mod_id;

  int slot;

  int receiver;

};



static void close_the_relays____(struct LOC_t9183 *LINK)

{

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KDC_RLYS[LINK->receiver - 'A']);

      /* Xn connect relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KX_RLYS[LINK->receiver - 'A']);

      /* Xn to receiver relay */

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

             [LINK->receiver - 'A']);

  vth_pclose_rly(LINK->mod_id, LINK->slot, PIN_KR_RLYS[LINK->receiver - 'A']);

      /* receiver connect relay */

}



//------------------------------------------------------------------------------

void t9183(int mod_id, int slot)

{

  /* [PINCARD] RX NEGATIVE OV LIMIT ACCURACY */



  /* For path and test descriptions, see the documentation for test: 9182 */

  struct LOC_t9183 V;

  double voltage_increment;

  double actual_voltage;

  double source_voltage;



  boolean v_limit_occurred;



  a_word_type this_word;

  test_result_type result;







  V.mod_id = mod_id;

  V.slot = slot;

  open_dmm(V.mod_id);

  //open_mux(V.mod_id);
  open_34980A(V.mod_id);


  setup_dmm(V.mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);



  connect_dmm_pin(V.mod_id, V.slot);

  vth_aclose_rly(V.mod_id, K806);   /* Aim source to S bus */



  for (V.receiver = 'A'; V.receiver <= 'H'; V.receiver++)

        /* S bus to Xn busses */

          vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.receiver - 'A']);



  vth_afc_en_src_out(V.mod_id);



  for (V.receiver = 'A'; V.receiver <= 'H'; V.receiver++)

  {  /*for receiver*/

    vth_asrc_set_dc_ampl(V.mod_id, MIN_TEST_VOLTAGE);

    vth_pinit(V.mod_id, V.slot);



    source_voltage = MIN_TEST_VOLTAGE;

    voltage_increment = STARTING_INCREMENT;

    v_limit_occurred = false;

    close_the_relays____(&V);

    while (!v_limit_occurred && source_voltage >= MAX_TEST_VOLTAGE)

    {  /*search for limit level*/

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_mtmr_wait(V.mod_id, 0.050);

      vth_prd_stat(V.mod_id, V.slot);

      if (!get_result_nolog(V.mod_id, &result))

      {  /*process the result*/

        display_prompt("No result in result log (Expected dig stat)", true);

        continue;

      }  /*process the result*/



      this_word.data = result.UU.Integer_result;

//mjs - changed bit number from 10 to 5

      if (P_getbits_US(this_word.bits, 5, 0) != 0)

      {  /* limit_occurred */

        source_voltage -= voltage_increment;

        continue;

      }  /* limit_occurred */

      v_limit_occurred = true;

      if (voltage_increment <= FINEST_INCREMENT)

        continue;

      v_limit_occurred = false;

      source_voltage += voltage_increment;

      vth_asrc_set_dc_ampl(V.mod_id, source_voltage);

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_the_relays____(&V);

      voltage_increment /= 2;

    }  /*search for limit level*/



    if (!v_limit_occurred)

      actual_voltage = INT_MAX;

    else

    {  /*measure the acutal voltage*/

      vth_pdrv_clr_err(V.mod_id, V.slot);

      close_pin_gnd_relays(V.mod_id, V.slot);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.receiver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.receiver - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[MUX_NODE_PIN]

                 [V.receiver - 'A']);

      measure_dmm(V.mod_id);

      if (get_result_nolog(V.mod_id, &result))

        actual_voltage = result.UU.Real_result;

      else

        display_prompt("No result in result log (Expected dmm reading)", true);

    }  /*measure the acutal voltage*/



    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = actual_voltage;

    log_result(V.mod_id, result);



  }  /*for receiver*/







  vth_ainit(V.mod_id);



  close_dmm(V.mod_id);

  close_34980A(V.mod_id);//close_mux(V.mod_id);



}  /*t9183*/

#undef RANGE

#undef MUX_NODE_PIN

#undef RESOLUTION

#undef MIN_TEST_VOLTAGE

#undef MAX_TEST_VOLTAGE

#undef FINEST_INCREMENT

#undef STARTING_INCREMENT

#undef DMM_FUNCTION



#define NUM_LOOPS       10   /* buzz loops/relay */

typedef int loop_type;

/* static variables for t9184: */

struct LOC_t9184

{

  int mod_id;

  int slot;

};



static void buzz_that_relay(int relay, struct LOC_t9184 *LINK)

{

  loop_type bloop;



  vth_popen_rly(LINK->mod_id, LINK->slot, relay);

  vth_mtmr_wait(LINK->mod_id, 0.2e-3);



  vth_pclose_rly(LINK->mod_id, LINK->slot, relay);

  vth_mtmr_wait(LINK->mod_id, 1.0e-3);



  for (bloop = 1; bloop <= NUM_LOOPS; bloop++)

  {  /* for bloop */

    vth_aclose_rly(LINK->mod_id, K820);



    vth_rlc_setup(LINK->mod_id, 0, 0.1, 0.0, 0.001, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,

              -5.0, 0.001);



    vth_aopen_rly(LINK->mod_id, K814);



    /*wait time*/

    vth_mtmr_wait(LINK->mod_id, 0.2e-3);



    vth_aclose_rly(LINK->mod_id, K813);   /*connect DETLO with I bus*/

    vth_aclose_rly(LINK->mod_id, K816);   /*connect G bus with I bus*/



    /*wait time*/

    vth_mtmr_wait(LINK->mod_id, 20.0e-3);



    vth_resistor_meas(LINK->mod_id, 0, 1);



    vth_get_abs_resistor_result(LINK->mod_id);



  }  /* for bloop */



}  /* buzz_that_relay */



//------------------------------------------------------------------------------

void t9184(int mod_id, int slot)

{

  /* Buzz test for relays */



  /*From t3240 in DGN ~/sccs/dgn/src/tests/mt3000.p , modified to replace */

  /*buzz testing in production JRM - 11/18/92*/

  /*This is prepared for the test with/without CD fixture. If this test was failed*/

  /*without CD fixture, the driver relay or kgl will also be suspected.*/



  /*isolates mint relays on the receiver -- 72 relays total*/

  /*assumption = t3210(kxn and kdcn relays test) tested good*/

  struct LOC_t9184 V;

  int mux;

  int channel;

  boolean virgin_card;

  boolean virgin_channel;





  V.mod_id = mod_id;

  V.slot = slot;

  /*PIN relay exercise*/

  buzz_prelays(V.mod_id, V.slot);



  /*initialization*/

  vth_aunpowered_init(V.mod_id);

  vth_ameas_set_averaging(V.mod_id, 1);



  virgin_card = true;



  /*setup XL and XG bus relays*/

  vth_pclose_rly(V.mod_id, V.slot, KDCG);

  vth_pclose_rly(V.mod_id, V.slot, KDCL);

  vth_aclose_rly(V.mod_id, K753);   /*connect L bus with mother board*/

  vth_aclose_rly(V.mod_id, K752);   /*connect G bus with XG bus*/

  vth_aclose_rly(V.mod_id, K754);   /*connect L bus with XL bus*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*of for channel*/

    virgin_channel = true;

    /*close PIN card under test relays*/

    vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



    /*setup AIM - SUBMUX S bus connection with Xn bus*/

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);



    for (mux = 0; mux <= 8; mux++)   /*for each mux node relay pair */

    {  /* for mux */

      /*setup AIM relays*/

      vth_aclose_rly(V.mod_id, K820);   /*connect L bus with DETLO*/



      /*close PIN card under test relays*/

      vth_pclose_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



      if (virgin_card)

      {  /* buzz once per card relays */

        buzz_that_relay(KDCG, &V);

        buzz_that_relay(KDCL, &V);

        virgin_card = false;

      }  /* buzz once per card relays */



      if (virgin_channel)

      {  /* buzz once per channel relays */

        buzz_that_relay(PIN_KDC_RLYS[channel - 'A'], &V);

        buzz_that_relay(PIN_KX_RLYS[channel - 'A'], &V);

        buzz_that_relay(PIN_KGL_RLYS[channel - 'A'], &V);

        virgin_channel = false;

      }  /* buzz once per channel relays */



      buzz_that_relay(PIN_DRVR_RLYS[mux][channel - 'A'], &V);

      buzz_that_relay(PIN_RCVR_RLYS[mux][channel - 'A'], &V);



      vth_popen_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

      vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



    }  /* for mux */



    /*initialize all PIN and AIM relays*/

    vth_aopen_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



  }  /*for channel*/



}  /* t9184 */

#undef NUM_LOOPS



#define WHITE           85

/*01010101b*/

/*patterns*/

#define BLACK           170   /*10101010b*/

#define DRIVE_WRITE_MASK  127

/*01111111b*/

/*drive register masks*/

#define DRIVE_READ_MASK  127

#define RECEIVE_WRITE_MASK  127   /*receive register masks*/

#define RECEIVE_READ_MASK  127

#define MIN_DRIVE_CHAN  0   /*channels*/

#define MAX_DRIVE_CHAN  7

#define MIN_RECEIVE_CHAN  0

#define MAX_RECEIVE_CHAN  7

typedef int pattern_type;

typedef int channel_type_;

typedef char message_type[81];

#define LSB             0

#define MSB             31



typedef union bits

{

  pattern_type word_;

  unsigned bit_;

} bits;



/* static variables for t9185: */

struct LOC_t9185

{

  int mod_id;

  int slot;

  message_type the_pattern;

  test_result_type the_no_result;   /*initialized in main*/

  int subtest;   /*initialized in main*/

};



/*!ITOS*/

/*+convert an integer to a string*/

/*-----------------------------------------------------------------------*/

static char * itos(char * result, int i, struct LOC_t9185 *)

{

  s80 s;

  int n;



  sprintf(s, "%d", i);

  n = mtd_strlen(s) + 1;

  return strcpy(result, s);

}



/*!THE PATTERN IS*/

/*+record a pattern's description for error messages*/

/*-----------------------------------------------------------------------*/

static void the_pattern_is(char * description, struct LOC_t9185 * LINK)

{

  strcpy(LINK->the_pattern, description);

}



/*!PFC DRV DLY*/

/*+convert a channel number and "drv" register into a pcell*/

/*-----------------------------------------------------------------------*/

static int pfc_drv_dly(char * drv, int chan, struct LOC_t9185 *)

{

  switch (drv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return PFC_DRV_DLY_0_A;

        case 1:  return PFC_DRV_DLY_1_A;

        case 2:  return PFC_DRV_DLY_2_A;

        case 3:  return PFC_DRV_DLY_3_A;

        case 4:  return PFC_DRV_DLY_4_A;

        case 5:  return PFC_DRV_DLY_5_A;

        case 6:  return PFC_DRV_DLY_6_A;

        case 7:  return PFC_DRV_DLY_7_A;

        default: assert(false); return PFC_DRV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return PFC_DRV_DLY_0_B;

        case 1:  return PFC_DRV_DLY_1_B;

        case 2:  return PFC_DRV_DLY_2_B;

        case 3:  return PFC_DRV_DLY_3_B;

        case 4:  return PFC_DRV_DLY_4_B;

        case 5:  return PFC_DRV_DLY_5_B;

        case 6:  return PFC_DRV_DLY_6_B;

        case 7:  return PFC_DRV_DLY_7_B;

        default: assert(false); return PFC_DRV_DLY_0_B;

      }

      break;



    default: assert(false); return PFC_DRV_DLY_0_A;

  }

}



/*!PFC RCV DLY*/

/*+convert a channel number and "rcv" register into a pcell*/

/*-----------------------------------------------------------------------*/

static int pfc_rcv_dly(char * rcv, int chan, struct LOC_t9185 *)

{

  switch (rcv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return PFC_RCV_DLY_0_A;

        case 1:  return PFC_RCV_DLY_1_A;

        case 2:  return PFC_RCV_DLY_2_A;

        case 3:  return PFC_RCV_DLY_3_A;

        case 4:  return PFC_RCV_DLY_4_A;

        case 5:  return PFC_RCV_DLY_5_A;

        case 6:  return PFC_RCV_DLY_6_A;

        case 7:  return PFC_RCV_DLY_7_A;

        default: assert(false); return PFC_RCV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return PFC_RCV_DLY_0_B;

        case 1:  return PFC_RCV_DLY_1_B;

        case 2:  return PFC_RCV_DLY_2_B;

        case 3:  return PFC_RCV_DLY_3_B;

        case 4:  return PFC_RCV_DLY_4_B;

        case 5:  return PFC_RCV_DLY_5_B;

        case 6:  return PFC_RCV_DLY_6_B;

        case 7:  return PFC_RCV_DLY_7_B;

        default: assert(false); return PFC_RCV_DLY_0_B;

      }

      break;



    default:  assert(false); return PFC_RCV_DLY_0_A;

  }

}





/*!AND MASK*/

/*+return the result of bitwise anding a pattern and a mask*/

/*-----------------------------------------------------------------------*/

static int and_mask(int pattern, int mask, struct LOC_t9185 *)

{

  bits p;

  bits m;

  bits result;

  int i;



  result.bit_ = ~0; // wpd - need to check if this is correct

  p.word_ = pattern;

  m.word_ = mask;

  for (i = LSB; i <= MSB; i++)

  {

    result.bit_ &= ~(1 << (i - LSB));

    result.bit_ |= ((p.bit_ & (1 << (i - LSB))) != 0 &&

                    (m.bit_ & (1 << (i - LSB))) != 0) << (i - LSB);

  }

  return (result.word_);

}

#undef LSB

#undef MSB



/* static variables for interleave_write_drive: */

struct LOC_interleave_write_drive

{

  struct LOC_t9185 *LINK;

} ;



/*!WRITE DRIVE*/

/*+use an appropriate "vth" procedure to write to a drive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_drive(char *drv, int chan, int pattern, struct LOC_interleave_write_drive * LINK)

{

  switch (drv[0])

  {



  case 'a':

    vth_pfc_wr_drva_tap(LINK->LINK->mod_id, LINK->LINK->slot, chan, pattern);

    break;



  case 'b':

    vth_pfc_wr_drvb_tap(LINK->LINK->mod_id, LINK->LINK->slot, chan, pattern);

    break;



  default:

    assert(false);

    break;



  }

}





/*!INTERLEAVE WRITE DRIVE*/

/*+issue interleaved writes to all channels of "drv1" and "drv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_drive(char * drv1, int pattern1, char * drv2, int pattern2, struct LOC_t9185 * LINK)

{

  struct LOC_interleave_write_drive V;

  pattern_type p1;

  pattern_type p2;

  channel_type_ chan;



  /*+BODY OF INTERLEAVE WRITE DRIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask(pattern1, DRIVE_WRITE_MASK, LINK);

  p2 = and_mask(pattern2, DRIVE_WRITE_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO DRV1*/

    vth_write_drive(drv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO DRV2*/

    vth_write_drive(drv2, chan, p2, &V);

  }

}



/* static variables for interleave_write_receive: */

struct LOC_interleave_write_receive

{

  struct LOC_t9185 *LINK;

} ;



/*!WRITE RECEIVE*/

/*+use an appropriate "vth" procedure to write to a receive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_receive(char * rcv, int chan, int pattern, struct LOC_interleave_write_receive * LINK)

{

  switch (rcv[0])

  {



  case 'a':

    vth_pfc_wr_rcva_tap(LINK->LINK->mod_id, LINK->LINK->slot, chan, pattern);

    break;



  case 'b':

    vth_pfc_wr_rcvb_tap(LINK->LINK->mod_id, LINK->LINK->slot, chan, pattern);

    break;



  default:

    assert(false);

    break;



  }

}



/*!INTERLEAVE WRITE RECEIVE*/

/*+issue interleaved writes to all channels of "rcv1" and "rcv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_receive(char * rcv1, int pattern1, char * rcv2, int pattern2, struct LOC_t9185 * LINK)

{

  struct LOC_interleave_write_receive V;

  pattern_type p1;

  pattern_type p2;

  channel_type_ chan;



  /*+BODY OF INTERLEAVE WRITE RECEIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask(pattern1, RECEIVE_WRITE_MASK, LINK);

  p2 = and_mask(pattern2, RECEIVE_WRITE_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO RCV1*/

    vth_write_receive(rcv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO RCV2*/

    vth_write_receive(rcv2, chan, p2, &V);

  }

}



/*!DISPLAY TEST TITLE*/

/*+output test title and pattern description to operator's display*/

/*-----------------------------------------------------------------------*/

static void display_test_title(struct LOC_t9185 * LINK)

{

  s80 str1;

  char str2[196];



  sprintf(str2, "T9185 Formatter Pattern Subtest %s: %s",

          itos(str1, LINK->subtest, LINK), LINK->the_pattern);

  display_prompt(str2, true);

}



/*!NO RESULT*/

/*+alert operator that no result was available*/

/*-----------------------------------------------------------------------*/

static void no_result(char * message, char * reg, int chan, struct LOC_t9185 * LINK)

{

  s80 str1;

  s80 str2;

  char str3[256];

  s80 str4;



  display_test_title(LINK);

  sprintf(str3, "Module=%s Slot=%s%s%c Chan=%s No result in result log",

          itos(str1, LINK->mod_id, LINK), itos(str2, LINK->slot, LINK),

          message, reg, itos(str4, chan, LINK));

  display_prompt(str3, true);

  display_prompt("", true);

}



/*!DOESNT MATCH*/

/*+complain to operator about mismatched patterns*/

/*-----------------------------------------------------------------------*/

static void doesnt_match(char * message, char * reg, int chan, int actual, int expected, struct LOC_t9185 * LINK)

{

  s80 str1;

  s80 str2;

  s80 str4;

  s80 str5;

  s80 str6;

  char str7[256];



  display_test_title(LINK);

  sprintf(str7, "Module=%s Slot=%s%s%c Chan=%s Actual=%s Expected=%s",

          itos(str1, LINK->mod_id, LINK), itos(str2, LINK->slot, LINK),

          message, reg, itos(str4, chan, LINK), itos(str5, actual, LINK),

          itos(str6, expected, LINK));

  display_prompt(str7, true);

  display_prompt("", true);

}



/*!EXPECT DRIVE*/

/*+check all channels of register "drv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_drive(char *drv, int pattern, struct LOC_t9185 *LINK)

{

  pattern_type actual;

  pattern_type expected;

  channel_type_ chan;

  test_result_type the_result;



  /*+APPLY THE DRIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask(pattern, DRIVE_READ_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "DRV" CHANNEL*/

    vth_prd_cell(LINK->mod_id, LINK->slot, pfc_drv_dly(drv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_nolog(LINK->mod_id, &the_result))

    {

      /*+LOG THE RESULT*/

      log_result(LINK->mod_id, the_result);



      /*+APPLY THE READ-MASK*/

      actual = and_mask(the_result.UU.Integer_result, DRIVE_READ_MASK, LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match(" DRV=", drv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      no_result(" DRV=", drv, chan, LINK);

      log_result(LINK->mod_id, LINK->the_no_result);

    }



    /*+OTHERWISE*/

  }

}



/*!EXPECT RECEIVE*/

/*+check all channels of register "rcv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_receive(char *rcv, int pattern, struct LOC_t9185 *LINK)

{

  pattern_type actual;

  pattern_type expected;

  channel_type_ chan;

  test_result_type the_result;



  /*+APPLY THE RECEIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask(pattern, RECEIVE_READ_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "RCV" CHANNEL*/

    vth_prd_cell(LINK->mod_id, LINK->slot, pfc_rcv_dly(rcv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_nolog(LINK->mod_id, &the_result))

    {

      /*+LOG THE RESULT*/

      log_result(LINK->mod_id, the_result);



      /*+APPLY THE READ-MASK*/

      actual = and_mask(the_result.UU.Integer_result, RECEIVE_READ_MASK, LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match(" RCV=", rcv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      log_result(LINK->mod_id, LINK->the_no_result);

      no_result(" RCV=", rcv, chan, LINK);

    }



    /*+OTHERWISE*/

  }

}



//------------------------------------------------------------------------------

/*+T9185.P*/

/*PAGE #*/

/*!T9185*/

/*+17-JAN-90 (slc) Cox wrote original from Devore's notes*/

/*+22-JAN-90 (slc) Cox corrected bugs and got it working for the 1st time*/

/*+05-FEB-90 (slc) Devore checked with real boards and blessed it*/

/*+06-FEB-90 (slc) Cox added error logging*/

/*-----------------------------------------------------------------------*/

void t9185(int mod_id, int slot)

{

  struct LOC_t9185 V;



  /*+BODY OF T9185*/

  /*-----------------------------------------------------------------------*/

  V.mod_id = mod_id;

  V.slot = slot;

  /*+INITIALIZE THE SUBTEST COUNTER*/

  V.subtest = 0;



  /*----------*/



  /*+INITIALIZE "THE NO RESULT" RESULT*/

  V.the_no_result.Measurement_class = CLASS_BOOLEAN;

  V.the_no_result.UU.Boolean_result = false;



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is("Black on white, vth_write A then B", &V);

  interleave_write_drive("a", BLACK, "b", WHITE, &V);

  interleave_write_receive("a", BLACK, "b", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive("a", BLACK, &V);

  expect_drive("b", WHITE, &V);

  expect_receive("a", BLACK, &V);

  expect_receive("b", WHITE, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is("White on black, vth_write A then B", &V);

  interleave_write_drive("a", WHITE, "b", BLACK, &V);

  interleave_write_receive("a", WHITE, "b", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive("a", WHITE, &V);

  expect_drive("b", BLACK, &V);

  expect_receive("a", WHITE, &V);

  expect_receive("b", BLACK, &V);



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is("Black on white, vth_write B then A", &V);

  interleave_write_drive("b", BLACK, "a", WHITE, &V);

  interleave_write_receive("b", BLACK, "a", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive("a", WHITE, &V);

  expect_drive("b", BLACK, &V);

  expect_receive("a", WHITE, &V);

  expect_receive("b", BLACK, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is("White on black, vth_write B then A", &V);

  interleave_write_drive("b", WHITE, "a", BLACK, &V);

  interleave_write_receive("b", WHITE, "a", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive("a", BLACK, &V);

  expect_drive("b", WHITE, &V);

  expect_receive("a", BLACK, &V);

  expect_receive("b", WHITE, &V);



  /*----------*/



  /*+RESET THE MODULE TO A KNOWN STATE*/

  vth_mod_init_dgn(V.mod_id);

}

#undef WHITE

#undef BLACK

#undef DRIVE_WRITE_MASK

#undef DRIVE_READ_MASK

#undef RECEIVE_WRITE_MASK

#undef RECEIVE_READ_MASK

#undef MIN_DRIVE_CHAN

#undef MAX_DRIVE_CHAN

#undef MIN_RECEIVE_CHAN

#undef MAX_RECEIVE_CHAN



#define WHITE           85

/*01010101b*/

/*patterns*/

#define BLACK           170   /*10101010b*/

#define DRIVE_WRITE_MASK  127

/*01111111b*/

/*drive register masks*/

#define DRIVE_READ_MASK  127

#define RECEIVE_WRITE_MASK  127   /*receive register masks*/

#define RECEIVE_READ_MASK  127

#define MIN_DRIVE_CHAN  0   /*channels*/

#define MAX_DRIVE_CHAN  1

#define MIN_RECEIVE_CHAN  0

#define MAX_RECEIVE_CHAN  1

typedef int pattern_type_;

typedef int channel_type__;

typedef char message_type_[81];

#define LSB             0

#define MSB             31



typedef union bits_

{

  pattern_type_ word_;

  unsigned      bit_;

} bits_;



/* static variables for t9186: */

struct LOC_t9186

{

  int mod_id;

  int slot;

  message_type_ the_pattern;

  test_result_type the_no_result;   /*initialized in main*/

  int subtest;   /*initialized in main*/

} ;



/*!ITOS*/

/*+convert an integer to a string*/

/*-----------------------------------------------------------------------*/

static char * itos_(char * result, int i, struct LOC_t9186 *)

{

  s80 s;

  int n;



  sprintf(s, "%d", i);

  n = mtd_strlen(s) + 1;

  return strcpy(result, s);

}



/*!THE PATTERN IS*/

/*+record a pattern's description for error messages*/

/*-----------------------------------------------------------------------*/

static void the_pattern_is_(char * description, struct LOC_t9186 * LINK)

{

  strcpy(LINK->the_pattern, description);

}



/*!afc DRV DLY*/

/*+convert a channel number and "drv" register into a pcell*/

/*-----------------------------------------------------------------------*/

static int afc_drv_dly(char *drv, int chan, struct LOC_t9186 *)

{

  switch (drv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return AFC_DRV_DLY_0_A;

        case 1:  return AFC_DRV_DLY_1_A;

        default: assert(false); return AFC_DRV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return AFC_DRV_DLY_0_B;

        case 1:  return AFC_DRV_DLY_1_B;

        default: assert(false); return AFC_DRV_DLY_0_B;

      }

      break;



    default:

      assert(false);

      return AFC_DRV_DLY_0_A;

  }

}



/*!afc RCV DLY*/

/*+convert a channel number and "rcv" register into a pcell*/

/*-----------------------------------------------------------------------*/

static int afc_rcv_dly(char * rcv, int chan, struct LOC_t9186 *)

{

  switch (rcv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return AFC_RCV_DLY_0_A;

        case 1:  return AFC_RCV_DLY_1_A;

        default: assert(false); return AFC_RCV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return AFC_RCV_DLY_0_B;

        case 1:  return AFC_RCV_DLY_1_B;

        default: assert(false); return AFC_RCV_DLY_0_B;

      }

      break;



    default:

      assert(false);

      return AFC_RCV_DLY_0_A;

  }

}



/*!AND MASK*/

/*+return the result of bitwise anding a pattern and a mask*/

/*-----------------------------------------------------------------------*/

static int and_mask_(int pattern, int mask, struct LOC_t9186 *)

{

  bits_ p;

  bits_ m;

  bits_ result;

  int i;



  result.bit_ = ~0; // wpd - check if this should be set to ~0

  p.word_ = pattern;

  m.word_ = mask;

  for (i = LSB; i <= MSB; i++)

  {

    result.bit_ &= ~(1 << (i - LSB));

    result.bit_ |= ((p.bit_ & (1 << (i - LSB))) != 0 &&

                    (m.bit_ & (1 << (i - LSB))) != 0) << (i - LSB);

  }

  return (result.word_);

}

#undef LSB

#undef MSB



/* static variables for interleave_write_drive_: */

struct LOC_interleave_write_drive_

{

  struct LOC_t9186 *LINK;

} ;



/*!WRITE DRIVE*/

/*+use an appropriate "vth" procedure to write to a drive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_drive_(char * drv, int chan, int pattern, struct LOC_interleave_write_drive_ * LINK)

{

  switch (drv[0])

  {



  case 'a':

    vth_afc_wr_drva_tap(LINK->LINK->mod_id, chan, pattern);

    break;



  case 'b':

    vth_afc_wr_drvb_tap(LINK->LINK->mod_id, chan, pattern);

    break;



  default:

    assert(false);

    break;



  }

}



/*!INTERLEAVE WRITE DRIVE*/

/*+issue interleaved writes to all channels of "drv1" and "drv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_drive_(char * drv1, int pattern1, char * drv2, int pattern2, struct LOC_t9186 * LINK)

{

  struct LOC_interleave_write_drive_ V;

  pattern_type_ p1;

  pattern_type_ p2;

  channel_type__ chan;



  /*+BODY OF INTERLEAVE WRITE DRIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask_(pattern1, DRIVE_WRITE_MASK, LINK);

  p2 = and_mask_(pattern2, DRIVE_WRITE_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO DRV1*/

    vth_write_drive_(drv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO DRV2*/

    vth_write_drive_(drv2, chan, p2, &V);

  }

}



/* static variables for interleave_write_receive_: */

struct LOC_interleave_write_receive_ {

  struct LOC_t9186 *LINK;

} ;



/*!WRITE RECEIVE*/

/*+use an appropriate "vth" procedure to write to a receive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_receive_(char * rcv, int chan, int pattern, struct LOC_interleave_write_receive_ * LINK)

{

  switch (rcv[0])

  {



  case 'a':

    vth_afc_wr_rcva_tap(LINK->LINK->mod_id, chan, pattern);

    break;



  case 'b':

    vth_afc_wr_rcvb_tap(LINK->LINK->mod_id, chan, pattern);

    break;

  default:

    assert(false);

    break;



  }

}



/*!INTERLEAVE WRITE RECEIVE*/

/*+issue interleaved writes to all channels of "rcv1" and "rcv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_receive_(char * rcv1, int pattern1, char * rcv2, int pattern2, struct LOC_t9186 * LINK)

{

  struct LOC_interleave_write_receive_ V;

  pattern_type_ p1;

  pattern_type_ p2;

  channel_type__ chan;



  /*+BODY OF INTERLEAVE WRITE RECEIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask_(pattern1, RECEIVE_WRITE_MASK, LINK);

  p2 = and_mask_(pattern2, RECEIVE_WRITE_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO RCV1*/

    vth_write_receive_(rcv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO RCV2*/

    vth_write_receive_(rcv2, chan, p2, &V);

  }

}



/*!DISPLAY TEST TITLE*/

/*+output test title and pattern description to operator's display*/

/*-----------------------------------------------------------------------*/

static void display_test_title_(struct LOC_t9186 * LINK)

{

  s80 str1;

  char str2[196];



  sprintf(str2, "T9186 Formatter Pattern Subtest %s: %s",

          itos_(str1, LINK->subtest, LINK), LINK->the_pattern);

  display_prompt(str2, true);

}



/*!NO RESULT*/

/*+alert operator that no result was available*/

/*-----------------------------------------------------------------------*/

static void no_result_(char * message, char * reg, int chan, struct LOC_t9186 * LINK)

{

  s80 str1;

  s80 str2;

  char str3[256];

  s80 str4;



  display_test_title_(LINK);

  sprintf(str3, "Module=%s Slot=%s%s%c Chan=%s No result in result log",

          itos_(str1, LINK->mod_id, LINK), itos_(str2, LINK->slot, LINK),

          message, reg, itos_(str4, chan, LINK));

  display_prompt(str3, true);

  display_prompt("", true);

}



/*!DOESNT MATCH*/

/*+complain to operator about mismatched patterns*/

/*-----------------------------------------------------------------------*/

static void doesnt_match_(char * message, char * reg, int chan, int actual, int expected, struct LOC_t9186 * LINK)

{

  s80 str1;

  s80 str2;

  s80 str4;

  s80 str5;

  s80 str6;

  char str7[256];



  display_test_title_(LINK);

  sprintf(str7, "Module=%s Slot=%s%s%c Chan=%s Actual=%s Expected=%s",

          itos_(str1, LINK->mod_id, LINK), itos_(str2, LINK->slot, LINK),

          message, reg, itos_(str4, chan, LINK), itos_(str5, actual, LINK),

          itos_(str6, expected, LINK));

  display_prompt(str7, true);

  display_prompt("", true);

}



/*!EXPECT DRIVE*/

/*+check all channels of register "drv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_drive_(char * drv, int pattern, struct LOC_t9186 * LINK)

{

  pattern_type_ actual;

  pattern_type_ expected;

  channel_type__ chan;

  test_result_type the_result;



  /*+APPLY THE DRIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask_(pattern, DRIVE_READ_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "DRV" CHANNEL*/

    vth_ard_cell(LINK->mod_id, afc_drv_dly(drv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_log(LINK->mod_id, &the_result))

    {

      /*+APPLY THE READ-MASK*/

      actual = and_mask_(the_result.UU.Integer_result, DRIVE_READ_MASK, LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match_(" DRV=", drv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      no_result_(" DRV=", drv, chan, LINK);

      log_result(LINK->mod_id, LINK->the_no_result);

    }



    /*+OTHERWISE*/

  }

}



/*!EXPECT RECEIVE*/

/*+check all channels of register "rcv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_receive_(char * rcv, int pattern, struct LOC_t9186 * LINK)

{

  pattern_type_ actual;

  pattern_type_ expected;

  channel_type__ chan;

  test_result_type the_result;



  /*+APPLY THE RECEIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask_(pattern, RECEIVE_READ_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "RCV" CHANNEL*/

    vth_ard_cell(LINK->mod_id, afc_rcv_dly(rcv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_log(LINK->mod_id, &the_result))

    {

      /*+APPLY THE READ-MASK*/

      actual = and_mask_(the_result.UU.Integer_result, RECEIVE_READ_MASK,

                         LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match_(" RCV=", rcv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      log_result(LINK->mod_id, LINK->the_no_result);

      no_result_(" RCV=", rcv, chan, LINK);

    }



    /*+OTHERWISE*/

  }

}



//------------------------------------------------------------------------------

/*+T9186.P*/

/*PAGE #*/



/*!T9186*/

/*+17-JAN-90 (slc) Cox wrote original from Devore's notes*/

/*+22-JAN-90 (slc) Cox corrected bugs and got it working for the 1st time*/

/*+05-FEB-90 (slc) Devore checked with real boards and blessed it*/

/*+06-FEB-90 (slc) Cox added error logging*/

/*+04-JUN-90 (jrm) Myers modified t9185 to become t9186 (aim formatter)*/

/*-----------------------------------------------------------------------*/

void t9186(int mod_id, int slot)

{

  struct LOC_t9186 V;



  /*+BODY OF T9186*/

  /*-----------------------------------------------------------------------*/

  V.mod_id = mod_id;

  V.slot = slot;

  /*+INITIALIZE THE SUBTEST COUNTER*/

  V.subtest = 0;



  /*----------*/



  /*+INITIALIZE "THE NO RESULT" RESULT*/

  V.the_no_result.Measurement_class = CLASS_BOOLEAN;

  V.the_no_result.UU.Boolean_result = false;



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is_("Black on white, vth_write A then B", &V);

  interleave_write_drive_("a", BLACK, "b", WHITE, &V);

  interleave_write_receive_("a", BLACK, "b", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive_("a", BLACK, &V);

  expect_drive_("b", WHITE, &V);

  expect_receive_("a", BLACK, &V);

  expect_receive_("b", WHITE, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is_("White on black, vth_write A then B", &V);

  interleave_write_drive_("a", WHITE, "b", BLACK, &V);

  interleave_write_receive_("a", WHITE, "b", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive_("a", WHITE, &V);

  expect_drive_("b", BLACK, &V);

  expect_receive_("a", WHITE, &V);

  expect_receive_("b", BLACK, &V);



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is_("Black on white, vth_write B then A", &V);

  interleave_write_drive_("b", BLACK, "a", WHITE, &V);

  interleave_write_receive_("b", BLACK, "a", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive_("a", WHITE, &V);

  expect_drive_("b", BLACK, &V);

  expect_receive_("a", WHITE, &V);

  expect_receive_("b", BLACK, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is_("White on black, vth_write B then A", &V);

  interleave_write_drive_("b", WHITE, "a", BLACK, &V);

  interleave_write_receive_("b", WHITE, "a", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive_("a", BLACK, &V);

  expect_drive_("b", WHITE, &V);

  expect_receive_("a", BLACK, &V);

  expect_receive_("b", WHITE, &V);



  /*----------*/



  /*+RESET THE MODULE TO A KNOWN STATE*/

  vth_mod_init_dgn(V.mod_id);

}

#undef WHITE

#undef BLACK

#undef DRIVE_WRITE_MASK

#undef DRIVE_READ_MASK

#undef RECEIVE_WRITE_MASK

#undef RECEIVE_READ_MASK

#undef MIN_DRIVE_CHAN

#undef MAX_DRIVE_CHAN

#undef MIN_RECEIVE_CHAN

#undef MAX_RECEIVE_CHAN



#define WHITE           85

/*01010101b*/

/*patterns*/

#define BLACK           170   /*10101010b*/

#define DRIVE_WRITE_MASK  127

/*01111111b*/

/*drive register masks*/

#define DRIVE_READ_MASK  127

#define RECEIVE_WRITE_MASK  127   /*receive register masks*/

#define RECEIVE_READ_MASK  127

#define MIN_DRIVE_CHAN  0   /*channels*/

#define MAX_DRIVE_CHAN  1

#define MIN_RECEIVE_CHAN  0

#define MAX_RECEIVE_CHAN  1

typedef int pattern_type__;

typedef int channel_type___;

typedef char message_type__[81];

#define LSB             0

#define MSB             31



typedef union bits__

{

  pattern_type__ word_;

  unsigned bit_;

} bits__;



/* static variables for t9187: */

struct LOC_t9187

{

  int mod_id;

  int slot;

  message_type__ the_pattern;

  test_result_type the_no_result;   /*initialized in main*/

  int subtest;   /*initialized in main*/

} ;



/*!ITOS*/

/*+convert an integer to a string*/

/*-----------------------------------------------------------------------*/

static char * itos__(char * result, int i, struct LOC_t9187 *)

{

  s80 s;

  int n;



  sprintf(s, "%d", i);

  n = mtd_strlen(s) + 1;

  return strcpy(result, s);

}



/*!THE PATTERN IS*/

/*+record a pattern's description for error messages*/

/*-----------------------------------------------------------------------*/

static void the_pattern_is__(char * description, struct LOC_t9187 * LINK)

{

  strcpy(LINK->the_pattern, description);

}



/*!mfc DRV DLY*/

/*+convert a channel number and "drv" register into an mcell*/

/*-----------------------------------------------------------------------*/

static int mfc_drv_dly(char * drv, int chan, struct LOC_t9187 *)

{

  switch (drv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return MFC_DRV_DLY_0_A;

        case 1:  return MFC_DRV_DLY_1_A;

        default: assert(false); return MFC_DRV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return MFC_DRV_DLY_0_B;

        case 1:  return MFC_DRV_DLY_1_B;

        default: assert(false); return MFC_DRV_DLY_0_B;

      }

      break;



    default:

      assert(false);

      return MFC_DRV_DLY_0_A;

  }

}



/*!mfc RCV DLY*/

/*+convert a channel number and "rcv" register into an mcell*/

/*-----------------------------------------------------------------------*/

static int mfc_rcv_dly(char * rcv, int chan, struct LOC_t9187 *)

{

  switch (rcv[0])

  {

    case 'a':

      switch (chan)

      {

        case 0:  return MFC_RCV_DLY_0_A;

        case 1:  return MFC_RCV_DLY_1_A;

        default: assert(false); return MFC_RCV_DLY_0_A;

      }

      break;



    case 'b':

      switch (chan)

      {

        case 0:  return MFC_RCV_DLY_0_B;

        case 1:  return MFC_RCV_DLY_1_B;

        default: assert(false); return MFC_RCV_DLY_0_B;

      }

      break;



    default:

      assert(false);

      return MFC_RCV_DLY_0_A;

  }

}



/*!AND MASK*/

/*+return the result of bitwise anding a pattern and a mask*/

/*-----------------------------------------------------------------------*/

static int and_mask__(int pattern, int mask, struct LOC_t9187 *)

{

  bits__ p;

  bits__ m;

  bits__ result;

  int i;



  result.bit_ = ~0; // wpd - check this

  p.word_ = pattern;

  m.word_ = mask;

  for (i = LSB; i <= MSB; i++)

  {

    result.bit_ &= ~(1 << (i - LSB));

    result.bit_ |= ((p.bit_ & (1 << (i - LSB))) != 0 &&

                    (m.bit_ & (1 << (i - LSB))) != 0) << (i - LSB);

  }

  return (result.word_);

}

#undef LSB

#undef MSB



/* static variables for interleave_write_drive__: */

struct LOC_interleave_write_drive__

{

  struct LOC_t9187 *LINK;

} ;



/*!WRITE DRIVE*/

/*+use an appropriate "vth" procedure to write to a drive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_drive__(char * drv, int chan, int pattern, struct LOC_interleave_write_drive__ * LINK)

{

  vth_mwr_cell(LINK->LINK->mod_id, mfc_drv_dly(drv, chan, LINK->LINK), pattern);

}



/*!INTERLEAVE WRITE DRIVE*/

/*+issue interleaved writes to all channels of "drv1" and "drv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_drive__(char * drv1, int pattern1, char * drv2, int pattern2, struct LOC_t9187 * LINK)

{

  struct LOC_interleave_write_drive__ V;

  pattern_type__ p1;

  pattern_type__ p2;

  channel_type___ chan;



  /*+BODY OF INTERLEAVE WRITE DRIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask__(pattern1, DRIVE_WRITE_MASK, LINK);

  p2 = and_mask__(pattern2, DRIVE_WRITE_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO DRV1*/

    vth_write_drive__(drv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO DRV2*/

    vth_write_drive__(drv2, chan, p2, &V);

  }

}



/* static variables for interleave_write_receive__: */

struct LOC_interleave_write_receive__

{

  struct LOC_t9187 *LINK;

} ;



/*!WRITE RECEIVE*/

/*+use an appropriate "vth" procedure to write to a receive register*/

/*-----------------------------------------------------------------------*/

static void vth_write_receive__(char * rcv, int chan, int pattern, struct LOC_interleave_write_receive__ * LINK)

{

  vth_mwr_cell(LINK->LINK->mod_id, mfc_rcv_dly(rcv, chan, LINK->LINK), pattern);

}



/*!INTERLEAVE WRITE RECEIVE*/

/*+issue interleaved writes to all channels of "rcv1" and "rcv2"*/

/*-----------------------------------------------------------------------*/

static void interleave_write_receive__(char * rcv1, int pattern1, char * rcv2, int pattern2, struct LOC_t9187 * LINK)

{

  struct LOC_interleave_write_receive__ V;

  pattern_type__ p1;

  pattern_type__ p2;

  channel_type___ chan;



  /*+BODY OF INTERLEAVE WRITE RECEIVE*/

  /*-----------------------------------------------------------------------*/

  V.LINK = LINK;

  /*+MASK THE PATTERNS TO FIT THE REGS.*/

  p1 = and_mask__(pattern1, RECEIVE_WRITE_MASK, LINK);

  p2 = and_mask__(pattern2, RECEIVE_WRITE_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+WRITE MASKED PATTERN1 TO RCV1*/

    vth_write_receive__(rcv1, chan, p1, &V);



    /*+WRITE MASKED PATTERN2 TO RCV2*/

    vth_write_receive__(rcv2, chan, p2, &V);

  }

}



/*!DISPLAY TEST TITLE*/

/*+output test title and pattern description to operator's display*/

/*-----------------------------------------------------------------------*/

static void display_test_title__(struct LOC_t9187 * LINK)

{

  s80 str1;

  char str2[196];



  sprintf(str2, "T9187 Formatter Pattern Subtest %s: %s",

          itos__(str1, LINK->subtest, LINK), LINK->the_pattern);

  display_prompt(str2, true);

}



/*!NO RESULT*/

/*+alert operator that no result was available*/

/*-----------------------------------------------------------------------*/

static void no_result__(char * message, char * reg, int chan, struct LOC_t9187 * LINK)

{

  s80 str1;

  s80 str2;

  char str3[256];

  s80 str4;



  display_test_title__(LINK);

  sprintf(str3, "Module=%s Slot=%s%s%c Chan=%s No result in result log",

          itos__(str1, LINK->mod_id, LINK), itos__(str2, LINK->slot, LINK),

          message, reg, itos__(str4, chan, LINK));

  display_prompt(str3, true);

  display_prompt("", true);

}



/*!DOESNT MATCH*/

/*+complain to operator about mismatched patterns*/

/*-----------------------------------------------------------------------*/

static void doesnt_match__(char * message, char * reg, int chan, int actual, int expected, struct LOC_t9187 * LINK)

{

  s80 str1;

  s80 str2;

  s80 str4;

  s80 str5;

  s80 str6;

  char str7[256];



  display_test_title__(LINK);

  sprintf(str7, "Module=%s Slot=%s%s%c Chan=%s Actual=%s Expected=%s",

          itos__(str1, LINK->mod_id, LINK), itos__(str2, LINK->slot, LINK),

          message, reg, itos__(str4, chan, LINK), itos__(str5, actual, LINK),

          itos__(str6, expected, LINK));

  display_prompt(str7, true);

  display_prompt("", true);

}



/*!EXPECT DRIVE*/

/*+check all channels of register "drv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_drive__(char * drv, int pattern, struct LOC_t9187 * LINK)

{

  pattern_type__ actual;

  pattern_type__ expected;

  channel_type___ chan;

  test_result_type the_result;



  /*+APPLY THE DRIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask__(pattern, DRIVE_READ_MASK, LINK);



  /*+FOR EACH DRIVE CHANNEL...*/

  for (chan = MIN_DRIVE_CHAN; chan <= MAX_DRIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "DRV" CHANNEL*/

    vth_mrd_cell(LINK->mod_id, mfc_drv_dly(drv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_log(LINK->mod_id, &the_result))

    {

      /*+APPLY THE READ-MASK*/

      actual = and_mask__(the_result.UU.Integer_result, DRIVE_READ_MASK, LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match__(" DRV=", drv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      no_result__(" DRV=", drv, chan, LINK);

      log_result(LINK->mod_id, LINK->the_no_result);

    }



    /*+OTHERWISE*/

  }

}



/*!EXPECT RECEIVE*/

/*+check all channels of register "rcv" for an expected pattern*/

/*-----------------------------------------------------------------------*/

static void expect_receive__(char * rcv, int pattern, struct LOC_t9187 * LINK)

{

  pattern_type__ actual;

  pattern_type__ expected;

  channel_type___ chan;

  test_result_type the_result;



  /*+APPLY THE RECEIVE-READ-MASK TO THE EXPECTED PATTERN*/

  expected = and_mask__(pattern, RECEIVE_READ_MASK, LINK);



  /*+FOR EACH RECEIVE CHANNEL...*/

  for (chan = MIN_RECEIVE_CHAN; chan <= MAX_RECEIVE_CHAN; chan++)

  {

    /*+INCREMENT THE GLOBAL SUBTEST COUNTER*/

    LINK->subtest++;



    /*+READ THE PCELL APPROPRIATE FOR THIS "RCV" CHANNEL*/

    vth_mrd_cell(LINK->mod_id, mfc_rcv_dly(rcv, chan, LINK));



    /*+IF THERE IS A RESULT...*/

    if (get_result_log(LINK->mod_id, &the_result))

    {

      /*+APPLY THE READ-MASK*/

      actual = and_mask__(the_result.UU.Integer_result, RECEIVE_READ_MASK,

                          LINK);



      /*+COMPLAIN IF THE MASKED READ DOESN'T MATCH THE EXPECTED*/

      if (actual != expected)

        doesnt_match__(" RCV=", rcv, chan, actual, expected, LINK);

    }

    else

    {

      /*+LOG "NO RESULT" AND COMPLAIN TO THE OPERATOR*/

      log_result(LINK->mod_id, LINK->the_no_result);

      no_result__(" RCV=", rcv, chan, LINK);

    }



    /*+OTHERWISE*/

  }

}





//------------------------------------------------------------------------------

/*+T9187.P*/

/*PAGE #*/



/*!T9187*/

/*+17-JAN-90 (slc) Cox wrote original from Devore's notes*/

/*+22-JAN-90 (slc) Cox corrected bugs and got it working for the 1st time*/

/*+05-FEB-90 (slc) Devore checked with real boards and blessed it*/

/*+06-FEB-90 (slc) Cox added error logging*/

/*+04-JUN-90 (jrm) Myers modified t9185 to become t9186 (aim formatter)*/

/*+07-JUN-90 (jrm) Myers modified t9186 to become t9187 (mac formatter)*/

/*-----------------------------------------------------------------------*/

void t9187(int mod_id, int slot)

{

  struct LOC_t9187 V;





  /*+BODY OF T9187*/

  /*-----------------------------------------------------------------------*/

  V.mod_id = mod_id;

  V.slot = slot;

  /*+INITIALIZE THE SUBTEST COUNTER*/

  V.subtest = 0;



  /*----------*/



  /*+INITIALIZE "THE NO RESULT" RESULT*/

  V.the_no_result.Measurement_class = CLASS_BOOLEAN;

  V.the_no_result.UU.Boolean_result = false;



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is__("Black on white, vth_write A then B", &V);

  interleave_write_drive__("a", BLACK, "b", WHITE, &V);

  interleave_write_receive__("a", BLACK, "b", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive__("a", BLACK, &V);

  expect_drive__("b", WHITE, &V);

  expect_receive__("a", BLACK, &V);

  expect_receive__("b", WHITE, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "A" AND "B"*/

  the_pattern_is__("White on black, vth_write A then B", &V);

  interleave_write_drive__("a", WHITE, "b", BLACK, &V);

  interleave_write_receive__("a", WHITE, "b", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive__("a", WHITE, &V);

  expect_drive__("b", BLACK, &V);

  expect_receive__("a", WHITE, &V);

  expect_receive__("b", BLACK, &V);



  /*----------*/



  /*+WRITE "BLACK ON WHITE" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is__("Black on white, vth_write B then A", &V);

  interleave_write_drive__("b", BLACK, "a", WHITE, &V);

  interleave_write_receive__("b", BLACK, "a", WHITE, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive__("a", WHITE, &V);

  expect_drive__("b", BLACK, &V);

  expect_receive__("a", WHITE, &V);

  expect_receive__("b", BLACK, &V);



  /*----------*/



  /*+WRITE "WHITE ON BLACK" PATTERNS TO REGS. "B" AND "A"*/

  the_pattern_is__("White on black, vth_write B then A", &V);

  interleave_write_drive__("b", WHITE, "a", BLACK, &V);

  interleave_write_receive__("b", WHITE, "a", BLACK, &V);



  /*+READ AND CHECK THE REGS.*/

  expect_drive__("a", BLACK, &V);

  expect_drive__("b", WHITE, &V);

  expect_receive__("a", BLACK, &V);

  expect_receive__("b", WHITE, &V);



  /*----------*/



  /*+RESET THE MODULE TO A KNOWN STATE*/

  vth_mod_init_dgn(V.mod_id);

}

#undef WHITE

#undef BLACK

#undef DRIVE_WRITE_MASK

#undef DRIVE_READ_MASK

#undef RECEIVE_WRITE_MASK

#undef RECEIVE_READ_MASK

#undef MIN_DRIVE_CHAN

#undef MAX_DRIVE_CHAN

#undef MIN_RECEIVE_CHAN

#undef MAX_RECEIVE_CHAN



//------------------------------------------------------------------------------

//buzz_that_relay_9188

//

//This test measure the relay resistance pass by t9189

//It take 5 measurement and find the difference between the max and min

//

//------------------------------------------------------------------------------



#define NUM_LOOPS       10   /* buzz loops/relay */

typedef int loop_type__;

/* #define PRECLOSURES     5 */



/* static variables for t9188: */

struct LOC_t9188

{

  int mod_id;

  int slot;

} ;



static void buzz_that_relay_9188(int relay, struct LOC_t9188 * LINK)

{

	test_result_type resultBuzz;

	double aryResult[NUM_LOOPS+1], dblMax, dblMin;

	loop_type__ bloop;



	for (bloop = 1; bloop <= NUM_LOOPS; bloop++)

	{  /* for bloop */

		vth_aclose_rly(LINK->mod_id, K820);

		vth_rlc_setup(LINK->mod_id,

					  0,      /* 0=DC, 128=128Hz, 1024=1024Hz, 8192=8192Hz */

					  0.1,    /* 0.0 to +/-10.0 Volts (DC), 0.0 to 7.0 Volts RMS (AC)*/

					  0.0,    /* 0.0 to +/-10.0 (depends on SRC_AMP) Volts (DC) */

					  0.001,  /* 0.0 to 10.0 seconds */

					  1,      /* 0=30mA, 1=150mA */

					  0,      /* 0=no en, 1=en */

					  0,      /* 0=no ed, 1=ed */

					  1,      /* 1=10ohms, 2=100ohms, 3=1Kohms, 4=10Kohms, 5=100Kohms, 6=1Mohms */

					  0,      /* 0=no sa, 1=sa */

					  0,      /* 0=no sb, 1=sb */

					  0,      /* 0=no sl, 1=sl */

					  0,      /* 0=narrowband, 1=wideband */

					  0,      /* 0=not used */

					  0,      /* 0=single ended, 1=differential NOT IMPLEMENTED */

					  -5.0,   /* expected MOA output voltage */

					  0.001); /* 0.0 to 1.0 seconds */

		vth_aopen_rly(LINK->mod_id, K814);

		vth_mtmr_wait(LINK->mod_id, 0.2e-3);

		vth_aclose_rly(LINK->mod_id, K813);   /*connect DETLO with I bus*/

		vth_aclose_rly(LINK->mod_id, K816);   /*connect G bus with I bus*/

		vth_mtmr_wait(LINK->mod_id, 0.2e-3);



		vth_popen_rly(LINK->mod_id, LINK->slot, relay);

		vth_mtmr_wait(LINK->mod_id, 0.08e-3);

		vth_pclose_rly(LINK->mod_id, LINK->slot, relay);

		vth_mtmr_wait(LINK->mod_id, 0.08e-3);



		vth_mtmr_wait(LINK->mod_id, 2.0e-3);

		vth_resistor_meas(LINK->mod_id, 0, 1);

		vth_get_abs_resistor_result(LINK->mod_id);

	}  /* for bloop */



	get_result_nolog(LINK->mod_id, &resultBuzz);

	aryResult[1] = resultBuzz.UU.Real_result;

	dblMax = dblMin = aryResult[1];

	for (int i=2; i<=NUM_LOOPS; i++)

	{

		get_result_nolog(LINK->mod_id, &resultBuzz);

		aryResult[i] = resultBuzz.UU.Real_result;

		if (aryResult[i] > dblMax)

			dblMax = aryResult[i];

		else if (aryResult[i] < dblMin)

			dblMin = aryResult[i];

	}

	resultBuzz.UU.Real_result = dblMax - dblMin;

	log_result(LINK->mod_id, resultBuzz);



}

/* buzz_that_relay */



//------------------------------------------------------------------------------

//t9188

//

//This test combines test9189 (relay close measurement) with AnalyzeBuzz script

//It uses buzz_that_relay_9188 function.

//

//------------------------------------------------------------------------------

void t9188(int mod_id, int slot)

{



	struct LOC_t9188 V;

	int mux;

	int channel;

	boolean virgin_card;

	boolean virgin_channel;

	int card_type=0;



	V.mod_id = mod_id;

	V.slot = slot;



	card_type = get_testhead_actual_card(V.mod_id, V.slot);

	/* determine if card is caribou and put in compatibility mode */

	if ((card_type == CDDP) || (card_type == CDD20) ||

	(card_type == CDD6) || (card_type == CDDJB) ||

	(card_type == CDDU))

		vth_pdis_32chan(V.mod_id, V.slot);



	/*PIN relay exercise*/

	display_prompt("extra loop", true);



	buzz_prelays(V.mod_id, V.slot);



	/*initialization*/

	vth_aunpowered_init(V.mod_id);

	vth_ameas_set_averaging(V.mod_id, 1);



	virgin_card = true;



	/*setup XL and XG bus relays*/

	vth_pclose_rly(V.mod_id, V.slot, KDCG);

	vth_pclose_rly(V.mod_id, V.slot, KDCL);

	vth_aclose_rly(V.mod_id, K753);   /*connect L bus with mother board*/

	vth_aclose_rly(V.mod_id, K752);   /*connect G bus with XG bus*/

	vth_aclose_rly(V.mod_id, K754);   /*connect L bus with XL bus*/



	for (channel = 'A'; channel <= 'H'; channel++)

	{  /*of for channel*/

		virgin_channel = true;

		/*close PIN card under test relays*/

		vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

		vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

		vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



		/*setup AIM - SUBMUX S bus connection with Xn bus*/

		vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);



		for (mux = 0; mux <= 8; mux++)   /*for each mux node relay pair */

		{  /* for mux */

			/*setup AIM relays*/

			vth_aclose_rly(V.mod_id, K820);   /*connect L bus with DETLO*/



			/*close PIN card under test relays*/

			vth_pclose_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

			vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



			if (virgin_card)

			{  /* buzz once per card relays */

				buzz_that_relay_9188(KDCG, &V);

				buzz_that_relay_9188(KDCL, &V);

				virgin_card = false;

			}  /* buzz once per card relays */



			if (virgin_channel)

			{  /* buzz once per channel relays */

				buzz_that_relay_9188(PIN_KDC_RLYS[channel - 'A'], &V);

				buzz_that_relay_9188(PIN_KX_RLYS[channel - 'A'], &V);

				buzz_that_relay_9188(PIN_KGL_RLYS[channel - 'A'], &V);

				virgin_channel = false;

			}  /* buzz once per channel relays */



			if (mux == 6)

			{ /* buzz muxing relays in case card is caribou */

				buzz_that_relay_9188(PIN_KX_RLYS[channel - 'A'], &V);

				buzz_that_relay_9188(PIN_KGL_RLYS[channel - 'A'], &V);

			}



			buzz_that_relay_9188(PIN_DRVR_RLYS[mux][channel - 'A'], &V);

			buzz_that_relay_9188(PIN_RCVR_RLYS[mux][channel - 'A'], &V);



			vth_popen_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

			vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



		}  /* for mux */



		/*initialize all PIN and AIM relays*/

		vth_aopen_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);

		vth_popen_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

		vth_popen_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

		vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



	}  /*for channel*/



	vth_popen_all_rlys(V.mod_id, V.slot);



}  /* t9188 */

#undef NUM_LOOPS





#define NUM_LOOPS       10   /* buzz loops/relay */

/* #define PRECLOSURES     5 */



/* static variables for t9189: */

struct LOC_t9189

{

  int mod_id;

  int slot;

} ;



static void buzz_that_relay__(int relay, struct LOC_t9189 * LINK)

{



  loop_type__ bloop;





  for (bloop = 1; bloop <= NUM_LOOPS; bloop++)

  {  /* for bloop */

    vth_aclose_rly(LINK->mod_id, K820);

    vth_rlc_setup(LINK->mod_id, 0, 0.1, 0.0, 0.001, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,

              -5.0, 0.001);



       //old??vth_rlc_setup(mod_id, 0, 0.1, 0, 0.001, 1, 1, 0, 2, 0, 0, 0, 0, 0, 0,

       //        -5.0, 0.001);



    vth_aopen_rly(LINK->mod_id, K814);

    vth_mtmr_wait(LINK->mod_id, 0.2e-3);



    vth_aclose_rly(LINK->mod_id, K813);   /*connect DETLO with I bus*/

    vth_aclose_rly(LINK->mod_id, K816);   /*connect G bus with I bus*/

    vth_mtmr_wait(LINK->mod_id, 0.2e-3);



/* This pre-close section was commented out 7/1/99 per WA's investigation

   of potentially false failures of buzz relays.  OK'ed with Dave Crook.

   -- mjs

   Fixed this to actually open close relay once each loop instead of not

   opening/closing it at all  10/19/99 --gpm

*/



//     for (int extra_loop = 1; extra_loop <= PRECLOSURES; extra_loop++)

//    {



      vth_popen_rly(LINK->mod_id, LINK->slot, relay);

      vth_mtmr_wait(LINK->mod_id, 0.08e-3);

      vth_pclose_rly(LINK->mod_id, LINK->slot, relay);

      vth_mtmr_wait(LINK->mod_id, 0.08e-3);

//    }





    vth_mtmr_wait(LINK->mod_id, 2.0e-3);

    vth_resistor_meas(LINK->mod_id, 0, 1);

    vth_get_abs_resistor_result(LINK->mod_id);

  }  /* for bloop */



}  /* buzz_that_relay */

/* #undef PRECLOSURES */



//------------------------------------------------------------------------------

void t9189(int mod_id, int slot)

{

  /* Buzz test for relays */



  /* Modified version of buzz t9188.  This version adds a pre-buzz loop */

  /* before each measurement is taken.  8-22-94 Wally Austin */



  /*From t3240 in DGN ~/sccs/dgn/src/tests/mt3000.p , modified to replace */

  /*buzz testing in production JRM - 11/18/92*/

  /*This is prepared for the test with/without CD fixture. If this test was failed*/

  /*without CD fixture, the driver relay or kgl will also be suspected.*/



  /*isolates mint relays on the receiver -- 72 relays total*/

  /*assumption = t3210(kxn and kdcn relays test) tested good*/



  /* adding functionality for Caribou -- Greg M 12-22-99 */



struct LOC_t9189 V;

int mux;

int channel;

boolean virgin_card;

boolean virgin_channel;

int card_type=0;



  V.mod_id = mod_id;

  V.slot = slot;



  card_type = get_testhead_actual_card(V.mod_id, V.slot);

  /* determine if card is caribou and put in compatibility mode */

  if ((card_type == CDDP) || (card_type == CDD20) ||

      (card_type == CDD6) || (card_type == CDDJB) ||

      (card_type == CDDU))

    vth_pdis_32chan(V.mod_id, V.slot);



  /*PIN relay exercise*/

  display_prompt("extra loop", true);



  buzz_prelays(V.mod_id, V.slot);





/////////////prebuzz KDCG //////////////////////////

   int warm_up;

   int warm_up_loops;

   warm_up_loops = 10;





	for(warm_up = 1; warm_up<= warm_up_loops; warm_up++) ///relay warm up routine

	{

      vth_popen_rly(mod_id, slot, KDCG);

      vth_mtmr_wait(mod_id, 0.08e-3);

      vth_pclose_rly(mod_id, slot, KDCG);

      vth_mtmr_wait(mod_id, 0.08e-3);

	  display_prompt("Pre Buzz KDCG", true);

	}

//////////////////////////////////////////////





  /*initialization*/

  vth_aunpowered_init(V.mod_id);

  vth_ameas_set_averaging(V.mod_id, 1);



  virgin_card = true;



  /*setup XL and XG bus relays*/

  vth_pclose_rly(V.mod_id, V.slot, KDCG);

  vth_pclose_rly(V.mod_id, V.slot, KDCL);

  vth_aclose_rly(V.mod_id, K753);   /*connect L bus with mother board*/

  vth_aclose_rly(V.mod_id, K752);   /*connect G bus with XG bus*/

  vth_aclose_rly(V.mod_id, K754);   /*connect L bus with XL bus*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*of for channel*/

    virgin_channel = true;

    /*close PIN card under test relays*/

    vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



    /*setup AIM - SUBMUX S bus connection with Xn bus*/

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);



    for (mux = 0; mux <= 8; mux++)   /*for each mux node relay pair */

    {  /* for mux */

      /*setup AIM relays*/

      vth_aclose_rly(V.mod_id, K820);   /*connect L bus with DETLO*/



      /*close PIN card under test relays*/

      vth_pclose_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



      if (virgin_card)

      {  /* buzz once per card relays */

        buzz_that_relay__(KDCG, &V);

        buzz_that_relay__(KDCL, &V);

        virgin_card = false;

      }  /* buzz once per card relays */



      if (virgin_channel)

      {  /* buzz once per channel relays */

        buzz_that_relay__(PIN_KDC_RLYS[channel - 'A'], &V);

        buzz_that_relay__(PIN_KX_RLYS[channel - 'A'], &V);

        buzz_that_relay__(PIN_KGL_RLYS[channel - 'A'], &V);

        virgin_channel = false;

      }  /* buzz once per channel relays */



      if (mux == 6)

      { /* buzz muxing relays in case card is caribou */

        buzz_that_relay__(PIN_KX_RLYS[channel - 'A'], &V);

        buzz_that_relay__(PIN_KGL_RLYS[channel - 'A'], &V);

      }



      buzz_that_relay__(PIN_DRVR_RLYS[mux][channel - 'A'], &V);

      buzz_that_relay__(PIN_RCVR_RLYS[mux][channel - 'A'], &V);



      vth_popen_rly(V.mod_id, V.slot, PIN_DRVR_RLYS[mux][channel - 'A']);

      vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mux][channel - 'A']);



    }  /* for mux */



    /*initialize all PIN and AIM relays*/

    vth_aopen_rly(V.mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KDC_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KX_RLYS[channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[channel - 'A']);



  }  /*for channel*/



  vth_popen_all_rlys(V.mod_id, V.slot);



}  /* t9189 */

#undef NUM_LOOPS



#define NON_INVERTED    0

#define INVERTED        1

typedef double delay_array__[2];

#define PROBE_NUMBER    1

#define LINKS_TO_MASTER  0

/*V/uS*/

#define SLEW_RATE       225

#define TCLK_FREQ       5.0e+06

/* same as tclk */

#define GEN_LOW_UNTERMINATED  0.1e+00

#define GEN_LOW_TERMINATED  0.2e+00

#define GEN_HIGH_UNTERMINATED  1.75e+00

#define GEN_HIGH_TERMINATED  3.5e+00

#define PROBE_SPEC      8e-09

#define TIMEOUT         1.0e-03

#define STOP_WAIT       100e-03

#define PROBE_THRESHOLD  1.5e+00

const delay_array__ PROG_DELAY__ = {100e-09, -29e-09};

#define RES             1.0e-09



/* static variables for t9191: */

struct LOC_t9191

{

  int mod_id;

  int value;

  double gen_delay;

  boolean exit_variable;

  test_result_type result;

} ;



/* ----------------------------------------------------------------------- */

static void sample_(struct LOC_t9191 * LINK)

{

  int mod_id = LINK->mod_id;



  setup_gen_trg_out_delay(LINK->mod_id, LINK->gen_delay);

  enable_gen_out(LINK->mod_id);

  sales_reset_sequencer_aim(LINK->mod_id);



  if (LINK->value == 1)

    {

#include "t9191_d100.cmd"

    }

  else

    {

#include "t9191_dn30.cmd"

    }



  sales_start_sequencer_mac(LINK->mod_id);

  vth_mseq_wait_on_stop(LINK->mod_id, STOP_WAIT);

  vth_mseq_stop(LINK->mod_id, TIMEOUT);



  vth_mmbd_rd_arcv1(LINK->mod_id);   /* check WERR */

  if (get_result_nolog(LINK->mod_id, &LINK->result))

  {

    if (LINK->result.UU.Integer_result != 1)

    {   /* no WERR */

      vth_mmbd_rd_arcv0(LINK->mod_id);

      if (get_result_nolog(LINK->mod_id, &LINK->result))

      {

        if (LINK->result.UU.Integer_result == 1)

          LINK->exit_variable = true;

        else

          LINK->exit_variable = false;

      }

    }

  }

}  /* sample */



//------------------------------------------------------------------------------

//This is an evaluation test not performed for production mass pro testing. Not fully verified.Mark.JJ//



void t9191(void)

{

  /*Probe Edge Accuracy and Skew*/

  struct LOC_t9191 V;

  double delay_inc;

  double direction;

  double transition_time;

  double period;

  double expected_receive;

  double actual_receive;

  double cal_min_set;

  double cal_max_set;

  double cal_min_actual;

  double cal_max_actual;

  double probe_range;

  double skew;

  double offset[2];

  double gain[2];

  double probe_result[2];

  boolean expected_response;

  boolean found;

  boolean hit;

  int loop;

  int probe_connect_module;



  /* ----------------------------------------------------------------------- */

  probe_connect_module = get_system_probe_location();

  V.mod_id = probe_connect_module;

  vth_mod_init_dgn(V.mod_id);

  present_test[V.mod_id - NO_TESTHEAD_NUMBER] = 9191;

  present_test_type[V.mod_id - NO_TESTHEAD_NUMBER] = SINGLE_MODULE_SINGLE_SLOT;

  present_slot[V.mod_id - NO_TESTHEAD_NUMBER] = 1;

  present_subtest[V.mod_id - NO_TESTHEAD_NUMBER] = 0;

  if (V.mod_id < 0 || V.mod_id > 3)

  {  /* Display wrong  configuration error message */

    display_prompt("Configuration in error.  Cannot find a module", true);

    display_prompt("that is connected to the probe.", true);

  }  /* Display wrong configuration error message */

  else

  {  /* Do the test */

	OpenResourceManager(); //added by chuanho, 18jul2011

	open_33250A(V.mod_id);

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
  {
    enable_33250A_out(V.mod_id);
	setup_33250A_defaults(V.mod_id);
  }
  else
    open_syn(V.mod_id);
  /*--------------------------------------------*/

    open_gen(V.mod_id);

	//open_mux(V.mod_id);
	open_34980A(V.mod_id);

    open_cntr(V.mod_id);

    period = 1 / TCLK_FREQ;

    probe_range = 2.0 * PROBE_SPEC;

    transition_time = (GEN_HIGH_TERMINATED - GEN_LOW_TERMINATED) * 0.8 * 1e-06/ SLEW_RATE;

    for (V.value = 1; V.value <= 2; V.value++)

    {

      expected_receive = PROG_DELAY__[V.value - 1];



      if (V.value == 2)   /* -30nS receives in the next period */

        expected_receive += period;





      cal_min_set = expected_receive + probe_clkrb_delay[V.mod_id] - probe_range;

      cal_max_set = expected_receive + probe_clkrb_delay[V.mod_id] + probe_range;

      //display_it(V.mod_id, "cal_min_set = ", 0, cal_min_set);

      //display_it(V.mod_id, "cal_max_set = ", 0, cal_max_set);

      cal_min_set = static_cast<int>(cal_min_set * 1e9) / 1e9;

      cal_max_set = static_cast<int>(cal_max_set * 1e9) / 1e9;



      //display_it(V.mod_id, "expected_receive = ", 0, expected_receive);

      //display_it(V.mod_id, "probe_clkrb_delay = ", 0, probe_clkrb_delay[V.mod_id]);

      //display_it(V.mod_id, "probe_range = ", 0, probe_range);

      //display_it(V.mod_id, "cal_min_set = ", 0, cal_min_set);

      //display_it(V.mod_id, "cal_max_set = ", 0, cal_max_set);

      connect_syn_out_gen_ext(V.mod_id);

      connect_gen_trg_cntr_start(V.mod_id);

      connect_gen_out_cntr_stop(V.mod_id);

      setup_gen_levels(V.mod_id, GEN_LOW_TERMINATED, GEN_HIGH_TERMINATED);

      setup_gen_transition_times(V.mod_id, transition_time);

      no_complement_gen_out(V.mod_id);

      setup_cntr_trigger_slopes(V.mod_id, POS, POS);



      for (loop = NON_INVERTED; loop <= INVERTED; ++loop)

      {  /* Measure the offset and gain for pos and neg generator output */

        setup_gen_trg_out_delay(V.mod_id, cal_min_set);

        enable_gen_out(V.mod_id);

        show_value(V.mod_id, "delay ", cal_min_set);

        //display_it(V.mod_id, "delay = ", 0, cal_min_set);

        trigger_cntr(V.mod_id);

        cal_min_actual = read_cntr_mean(V.mod_id);

        if (cal_min_actual < period / 10)

          cal_min_actual += period;



      //display_it(V.mod_id, "*cal_min_actual = ", 0, cal_min_actual);



        setup_gen_trg_out_delay(V.mod_id, cal_max_set);

        show_value(V.mod_id, "delay ", cal_max_set);

        //display_it(V.mod_id, "delay = ", 0, cal_max_set);

        trigger_cntr(V.mod_id);

        cal_max_actual = read_cntr_mean(V.mod_id);

        if (cal_max_actual < period / 10)

          cal_max_actual += period;

      //display_it(V.mod_id, "*cal_max_actual = ", 0, cal_max_actual);



        disable_gen_out(V.mod_id);

        offset[loop] = cal_min_actual;

        gain[loop] = (cal_max_actual - cal_min_actual) /

                     (cal_max_set - cal_min_set);

        complement_gen_out(V.mod_id);

        setup_cntr_trigger_slopes(V.mod_id, POS, NEG);

      }  /* Measure the offset and gain for pos and neg generator output */



      setup_gen_levels(V.mod_id, GEN_LOW_UNTERMINATED, GEN_HIGH_UNTERMINATED);

      connect_gen_trg_clkrb(V.mod_id);

      connect_gen_out_probe(V.mod_id);

      vth_mclose_rly(V.mod_id, MK2902);   /* clkrb path relay */

      vth_mclose_rly(V.mod_id, MK2903);   /* clkrsg path relay */

      vth_aclose_rly(V.mod_id, K2203);   /* probe in relay */

      vth_mtclk_clkrb_mux(V.mod_id);

      vth_mtclk_sel_ris_edge(V.mod_id);

      vth_mtclk_set_freq(V.mod_id, TCLK_FREQ, TCLK_FREQ);

      vth_mtclk_set_cal_adv_time(V.mod_id, LINKS_TO_MASTER);

      vth_mmbd_en_arcv(V.mod_id);

      vth_aarcv0_en(V.mod_id);

      vth_aarcv1_en(V.mod_id);

      vth_afc_gt1_prb(V.mod_id);

      vth_afc_en(V.mod_id);

      vth_aprbhi_set_trg_lvl(V.mod_id, PROBE_THRESHOLD);

      vth_aprblo_set_trg_lvl(V.mod_id, PROBE_THRESHOLD);

      vth_afc_sel_arcv0(V.mod_id, PROBE_NUMBER, 3);   /* ARCV0 = RRESP */

      vth_afc_sel_arcv1(V.mod_id, PROBE_NUMBER, 4);   /* ARCV1 = WERR  */



      for (loop = NON_INVERTED; loop <= INVERTED; ++loop)

      {  /* for loop */

        if (loop == NON_INVERTED)

        {

          no_complement_gen_out(V.mod_id);

          expected_response = true;

        }

        else

        {

          complement_gen_out(V.mod_id);

          expected_response = false;

        }



        delay_inc = 4.0e-9;

        direction = 0.0;

        hit = false;

        found = false;

        V.gen_delay = expected_receive + probe_clkrb_delay[V.mod_id];

        do

        {

          sample_(&V);

          show_value(V.mod_id, "gen delay", V.gen_delay);

          //display_it(V.mod_id, "gen_delay = ", 0, V.gen_delay);



          if (V.exit_variable == expected_response)

          {  /* delay too small */

            if (direction < 0)

              hit = true;

            direction = 1.0;

          }

          else

          {

            if (direction > 0)

              hit = true;

            direction = -1.0;

          }

          if (hit)

          {

            delay_inc /= 2;

            if (delay_inc <= RES / 2)

              found = true;

          }

          V.gen_delay += delay_inc * direction;

        } while (!(found || V.gen_delay < cal_min_set ||

                   V.gen_delay > cal_max_set));



        actual_receive = gain[loop] * (V.gen_delay - cal_min_set) +

                         offset[loop] - probe_clkrb_delay[V.mod_id];

       // display_it(V.mod_id, "actual_receive              = ", 0, actual_receive);

       //display_it(V.mod_id, "gain[loop]                  = ", 0, gain[loop]);

       // display_it(V.mod_id, "V.gen_delay                 = ", 0, V.gen_delay);

       // display_it(V.mod_id, "cal_min_set                 = ", 0, cal_min_set);

       // display_it(V.mod_id, "offset[loop]                = ", 0, offset[loop]);

       // display_it(V.mod_id, "probe_clkrb_delay[V.mod_id] = ", 0, probe_clkrb_delay[V.mod_id]);

        show_value(V.mod_id, "actual rec", actual_receive);

        show_value(V.mod_id, "expected rec", expected_receive);



        probe_result[loop] = actual_receive - expected_receive;

       // display_it(V.mod_id, "probe_result = ", 0, probe_result[loop]);

       // display_it(V.mod_id, "expected_receive = ", 0, expected_receive);

       // display_it(V.mod_id, "actual_receive              = ", 0, actual_receive);

        V.result.Measurement_class = CLASS_REAL;

        if (!found)

        {   /* it never received */

          probe_result[loop] = INT_MAX;

          display_prompt("*RECEIVE DOES NOT OCCUR WITHIN TEST RANGE*", true);

        }

        V.result.UU.Real_result = probe_result[loop];

        log_result(V.mod_id, V.result);

      }  /* for loop */

      disable_gen_out(V.mod_id);

      skew = probe_result[NON_INVERTED] - probe_result[INVERTED];

      V.result.UU.Real_result = skew;

      log_result(V.mod_id, V.result);

    }  /* for value */

  /*Added by chuanho to select syn model, 15jun2012*/
  /*--------------------------------------------*/
  if(check_syn_model())
    close_33250A(V.mod_id);
  else
    close_syn(V.mod_id);
  /*--------------------------------------------*/

    close_gen(V.mod_id);

    close_34980A(V.mod_id);//close_mux(V.mod_id);

    close_cntr(V.mod_id);

	CloseResourceManager(); //added by fikri, 25062024

  }  /* Do the test */



}  /* t9191 */

#undef NON_INVERTED

#undef INVERTED

#undef PROBE_NUMBER

#undef LINKS_TO_MASTER

#undef SLEW_RATE

#undef TCLK_FREQ

#undef GEN_LOW_UNTERMINATED

#undef GEN_LOW_TERMINATED

#undef GEN_HIGH_UNTERMINATED

#undef GEN_HIGH_TERMINATED

#undef PROBE_SPEC

#undef TIMEOUT

#undef STOP_WAIT

#undef PROBE_THRESHOLD

#undef RES



#define PROBE_NUMBER    1

#define RANGE           30

#define RESOLUTION      0.001e+00

#define MAX_VOLTAGE     5.400e+00

#define MIN_VOLTAGE     4.600e+00

#define STARTING_STEP_SIZE  0.064e+00

/*DC souce resolution = 4.98mV*/

#define FINEST_INCREMENT  0.004e+00

#define EXPECTED_RECEIVE_LVL  5.000e+00

#define DMM_FUNCTION    DCV

#define HI              0

#define LO              1

//------------------------------------------------------------------------------

void t9195(void)

{

  /*Probe DC Voltage Accuracy and Range*/

  int search_level;

  int mod_id;



  double probe_voltage;

  double no_trip_voltage;

  double voltage_increment;

  double stop_voltage;

  double skew;



  double probe_result[2][2];



  boolean search_level_found;



  int gt;

  test_result_type result;

  int probe_connect_module;



  probe_connect_module = get_system_probe_location();

  mod_id = probe_connect_module;

  vth_mod_init_dgn(mod_id);



  present_test[mod_id - NO_TESTHEAD_NUMBER] = 9195;

  present_test_type[mod_id - NO_TESTHEAD_NUMBER] = SINGLE_MODULE_SINGLE_SLOT;

  present_slot[mod_id - NO_TESTHEAD_NUMBER] = 1;

  present_subtest[mod_id - NO_TESTHEAD_NUMBER] = 0;

  if (mod_id < 0 || mod_id > 3)

  {  /* Display wrong configuration error message */

    display_prompt("Configuration in error.  Cannot find a module", true);

    display_prompt("that is connected to the probe.", true);

  }  /* Display wrong configuration error message */

  else

  {  /* Do the test */

    OpenResourceManager();
    open_dmm(mod_id);

	//open_mux(mod_id);
	open_34980A(mod_id);



    setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

    connect_dmm_probe(mod_id);



    vth_aclose_rly(mod_id, K806);   /* aim source resistor connect */

    vth_aclose_rly(mod_id, K2201);   /* S bus to PROBS */

    vth_aclose_rly(mod_id, PROBR);   /* probe tip relay */

    vth_aclose_rly(mod_id, K2203);   /* probe_in relay */

  flush_commands(mod_id); //fikri added 19/06/2024


    /* SETUP AIM SOURCE */

    vth_asrc_dis_30ma_ilim(mod_id);

    vth_afc_en_src_out(mod_id);

  flush_commands(mod_id); //fikri added 19/06/2024


    vth_afc_gt1_prb(mod_id);

    vth_afc_en(mod_id);

  flush_commands(mod_id); //fikri added 19/06/2024


    vth_mmbd_en_arcv(mod_id);   /* Enable ARCV lines onto MAC */

    vth_aarcv0_en(mod_id);   /* Enable ARCV0 line off AIM */

    vth_aarcv1_en(mod_id);   /* Enable ARCV1 line off AIM */

    vth_afc_sel_arcv0(mod_id, PROBE_NUMBER, 0);   /* ARCV0 = GTL */

    vth_afc_sel_arcv1(mod_id, PROBE_NUMBER, 1);   /* ARCV1 = GTH */

  flush_commands(mod_id); //fikri added 19/06/2024


    vth_aprbhi_set_trg_lvl(mod_id, EXPECTED_RECEIVE_LVL);

    vth_aprblo_set_trg_lvl(mod_id, EXPECTED_RECEIVE_LVL);

  flush_commands(mod_id); //fikri added 19/06/2024


    for (gt = HI; gt <= LO; ++gt)

    {  /* SEARCH GTH,GTL FOR FIRST LOW WHILE DECREASING THROUGH THRESHOLD */

      search_level = 0;

      search_level_found = false;

      voltage_increment = STARTING_STEP_SIZE;

      probe_voltage = MAX_VOLTAGE;

      no_trip_voltage = MAX_VOLTAGE;

      vth_asrc_set_dc_ampl(mod_id, probe_voltage);

      stop_voltage = MIN_VOLTAGE;

  flush_commands(mod_id); //fikri added 19/06/2024


      while (!search_level_found && probe_voltage >= stop_voltage)

      {  /*search for GTH tranistion*/

        if (gt == HI)

          vth_mmbd_rd_arcv1(mod_id);

        else

          vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_nolog(mod_id, &result))

        {  /*process this result*/

          display_prompt("No result in result log (Expected ARCV)", true);

          continue;

        }  /*process this result*/

        if (result.UU.Integer_result != search_level)

        {  /*search_level is found*/

          probe_voltage -= voltage_increment;

          vth_asrc_set_dc_ampl(mod_id, probe_voltage);

          vth_mtmr_wait(mod_id, 0.001);

          continue;

        }  /*search_level is found*/

        search_level_found = true;

        if (voltage_increment <= FINEST_INCREMENT)

        {  /*decrease the increment over a limited range*/

          continue;

        }  /*decrease the increment over a limited range*/

        search_level_found = false;

        vth_asrc_set_dc_ampl(mod_id, no_trip_voltage);

        vth_mtmr_wait(mod_id, 0.001);

        probe_voltage += voltage_increment;

        voltage_increment /= 2;

        vth_asrc_set_dc_ampl(mod_id, probe_voltage);

        vth_mtmr_wait(mod_id, 0.001);

      }  /*search for probe receive*/



      if (search_level_found)

      {  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

     flush_commands(mod_id); //fikri added 19/06/2024
     measure_dmm(mod_id);





		//Added for NASRU offset 0.1V//

        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

             	////NASRU offset///////

				int card = get_testhead_actual_card(mod_id, 1);



				switch (card)

				{

				case NASRU:

			    result.UU.Real_result -= 0.1;

				break;

				}

			    ///////////////////////

			probe_result[gt][search_level] = result.UU.Real_result;

			log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log. Expected DMM reading",

                         true);

	  }  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

      else

      {  /*IT NEVER RECEIVED*/

        probe_result[gt][search_level] = MIN_VOLTAGE;

        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = probe_result[gt][search_level];

        log_result(mod_id, result);

      }  /*IT NEVER RECEIVED*/



    }  /* SEARCH GTH,GTL FOR FIRST LOW WHILE DECREASING THROUGH THRESHOLD */



    for (gt = HI; gt <= LO; ++gt)

    {  /* SEARCH GTH,GTL FOR FIRST HIGH WHILE INCREASING THROUGH THRESHOLD */

      search_level = 1;

      search_level_found = false;

      voltage_increment = STARTING_STEP_SIZE;

      probe_voltage = MIN_VOLTAGE;

      no_trip_voltage = MIN_VOLTAGE;

      vth_asrc_set_dc_ampl(mod_id, probe_voltage);

      stop_voltage = MAX_VOLTAGE;



      while (!search_level_found && probe_voltage <= stop_voltage)

      {  /*search for GTH tranistion*/

        if (gt == HI)

          vth_mmbd_rd_arcv1(mod_id);

        else

          vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_nolog(mod_id, &result))

        {  /*process this result*/

          display_prompt("No result in result log (Expected ARCV)", true);

          continue;

        }  /*process this result*/

        if (result.UU.Integer_result != search_level)

        {  /*search_level is found*/

          probe_voltage += voltage_increment;

          vth_asrc_set_dc_ampl(mod_id, probe_voltage);

          vth_mtmr_wait(mod_id, 0.001);

          continue;

        }  /*search_level is found*/

        search_level_found = true;

        if (voltage_increment <= FINEST_INCREMENT)

        {  /*decrease the increment over a limited range*/

          continue;

        }  /*decrease the increment over a limited range*/

        search_level_found = false;

        vth_asrc_set_dc_ampl(mod_id, no_trip_voltage);

        vth_mtmr_wait(mod_id, 0.001);

        probe_voltage -= voltage_increment;

        voltage_increment /= 2;

        vth_asrc_set_dc_ampl(mod_id, probe_voltage);

        vth_mtmr_wait(mod_id, 0.001);

      }  /*search for probe receive*/



      if (search_level_found)

      {  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

    flush_commands(mod_id); //fikri added 19/06/2024
      measure_dmm(mod_id);



		//Added for NASRU offset 0.1V//

        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */



		  ////NASRU offset///////

		  int card = get_testhead_actual_card(mod_id, 1);



		  switch (card)

		  {

		  case NASRU:

		  result.UU.Real_result -= 0.1;

		  break;

		  }

		  ///////////////////////



		  probe_result[gt][search_level] = result.UU.Real_result;

		  log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log. Expected DMM reading",

                         true);

      }  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

      else

      {  /*IT NEVER RECEIVED*/

        probe_result[gt][search_level] = MAX_VOLTAGE;

        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = probe_result[gt][search_level];

        log_result(mod_id, result);

      }  /*IT NEVER RECEIVED*/



    }  /*search for decreasing threshold, then increasing threshold*/



    for (gt = HI; gt <= LO; gt = (int)(gt + 1))

    {  /* calculate skew */

      skew = probe_result[gt][1] - probe_result[gt][0];

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = skew;

      log_result(mod_id, result);

    }  /* calculate skew */



    vth_ainit(mod_id);

    vth_minit(mod_id);



    close_dmm(mod_id);

    close_34980A(mod_id);//close_mux(mod_id);

    CloseResourceManager();

  }  /* Do the test */



  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

}  /* t9195 */

#undef PROBE_NUMBER

#undef RANGE

#undef RESOLUTION

#undef MAX_VOLTAGE

#undef MIN_VOLTAGE

#undef STARTING_STEP_SIZE

#undef FINEST_INCREMENT

#undef EXPECTED_RECEIVE_LVL

#undef DMM_FUNCTION

#undef HI

#undef LO



#define PROBE_NUMBER    1

#define RANGE           30

#define RESOLUTION      0.001e+00

#define MAX_VOLTAGE     (-3.10e+00)

#define MIN_VOLTAGE     (-3.90e+00)

#define STARTING_STEP_SIZE  0.064e+00

/*DC souce resolution = 4.98mV*/

#define FINEST_INCREMENT  0.004e+00

#define EXPECTED_RECEIVE_LVL  (-3.50e+00)

#define DMM_FUNCTION    DCV

#define HI              0

#define LO              1

//------------------------------------------------------------------------------

void t9196(void)

{

  /*Probe DC Voltage Accuracy and Range*/

  int search_level;

  int mod_id;



  double probe_voltage;

  double no_trip_voltage;

  double voltage_increment;

  double stop_voltage;

  double skew;



  double probe_result[2][2];



  boolean search_level_found;



int gt;

  test_result_type result;

int probe_connect_module;





  probe_connect_module = get_system_probe_location();

  mod_id = probe_connect_module;

  vth_mod_init_dgn(mod_id);



  present_test[mod_id - NO_TESTHEAD_NUMBER] = 9196;

  present_test_type[mod_id - NO_TESTHEAD_NUMBER] = SINGLE_MODULE_SINGLE_SLOT;

  present_slot[mod_id - NO_TESTHEAD_NUMBER] = 1;

  present_subtest[mod_id - NO_TESTHEAD_NUMBER] = 0;

  if (mod_id < 0 || mod_id > 3)

  {  /* Display wrong  configuration error message */

    display_prompt("Configuration in error.  Cannot find a module", true);

    display_prompt("that is connected to the probe.", true);

  }  /* Display wrong configuration error message */

  else

  {  /* Do the test */

    OpenResourceManager();
    open_dmm(mod_id);

	//open_mux(mod_id);
	open_34980A(mod_id);



    setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

    connect_dmm_probe(mod_id);



    vth_aclose_rly(mod_id, K806);   /* aim source resistor connect */

    vth_aclose_rly(mod_id, K2201);   /* S bus to PROBS */

    vth_aclose_rly(mod_id, PROBR);   /* probe tip relay */

    vth_aclose_rly(mod_id, K2203);   /* probe_in relay */



    /* SETUP AIM SOURCE */

    vth_asrc_dis_30ma_ilim(mod_id);

    vth_afc_en_src_out(mod_id);



    vth_afc_gt1_prb(mod_id);

    vth_afc_en(mod_id);



    vth_mmbd_en_arcv(mod_id);   /* Enable ARCV lines onto MAC */

    vth_aarcv0_en(mod_id);   /* Enable ARCV0 line off AIM */

    vth_aarcv1_en(mod_id);   /* Enable ARCV1 line off AIM */

    vth_afc_sel_arcv0(mod_id, PROBE_NUMBER, 0);   /* ARCV0 = GTL */

    vth_afc_sel_arcv1(mod_id, PROBE_NUMBER, 1);   /* ARCV1 = GTH */



    vth_aprbhi_set_trg_lvl(mod_id, EXPECTED_RECEIVE_LVL);

    vth_aprblo_set_trg_lvl(mod_id, EXPECTED_RECEIVE_LVL);



    for (gt = HI; gt <= LO; ++gt)

    {  /* SEARCH GTH,GTL FOR FIRST LOW WHILE DECREASING THROUGH THRESHOLD */

      search_level = 0;

      search_level_found = false;

      voltage_increment = STARTING_STEP_SIZE;

      probe_voltage = MAX_VOLTAGE;

      no_trip_voltage = MAX_VOLTAGE;

      vth_asrc_set_dc_ampl(mod_id, probe_voltage);

      stop_voltage = MIN_VOLTAGE;



      while (!search_level_found && probe_voltage >= stop_voltage)

      {  /*search for GTH tranistion*/

        if (gt == HI)

          vth_mmbd_rd_arcv1(mod_id);

        else

          vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_nolog(mod_id, &result))

        {  /*process this result*/

          display_prompt("No result in result log (Expected ARCV)", true);

          continue;

        }  /*process this result*/

        if (result.UU.Integer_result != search_level)

        {  /*search_level is found*/

          probe_voltage -= voltage_increment;

          vth_asrc_set_dc_ampl(mod_id, probe_voltage);

          vth_mtmr_wait(mod_id, 0.001);

          continue;

        }  /*search_level is found*/

        search_level_found = true;

        if (voltage_increment <= FINEST_INCREMENT)

        {  /*decrease the increment over a limited range*/

          continue;

        }  /*decrease the increment over a limited range*/

        search_level_found = false;

        vth_asrc_set_dc_ampl(mod_id, no_trip_voltage);

        vth_mtmr_wait(mod_id, 0.001);

        probe_voltage += voltage_increment;

        voltage_increment /= 2;

        vth_asrc_set_dc_ampl(mod_id, probe_voltage);

        vth_mtmr_wait(mod_id, 0.001);

      }  /*search for probe receive*/



      if (search_level_found)

      {  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

        measure_dmm(mod_id);

        	//Added for NASRU offset 0.1V//

        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */



		   ////NASRU offset///////

		  int card = get_testhead_actual_card(mod_id, 1);



		  switch (card)

		  {

		  case NASRU:

		  result.UU.Real_result -= 0.13;//;0.1;//increased to 0.13 from 0.1

		  break;

		  }

		  ///////////////////////





          probe_result[gt][search_level] = result.UU.Real_result;

		  log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log. Expected DMM reading",

                         true);

      }  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

      else

      {  /*IT NEVER RECEIVED*/

        probe_result[gt][search_level] = MIN_VOLTAGE;

        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = probe_result[gt][search_level];

        log_result(mod_id, result);

      }  /*IT NEVER RECEIVED*/



    }  /* SEARCH GTH,GTL FOR FIRST LOW WHILE DECREASING THROUGH THRESHOLD */



    for (gt = HI; gt <= LO; ++gt)

    {  /* SEARCH GTH,GTL FOR FIRST HIGH WHILE INCREASING THROUGH THRESHOLD */

      search_level = 1;

      search_level_found = false;

      voltage_increment = STARTING_STEP_SIZE;

      probe_voltage = MIN_VOLTAGE;

      no_trip_voltage = MIN_VOLTAGE;

      vth_asrc_set_dc_ampl(mod_id, probe_voltage);

      stop_voltage = MAX_VOLTAGE;



      while (!search_level_found && probe_voltage <= stop_voltage)

      {  /*search for GTH tranistion*/

        if (gt == HI)

          vth_mmbd_rd_arcv1(mod_id);

        else

          vth_mmbd_rd_arcv0(mod_id);

        if (!get_result_nolog(mod_id, &result))

        {  /*process this result*/

          display_prompt("No result in result log (Expected ARCV)", true);

          continue;

        }  /*process this result*/

        if (result.UU.Integer_result != search_level)

        {  /*search_level is found*/

          probe_voltage += voltage_increment;

          vth_asrc_set_dc_ampl(mod_id, probe_voltage);

          vth_mtmr_wait(mod_id, 0.001);

          continue;

        }  /*search_level is found*/

        search_level_found = true;

        if (voltage_increment <= FINEST_INCREMENT)

        {  /*decrease the increment over a limited range*/

          continue;

        }  /*decrease the increment over a limited range*/

        search_level_found = false;

        vth_asrc_set_dc_ampl(mod_id, no_trip_voltage);

        vth_mtmr_wait(mod_id, 0.001);

        probe_voltage -= voltage_increment;

        voltage_increment /= 2;

        vth_asrc_set_dc_ampl(mod_id, probe_voltage);

        vth_mtmr_wait(mod_id, 0.001);

      }  /*search for probe receive*/



      if (search_level_found)

      {  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

        measure_dmm(mod_id);

       	//Added for NASRU offset 0.1V//

        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */



		  ////NASRU offset///////

		  int card = get_testhead_actual_card(mod_id, 1);



		  switch (card)

		  {

		  case NASRU:

		  result.UU.Real_result -= 0.13;//;0.1;//increased to 0.13 from 0.1

		  break;

		  }

		  ///////////////////////





	      probe_result[gt][search_level] = result.UU.Real_result;

		  log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log. Expected DMM reading",

                         true);

      }  /*MEASURE THE VOLTAGE AT THE PROBE TIP*/

      else

      {  /*IT NEVER RECEIVED*/

        probe_result[gt][search_level] = MAX_VOLTAGE;

        result.Measurement_class = CLASS_REAL;

        result.UU.Real_result = probe_result[gt][search_level];

        log_result(mod_id, result);

      }  /*IT NEVER RECEIVED*/



    }  /*search for decreasing threshold, then increasing threshold*/



    for (gt = HI; gt <= LO; ++gt)

    {  /* calculate skew */

      skew = probe_result[gt][1] - probe_result[gt][0];

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = skew;

      log_result(mod_id, result);

    }  /* calculate skew */



    vth_ainit(mod_id);

    vth_minit(mod_id);



    close_dmm(mod_id);

    close_34980A(mod_id);//close_mux(mod_id);
    CloseResourceManager();
  }  /* Do the test */



  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

  /*Setup for next value of voltage*/

}  /* t9196 */

#undef PROBE_NUMBER

#undef RANGE

#undef RESOLUTION

#undef MAX_VOLTAGE

#undef MIN_VOLTAGE

#undef STARTING_STEP_SIZE

#undef FINEST_INCREMENT

#undef EXPECTED_RECEIVE_LVL

#undef DMM_FUNCTION

#undef HI

#undef LO





#define RANGE           3

#define WORST_SLOT      11   /* Highest Xn Bus Resistance */

#define RESOLUTION      1.0e-03

#define DGN_INFINITY    1e+31

#define OFFSET_OHMS_PER_SLOT  39e-03   /* Amount MB R per slot */

#define DMM_FUNCTION    FOUR_WIRE_OHMS

//------------------------------------------------------------------------------

void t9200(int mod_id, int slot)

{

  /* Series Xn Bus Resistance */

  double slot_correction;   /* Added to make worst case */

  int mux_node_pin;



  int channel;

  test_result_type result;



  vth_aopen_all_rlys(mod_id);

  vth_popen_all_rlys(mod_id, slot);

  vth_mtmr_wait(mod_id, 0.5);

  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);

  vth_mtmr_wait(mod_id, 0.5);



  OpenResourceManager();//chun 10032022

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_dmm(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  setup_dmm_ocomp_on(mod_id);



  connect_dmm(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    if ((channel & 1) == 1)

    {

      virt_card_select(mod_id, slot, 2);

      mux_node_pin = 7;   /* Channels A,C,E, and G */

    }

    else

    {

      virt_card_select(mod_id, slot, 0);

      mux_node_pin = 0;   /* Channels B,D,F, and H */

    }

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_MINT_RLYS[channel - 'A']);

  }  /*for*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    connect_minus_pin(mod_id, slot, channel, true);

    connect_4wire_plus_xn(mod_id, channel, true);

    vth_mtmr_wait(mod_id, 3);

    measure_dmm(mod_id);

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      if (fabs(result.UU.Real_result) > DGN_INFINITY)

        result.UU.Real_result = DGN_INFINITY - 1;

      /* Make all slots log vaules as if they were in slot 11 (Worst case) */

      slot_correction = (WORST_SLOT - slot) * OFFSET_OHMS_PER_SLOT;

      result.UU.Real_result += slot_correction;

      log_result(mod_id, result);

    }  /*if*/

    else

      display_prompt("No result in result log (Expected dmm R)", true);



    vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);



    connect_minus_pin(mod_id, slot, channel, false);



    connect_4wire_plus_xn(mod_id, channel, false);

  }  /*for*/



  vth_aopen_all_rlys(mod_id);

  vth_popen_all_rlys(mod_id, slot);

  vth_mtmr_wait(mod_id, 0.5);

  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);

  vth_mtmr_wait(mod_id, 0.5);



  close_34980A(mod_id);//close_mux(mod_id);

  close_dmm(mod_id);

  CloseResourceManager();//chun 10032022

}  /*t9200*/

#undef RANGE

#undef WORST_SLOT

#undef RESOLUTION

#undef DGN_INFINITY

#undef OFFSET_OHMS_PER_SLOT

#undef DMM_FUNCTION



#define CHANNEL         'A'

#define MUX_NODE_PIN    7

#define RANGE           3

#define RESOLUTION      1.0e-03

#define DGN_INFINITY    1e+31

#define DMM_FUNCTION    FOUR_WIRE_OHMS

//------------------------------------------------------------------------------

void t9201(int mod_id, int slot)

{

  /* Series XG Bus Resistance */

  test_result_type result;



  vth_aopen_all_rlys(mod_id);

  vth_popen_all_rlys(mod_id, slot);

  vth_mtmr_wait(mod_id, 0.5);

  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);

  vth_mtmr_wait(mod_id, 0.5);

  OpenResourceManager();//chun 10032022

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_dmm(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, static_cast<double>(RANGE), RESOLUTION);

  setup_dmm_ocomp_on(mod_id);



  vth_aclose_rly(mod_id, K752);

  vth_aclose_rly(mod_id, K760);

  vth_mtmr_wait(mod_id, 3);//added by sri for NASRU

  /* ------------------------------------------------------------------ */

  /* Modified 01.28.91 JRM -------------------------------------------- */

  /* Added the following line for SS compatibility.  This allows all    */

  /* pin, pin6, and cp cards to run exactly the same code.              */

  /* ------------------------------------------------------------------ */

  virt_card_select(mod_id, slot, 2);   /*selects virtual card 2*/



  vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[(MUX_NODE_PIN + 1) % 9]

             [CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, KDCG);



  connect_dmm(mod_id);

  connect_minus_pin(mod_id, slot, CHANNEL, true);

  connect_plus_gout(mod_id);

  vth_mtmr_wait(mod_id, 3);//added by sri for NASRU

  measure_dmm(mod_id);

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    if (fabs(result.UU.Real_result) > DGN_INFINITY)

      result.UU.Real_result = DGN_INFINITY - 1;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected dmm R)", true);



  vth_aopen_all_rlys(mod_id);

  vth_popen_all_rlys(mod_id, slot);

  vth_mtmr_wait(mod_id, 0.5);

  vth_pinit(mod_id, slot);

  vth_ainit(mod_id);





  close_34980A(mod_id);//close_mux(mod_id);

  close_dmm(mod_id);

  CloseResourceManager();//chun10032022

}  /*t9201*/

#undef CHANNEL

#undef MUX_NODE_PIN

#undef RANGE

#undef RESOLUTION

#undef DGN_INFINITY

#undef DMM_FUNCTION



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            10.0

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           10.0

#define VMINUS          (-10.0)



/* static variables for t9205: */

struct LOC_t9205

{

  int mod_id;

  int slot;

  int len;

  int next;

  double resistance_xbus;

  double rfb;

  int channel;

  test_result_type result;

  s80 message;

} ;



static void measure_resistance(struct LOC_t9205 * LINK)

{

  LINK->resistance_xbus = measure_open(LINK->mod_id, VPLUS, VMINUS, LINK->rfb);

  if (LINK->resistance_xbus < -2.0e+11)

  {   /* large negative value */

    LINK->resistance_xbus = R_MAX_PARALLEL;

    LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

  }

  else

  {

    if (LINK->resistance_xbus < -1.0e+11)

    {   /* moderate negative < 200uV noise */

      LINK->resistance_xbus = R_MAX_PARALLEL;



      /* warn the operator of a potential measurement problem */

      strcpy(LINK->message,

             "WARNING: High-Z measurement problem, Absolute value required");

      display_prompt(LINK->message, true);

      strcpy(LINK->message, "Test 9207 Module ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1, "%d", LINK->mod_id);

      LINK->next = mtd_strlen(LINK->message) + 1;

      strcat(LINK->message, " Slot ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1, "%d", LINK->slot);

      LINK->next = mtd_strlen(LINK->message) + 1;

      strcat(LINK->message, " Channel ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1, "%c", LINK->channel);

      LINK->next = mtd_strlen(LINK->message) + 1;

      display_prompt(LINK->message, true);



      LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

    }

    else

    {

      if (LINK->resistance_xbus < 0)

      {   /* small negative > 200uV noise */

        LINK->resistance_xbus = fabs(LINK->resistance_xbus);

        LINK->result.UU.Real_result = -1.0 * log10(LINK->resistance_xbus);

      }

      else

      {  /* positive value */

        if (LINK->resistance_xbus > R_MAX_PARALLEL)

          LINK->resistance_xbus = R_MAX_PARALLEL;

        LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

      }

    }

  }



  log_result(LINK->mod_id, LINK->result);



}  /* measure_resistance */



//------------------------------------------------------------------------------

void t9205(int mod_id, int slot)

{

  /* Diagnostic version of T9209 */

  struct LOC_t9205 V;

  int mint;

  int valid_cards;

  int p2c_temp;



  V.mod_id = mod_id;

  V.slot = slot;

  /*select all Channel Virtual Cards */

  valid_cards = (1 << CP) | (1 << CP20);

  p2c_temp = get_testhead_actual_card(V.mod_id, V.slot);

  if (((1 << p2c_temp) & valid_cards) != 0)

    virt_card_select(V.mod_id, V.slot, 3);



  /* setup the MOA for resistor measurements */

  vth_aclose_rly(V.mod_id, K827);   /* MOAOUT to REFR2 */

  vth_aclose_rly(V.mod_id, K850);   /* Rfb = 1MEG */

  vth_aclose_rly(V.mod_id, K811);   /* I to MOAINV */

  vth_aclose_rly(V.mod_id, K843);   /* MOANON to ACOM */

  vth_aopen_rly(V.mod_id, K2605);   /* MOA Happy Relay */

  vth_amoa_sel_wb(V.mod_id);



  vth_acal_rtn_fb(V.mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(V.mod_id, &V.result))

    V.rfb = V.result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    V.rfb = 1e6;

  }



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(V.mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aclose_rly(V.mod_id, K2303);   /* DETLO to ACOM internally */

  vth_aopen_rly(V.mod_id, K2305);

  vth_aopen_rly(V.mod_id, K820);   /* disconnect L from DETLO */

  vth_aopen_rly(V.mod_id, K812);   /* remove DETHI from I */

  vth_aclose_rly(V.mod_id, K857); /* int L to ACOM */



  /* setup the SOURCE for DCV */

  vth_aclose_rly(V.mod_id, K806);   /* S to SRCOUT */

  vth_asrc_sel_fltr(V.mod_id, FILTER_128);

  vth_afc_en_src_out(V.mod_id);



  for (V.channel = 'A'; V.channel <= 'H'; V.channel++)

  {  /* measure one channel to XG bus */

    /* CLOSE AIM ONLY RELAYS TO MEASURE THE AIM AND MB RESISTANCE */

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[V.channel - 'A']);

    vth_aclose_rly(V.mod_id, K816);   /* I bus to G bus */

    vth_aclose_rly(V.mod_id, K752);   /* G bus to XG bus */

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance(&V);



    /* CLOSE KDC RELAY TO INCLUDE MEASUREMENT OF XBUS ON PIN CARD */

    vth_pclose_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, KDCG);

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance(&V);



    /* CLOSE KX RELAY TO INCLUDE MEASUREMENT OF RXBUS ON PIN CARD */

    vth_pclose_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.channel - 'A']);

    vth_pclose_rly(V.mod_id, V.slot, PIN_KGL_RLYS[V.channel - 'A']);

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance(&V);



    /* CLOSE MINT RELAY TO INCLUDE MEASUREMENT OF MINT PINS PATHS */

    for (mint = 0; mint <= 8; mint++)

    {

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint][V.channel - 'A']);

      vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

      measure_resistance(&V);

      vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint][V.channel - 'A']);

      vth_mtmr_wait(V.mod_id, RELAY_OPEN_WAIT_TIME);

    }



    vth_aopen_rly(V.mod_id, AIM_X_S_RLYS[V.channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KDC_RLYS[V.channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, KDCG);

    vth_popen_rly(V.mod_id, V.slot, PIN_KX_RLYS[V.channel - 'A']);

    vth_popen_rly(V.mod_id, V.slot, PIN_KGL_RLYS[V.channel - 'A']);

    vth_mtmr_wait(V.mod_id, RELAY_OPEN_WAIT_TIME);



  }  /* measure one channel to XG bus */



}  /* t9205 */

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            10.0

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           10.0

#define VMINUS          (-10.0)

#define FIRST           1

#define LAST            10

typedef int bus_type[LAST - FIRST + 1];

const bus_type FROM_BUS = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'B', 'C', 'C'};

const bus_type TO_BUS = {'B', 'C', 'D', 'E', 'F', 'G', 'H', 'D', 'F', 'H'};



/* static variables for t9206: */

struct LOC_t9206

{

  int mod_id;

  int slot;

  int measurement;

  int len;

  int next;

  double resistance_xbus;

  double rfb;

  test_result_type result;

  s80 message;

} ;



static void measure_resistance_(struct LOC_t9206 * LINK)

{

  LINK->resistance_xbus = measure_open(LINK->mod_id, VPLUS, VMINUS, LINK->rfb);

  if (LINK->resistance_xbus < -2.0e+11)

  {   /* large negative value */

    LINK->resistance_xbus = R_MAX_PARALLEL;

    LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

  }

  else

  {

    if (LINK->resistance_xbus < -1.0e+11)

    {   /* moderate negative < 200uV noise */

      LINK->resistance_xbus = R_MAX_PARALLEL;



      /* warn the operator of a potential measurement problem */

      strcpy(LINK->message,

             "WARNING: High-Z measurement problem, Absolute value required");

      display_prompt(LINK->message, true);

      strcpy(LINK->message, "Test 9207 Module ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1, "%d", LINK->mod_id);

      LINK->next = mtd_strlen(LINK->message) + 1;

      strcat(LINK->message, " Slot ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1, "%d", LINK->slot);

      LINK->next = mtd_strlen(LINK->message) + 1;

      strcat(LINK->message, " Channel ");

      LINK->len = mtd_strlen(LINK->message) + 1;

      sprintf(LINK->message + LINK->len - 1,

              "%c", FROM_BUS[LINK->measurement - FIRST]);

      LINK->next = mtd_strlen(LINK->message) + 1;

      display_prompt(LINK->message, true);



      LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

    }

    else

    {

      if (LINK->resistance_xbus < 0)

      {   /* small negative > 200uV noise */

        LINK->resistance_xbus = fabs(LINK->resistance_xbus);

        LINK->result.UU.Real_result = -1.0 * log10(LINK->resistance_xbus);

      }

      else

      {  /* positive value */

        if (LINK->resistance_xbus > R_MAX_PARALLEL)

          LINK->resistance_xbus = R_MAX_PARALLEL;

        LINK->result.UU.Real_result = log10(LINK->resistance_xbus);

      }

    }

  }



  log_result(LINK->mod_id, LINK->result);



}  /* measure_resistance */



//------------------------------------------------------------------------------

void t9206(int mod_id, int slot)

{

  /* Diagnostic version of T9207 */

  struct LOC_t9206 V;



  static bus_type from_bus = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'B', 'C', 'C'};



  int mint;

  int valid_cards;

  int p2c_temp;



  V.mod_id = mod_id;

  V.slot = slot;

  /*select all Channel Virtual Cards */

  valid_cards = (1 << CP) | (1 << CP20);

  p2c_temp = get_testhead_actual_card(V.mod_id, V.slot);

  if (((1 << p2c_temp) & valid_cards) != 0)

    virt_card_select(V.mod_id, V.slot, 3);



  flush_commands(V.mod_id);



  /* setup the MOA for resistor measurements */

  vth_aclose_rly(V.mod_id, K827);   /* MOAOUT to REFR2 */

  vth_aclose_rly(V.mod_id, K850);   /* Rfb = 1MEG */

  vth_aclose_rly(V.mod_id, K811);   /* I to MOAINV */

  vth_aclose_rly(V.mod_id, K843);   /* MOANON to ACOM */

  vth_aopen_rly(V.mod_id, K2605);   /* MOA Happy Relay */

  vth_amoa_sel_wb(V.mod_id);

  flush_commands(V.mod_id);



  vth_acal_rtn_fb(V.mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(V.mod_id, &V.result))

    V.rfb = V.result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    V.rfb = 1e6;

  }



  flush_commands(V.mod_id);



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(V.mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aclose_rly(V.mod_id, K2303);   /* DETLO to ACOM internally */

  vth_aopen_rly(V.mod_id, K2305);

  vth_aopen_rly(V.mod_id, K820);   /* disconnect L from DETLO */

  vth_aopen_rly(V.mod_id, K812);   /* remove DETHI from I */

vth_aclose_rly(V.mod_id, K857); /* int L to ACOM */



  flush_commands(V.mod_id);



  /* setup the SOURCE for DCV */

  vth_aclose_rly(V.mod_id, K806);   /* S to SRCOUT */

  vth_asrc_sel_fltr(V.mod_id, FILTER_128);

  vth_afc_en_src_out(V.mod_id);



  flush_commands(V.mod_id);



  for (V.measurement = FIRST; V.measurement <= LAST; V.measurement++)

  {  /* measure one of the from_bus/to_bus pairs */

    flush_commands(V.mod_id);



    /* discharge the bus */

    vth_aclose_rly(V.mod_id, AIM_X_L_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

        /* discharge bus */

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    vth_aopen_rly(V.mod_id, AIM_X_L_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_mtmr_wait(V.mod_id, RELAY_OPEN_WAIT_TIME);



    flush_commands(V.mod_id);



    /* CLOSE AIM ONLY RELAYS TO MEASURE THE AIM AND MB RESISTANCE */

    vth_aclose_rly(V.mod_id, AIM_X_S_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_aclose_rly(V.mod_id, AIM_X_I_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance_(&V);



    flush_commands(V.mod_id);



    /* CLOSE KDC RELAY TO INCLUDE MEASUREMENT OF XBUS ON PIN CARD */

    vth_pclose_rly(V.mod_id, V.slot,

               PIN_KDC_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_pclose_rly(V.mod_id, V.slot,

               PIN_KDC_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance_(&V);



    /* CLOSE KX RELAY TO INCLUDE MEASUREMENT OF RXBUS ON PIN CARD */

    vth_pclose_rly(V.mod_id, V.slot,

               PIN_KX_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_pclose_rly(V.mod_id, V.slot,

               PIN_KX_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    measure_resistance_(&V);



    /* CLOSE MINT RELAY TO INCLUDE MEASUREMENT OF MINT PINS PATHS */

    for (mint = 0; mint <= 8; mint++)

    {  /* for mint */

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint]

                 [FROM_BUS[V.measurement - FIRST] - 'A']);

      vth_pclose_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint]

                 [TO_BUS[V.measurement - FIRST] - 'A']);

      vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

      measure_resistance_(&V);

      vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint]

                [FROM_BUS[V.measurement - FIRST] - 'A']);

      vth_popen_rly(V.mod_id, V.slot, PIN_RCVR_RLYS[mint]

                [TO_BUS[V.measurement - FIRST] - 'A']);

      vth_mtmr_wait(V.mod_id, WAIT_TIME_FOR_RELAYS);

    }  /* for mint */





    vth_aopen_rly(V.mod_id, AIM_X_S_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_aopen_rly(V.mod_id, AIM_X_I_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_popen_rly(V.mod_id, V.slot,

              PIN_KDC_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_popen_rly(V.mod_id, V.slot,

              PIN_KDC_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_popen_rly(V.mod_id, V.slot,

              PIN_KX_RLYS[FROM_BUS[V.measurement - FIRST] - 'A']);

    vth_popen_rly(V.mod_id, V.slot,

              PIN_KX_RLYS[TO_BUS[V.measurement - FIRST] - 'A']);

    vth_mtmr_wait(V.mod_id, RELAY_OPEN_WAIT_TIME);



  }  /* measure one of the from_bus/to_bus pairs */



}  /* t9206 */

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS

#undef FIRST

#undef LAST



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            10.0

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           10.0

#define VMINUS          (-10.0)

//------------------------------------------------------------------------------

void t9207(int mod_id, int slot)

{

  /* Parallel Xn Bus Resistance */

  double resistance_xbus;

  int channel;

  test_result_type result;

  double rfb;

  int mint;

  s80 message;

  int len;

  int next;

  int valid_cards;

  int p2c_temp;





//mjs -- need to make sure that the fixture is unlocked for this test

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);

  vth_cfxt_unlock();







  /*select all Channel Virtual Cards */

  valid_cards = (1 << CP) | (1 << CP20);

  p2c_temp = get_testhead_actual_card(mod_id, slot);

  if (((1 << p2c_temp) & valid_cards) != 0)

    virt_card_select(mod_id, slot, 3);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*close the bus paths*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);



    for (mint = 0; mint <= 8; mint++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mint][channel - 'A']);



  }  /*close the bus paths*/



  /* setup the MOA for resistor measurements */

  vth_aclose_rly(mod_id, K827);   /* MOAOUT to REFR2 */

  vth_aclose_rly(mod_id, K850);   /* Rfb = 1MEG */

  vth_aclose_rly(mod_id, K811);   /* I to MOAINV */

  vth_aclose_rly(mod_id, K843);   /* MOANON to ACOM */

  vth_aopen_rly(mod_id, K2605);   /* MOA Happy Relay */

  vth_amoa_sel_wb(mod_id);

  vth_acal_rtn_fb(mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(mod_id, &result))

    rfb = result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    rfb = 1e6;

  }



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aclose_rly(mod_id, K2303);   /* DETLO to ACOM internally */

  vth_aopen_rly(mod_id, K2305);

  vth_aopen_rly(mod_id, K820);   /* disconnect L from DETLO */

  vth_aopen_rly(mod_id, K812);   /* remove DETHI from I */

vth_aclose_rly(mod_id, K857); /* int L to ACOM */



  /* setup the SOURCE for DCV */

  vth_aclose_rly(mod_id, K806);   /* S to SRCOUT */

  vth_asrc_sel_fltr(mod_id, FILTER_128);

  vth_afc_en_src_out(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*measure the resistance*/

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_L_RLYS[channel - 'A']);   /* discharge bus */

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    vth_aopen_rly(mod_id, AIM_X_L_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);



    resistance_xbus = measure_open(mod_id, VPLUS, VMINUS, rfb);

    if (resistance_xbus < -2.0e+11)

    {   /* large negative value */

      resistance_xbus = R_MAX_PARALLEL;

      result.UU.Real_result = log10(resistance_xbus);

    }

    else

    {

      if (resistance_xbus < -1.0e+11)

      {   /* moderate negative < 200uV noise */

        resistance_xbus = R_MAX_PARALLEL;



        /* warn the operator of a potential measurement problem */

        strcpy(message,

               "WARNING: High-Z measurement problem, Absolute value required");

        display_prompt(message, true);

        strcpy(message, "Test 9207 Module ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", mod_id);

        next = mtd_strlen(message) + 1;

        strcat(message, " Slot ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", slot);

        next = mtd_strlen(message) + 1;

        strcat(message, " Channel ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%c", channel);

        next = mtd_strlen(message) + 1;

        display_prompt(message, true);



        result.UU.Real_result = log10(resistance_xbus);

      }

      else

      {

        if (resistance_xbus < 0)

        {   /* small negative > 200uV noise */

          resistance_xbus = fabs(resistance_xbus);

          result.UU.Real_result = -1.0 * log10(resistance_xbus);

        }

        else

        {  /* positive value */

          if (resistance_xbus > R_MAX_PARALLEL)

            resistance_xbus = R_MAX_PARALLEL;

          result.UU.Real_result = log10(resistance_xbus);

        }

      }

    }

    log_result(mod_id, result);



    vth_aopen_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);



  }  /*measure the resistance*/



//mjs -- relock the fixture  ,  but i commented out because of annoyance and relock the fixture in 9210

//  vth_cfxt_lock();



}  /*t9207*/

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            10.0

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           10.0

#define VMINUS          (-10.0)

//------------------------------------------------------------------------------

void t9208(int mod_id, int slot)

{

  /* Parallel Xn Bus Resistance */

  double resistance_xbus;

  int channel;

  test_result_type result;

  double rfb;

  s80 message;

  int len;

  int next;



  /*close the bus paths*/

  for (channel = 'A'; channel <= 'H'; channel++)

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);



  /* setup the MOA for resistor measurements */

  vth_aclose_rly(mod_id, K827);   /* MOAOUT to REFR2 */

  vth_aclose_rly(mod_id, K850);   /* Rfb = 1MEG */

  vth_aclose_rly(mod_id, K811);   /* I to MOAINV */

  vth_aclose_rly(mod_id, K843);   /* MOANON to ACOM */

  vth_aopen_rly(mod_id, K2605);   /* MOA Happy Relay */

  vth_amoa_sel_wb(mod_id);

  vth_acal_rtn_fb(mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(mod_id, &result))

    rfb = result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    rfb = 1e6;

  }



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aclose_rly(mod_id, K2303);   /* DETLO to ACOM internally */

  vth_aopen_rly(mod_id, K2305);

  vth_aopen_rly(mod_id, K812);   /* remove DETHI from I */

  vth_aopen_rly(mod_id, K820);   /* remove L form DETLO */

  vth_aclose_rly(mod_id, K857);   /* L to ACOM */



  /* setup the SOURCE for DCV */

  vth_aclose_rly(mod_id, K806);   /* S to SRCOUT */

  vth_asrc_sel_fltr(mod_id, FILTER_128);

  vth_afc_en_src_out(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*measure the resistance*/

    vth_aopen_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_L_RLYS[channel - 'A']);   /* discharge bus */

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);

    vth_aopen_rly(mod_id, AIM_X_L_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);



    resistance_xbus = measure_open(mod_id, VPLUS, VMINUS, rfb);

    if (resistance_xbus < -2.0e+11)

    {   /* large negative */

      resistance_xbus = R_MAX_PARALLEL;

      result.UU.Real_result = log10(resistance_xbus);

    }

    else

    {

      if (resistance_xbus < -1.0e+11)

      {   /* moderate negative  < 200uV noise */

        resistance_xbus = R_MAX_PARALLEL;



        /* warn the operator of a potential measurement problem */

        strcpy(message,

               "WARNING: High-Z measurement problem, Absolute value required");

        display_prompt(message, true);

        strcpy(message, "Test 9208 Module ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", mod_id);

        next = mtd_strlen(message) + 1;

        strcat(message, " Slot ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", slot);

        next = mtd_strlen(message) + 1;

        strcat(message, " Channel ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%c", channel);

        next = mtd_strlen(message) + 1;

        display_prompt(message, true);



        result.UU.Real_result = log10(resistance_xbus);

      }

      else

      {

        if (resistance_xbus < 0)

        {   /* small negative > 200uV noise */

          resistance_xbus = fabs(resistance_xbus);

          result.UU.Real_result = -1.0 * log10(resistance_xbus);

        }

        else

        {  /* positive value */

          if (resistance_xbus > R_MAX_PARALLEL)

            resistance_xbus = R_MAX_PARALLEL;

          result.UU.Real_result = log10(resistance_xbus);

        }

      }

    }

    log_result(mod_id, result);



    vth_aopen_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);



  }  /*measure the resistance*/

}  /*t9208*/

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            10.0

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           10.0

#define VMINUS          (-10.0)

//------------------------------------------------------------------------------

void t9209(int mod_id, int slot)

{

  /* Parallel Xn Bus Resistance */

  double resistance_xbus;

  int channel;

  test_result_type result;

  double rfb;

  int mint;

  s80 message;

  int len;

  int next;

  int valid_cards;

  int p2c_temp;


  OpenResourceManager();//fikri 08112022
  open_34980A(mod_id);//fikri 08112022

  close_34980A(mod_id);//fikri 08112022
  CloseResourceManager();//fikri 08112022

  /*select all Channel Virtual Cards */

  valid_cards = (1 << CP) | (1 << CP20);

  p2c_temp = get_testhead_actual_card(mod_id, slot);

  if (((1 << p2c_temp) & valid_cards) != 0)

    virt_card_select(mod_id, slot, 3);



  vth_pclose_rly(mod_id, slot, KDCG);

  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*close the bus paths*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);



    for (mint = 0; mint <= 8; mint++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mint][channel - 'A']);



  }  /*close the bus paths*/



  /* setup the MOA for resistor measurements */

  vth_aopen_rly(mod_id, K814);   /* disconnect G from ACOM */

  vth_aclose_rly(mod_id, K827);   /* MOAOUT to REFR2 */

  vth_aclose_rly(mod_id, K850);   /* Rfb = 1MEG */

  vth_aclose_rly(mod_id, K811);   /* I to MOAINV */

  vth_aclose_rly(mod_id, K816);   /* I to G */

  vth_aclose_rly(mod_id, K752);   /* G to XG */

  vth_aclose_rly(mod_id, K843);   /* MOANON to ACOM */

  vth_aopen_rly(mod_id, K2605);   /* MOA Happy Relay */

  vth_amoa_sel_wb(mod_id);

  vth_acal_rtn_fb(mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(mod_id, &result))

    rfb = result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    rfb = 1e6;

  }



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aclose_rly(mod_id, K2303);   /* DETLO to ACOM internally */

  vth_aopen_rly(mod_id, K2305);

  vth_aopen_rly(mod_id, K812);   /* remove DETHI from I */



  /* setup the SOURCE for DCV */

  vth_aclose_rly(mod_id, K806);   /* S to SRCOUT */

  vth_asrc_sel_fltr(mod_id, FILTER_128);

  vth_afc_en_src_out(mod_id);



  resistance_xbus = measure_open(mod_id, VPLUS, VMINUS, rfb);

  if (resistance_xbus < -2.0e+11)

  {   /* large negative */

    resistance_xbus = R_MAX_PARALLEL;

    result.UU.Real_result = log10(resistance_xbus);

  }

  else

  {

    if (resistance_xbus < -1.0e+11)

    {   /* moderate negative < 200uV noise */

      resistance_xbus = R_MAX_PARALLEL;



      /* warn the operator of a potential measurement problem */

      strcpy(message,

             "WARNING: High-Z measurement problem, Absolute value required");

      display_prompt(message, true);

      strcpy(message, "Test 9209 Module ");

      len = mtd_strlen(message) + 1;

      sprintf(message + len - 1, "%d", mod_id);

      next = mtd_strlen(message) + 1;

      strcat(message, " Slot ");

      len = mtd_strlen(message) + 1;

      sprintf(message + len - 1, "%d", slot);

      next = mtd_strlen(message) + 1;

      strcat(message, " Channel ");

      len = mtd_strlen(message) + 1;

      sprintf(message + len - 1, "%c", channel);

      next = mtd_strlen(message) + 1;

      display_prompt(message, true);



      result.UU.Real_result = log10(resistance_xbus);

    }

    else

    {

      if (resistance_xbus < 0)

      {   /* small negative > 200uV noise       */

        resistance_xbus = fabs(resistance_xbus);

        result.UU.Real_result = -1.0 * log10(resistance_xbus);

      }

      else

      {  /* positive */

        if (resistance_xbus > R_MAX_PARALLEL)

          resistance_xbus = R_MAX_PARALLEL;

        result.UU.Real_result = log10(resistance_xbus);

      }

    }

  }

  log_result(mod_id, result);



}  /*t9209*/

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS



#define LCR_MULT        5

#define LCR_FREQ        100e+03

#define LCR_FUNCTION    INDUCTANCE

#define LCR_DISPLAY     Q

#define LCR_CKT_MODE    SERIES

//------------------------------------------------------------------------------

void t9210(int mod_id, int slot)

{

  /* Series Xn Bus Inductance */

  int mux_node_pin;

  int next;

  int start;



  double henries;



  int channel;

  test_result_type result;

  char *s_ptr;

  char s[MAX_S_LENGTH + 1];

  char *str1;





  OpenResourceManager();//chun10032022

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_lcr(mod_id);
  //open_E4980AL_LCR(mod_id);


//mjs -- need to make sure that the fixture is locked for this test

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();



  setup_lcr(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ,LCR_MULT);
  //setup_E4980AL_LCR(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);



  connect_lcr(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    if ((channel & 1) == 1)

    {

      virt_card_select(mod_id, slot, 2);

      mux_node_pin = 7;   /* Channels A,C,E, and G */

    }

    else

    {

      virt_card_select(mod_id, slot, 0);

      mux_node_pin = 0;   /* Channels B,D,F, and H */

    }

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin][channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mux_node_pin + 1][channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_S_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_MINT_RLYS[channel - 'A']);

  }  /*for*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);



    connect_minus_pin(mod_id, slot, channel, true);

    connect_4wire_plus_xn(mod_id, channel, true);



    measure_lcr(mod_id);
	//measure_E4980AL_LCR(mod_id);

    result.Measurement_class = CLASS_PSTRING_PTR;

    if (get_result_nolog(mod_id, &result))

    {  /* if */

      s_ptr = static_cast(char*, result.UU.Pstring_ptr);

      strcpy(s, s_ptr);

//  Debug

//    start = strpos2("L", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
    start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

      henries = strtod(s + start - 1, &str1);

      next = str1 - s + 1;

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = henries;

      log_result(mod_id, result);

    }  /* if */

    else

      display_prompt("No result in result log (Expected Series L)", true);



    vth_popen_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);



    connect_minus_pin(mod_id, slot, channel, false);

    connect_4wire_plus_xn(mod_id, channel, false);



  }  /*for*/



  vth_ainit(mod_id);

  vth_pinit(mod_id, slot);



  close_34980A(mod_id);//close_mux(mod_id);

  close_lcr(mod_id);
  //close_E4980AL_LCR(mod_id);

  CloseResourceManager();//chun 10032022

}  /*t9210*/

#undef LCR_MULT

#undef LCR_FREQ

#undef LCR_FUNCTION

#undef LCR_DISPLAY

#undef LCR_CKT_MODE



#define CHANNEL         'A'

#define MUX_NODE_PIN    7

#define LCR_MULT        5

#define LCR_FREQ        100e+03

#define LCR_FUNCTION    INDUCTANCE

#define LCR_DISPLAY     Q

#define LCR_CKT_MODE    SERIES

//------------------------------------------------------------------------------

void t9211(int mod_id, int slot)

{

  /* Series XG/XGL/DRa Bus Inductance */

  int next;

  int start;



  double henries;



  test_result_type result;

  char *s_ptr;

  char s[MAX_S_LENGTH + 1];

  char *str1;



  vth_ainit(mod_id);

  vth_pinit(mod_id,slot);

  vth_mtmr_wait(mod_id, 0.100);

  OpenResourceManager();//chun 10032022

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_lcr(mod_id);
 //open_E4980AL_LCR(mod_id);


  setup_lcr(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);
  //setup_E4980AL_LCR(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);



  vth_aclose_rly(mod_id, K752);

  vth_aclose_rly(mod_id, K760);

  /* ------------------------------------------------------------------ */

  /* Modified 01.28.91 JRM -------------------------------------------- */

  /* Added the following line for SS compatibility.  This allows all    */

  /* pin, pin6, and cp cards to run exactly the same code.              */

  /* ------------------------------------------------------------------ */

  virt_card_select(mod_id, slot, 2);   /*selects virtual card 2*/

  vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[(MUX_NODE_PIN + 1) % 9]

             [CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[CHANNEL - 'A']);

  vth_pclose_rly(mod_id, slot, KDCG);



  connect_lcr(mod_id);

  connect_minus_pin(mod_id, slot, CHANNEL, true);

  connect_plus_gout(mod_id);



  measure_lcr(mod_id);
  //measure_E4980AL_LCR(mod_id);

  result.Measurement_class = CLASS_PSTRING_PTR;

  if (get_result_nolog(mod_id, &result))

  {  /* if */

    s_ptr = static_cast(char*, result.UU.Pstring_ptr);

    strcpy(s, s_ptr);

//  Debug

//  start = strpos2("L", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
    start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

    henries = strtod(s + start - 1, &str1);

    next = str1 - s + 1;

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = henries;

    log_result(mod_id, result);
    connect_minus_pin(mod_id, slot, CHANNEL, false);
  }  /* if */

  else

    display_prompt("No result in result log (Expected Series L)", true);



  vth_ainit(mod_id);

  vth_pinit(mod_id, slot);



  close_34980A(mod_id);//close_mux(mod_id);

  close_lcr(mod_id);
  //close_E4980AL_LCR(mod_id);

  CloseResourceManager();//chun10032022

}  /*t9211*/

#undef CHANNEL

#undef MUX_NODE_PIN

#undef LCR_MULT

#undef LCR_FREQ

#undef LCR_FUNCTION

#undef LCR_DISPLAY

#undef LCR_CKT_MODE



#define SALES_LONG            1

#define AVERAGE         10

#define CPU             0

#define VEXP            0.039

#define TOUT            1.0

#define RFB_1MEG        5

#define MODE_2WIRE      0

#define VPLUS           5.0

#define VMINUS          (-5.0)

//------------------------------------------------------------------------------

void t9217(int mod_id, int slot)

{

  /* Parallel Xn Bus Resistance to Ground */

  double resistance_xbus;

  int channel;

  test_result_type result;

  double rfb;

  int mint;

  s80 message;

  int len;

  int next;

  int valid_cards;

  int p2c_temp;



//mjs -- need to make sure that the fixture is unlocked for this test

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_unlock();



  /*select all Channel Virtual Cards */

  valid_cards = (1 << CP) | (1 << CP20);

  p2c_temp = get_testhead_actual_card(mod_id, slot);

  if (((1 << p2c_temp) & valid_cards) != 0)

    virt_card_select(mod_id, slot, 3);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*close the bus paths*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[0][channel - 'A']);



    for (mint = 0; mint <= 8; mint++)

      vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[mint][channel - 'A']);



  }  /*close the bus paths*/



  vth_pclose_rly(mod_id, slot, KDCG);



  /* setup the MOA for resistor measurements */

  vth_aclose_rly(mod_id, K827);   /* MOAOUT to REFR2 */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K850);   /* Rfb = 1MEG */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K811);   /* I to MOAINV */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aopen_rly(mod_id, K843);   /* MOANON to AUXOUT */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K842);
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aopen_rly(mod_id, K2605);   /* MOA Happy Relay */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aopen_rly(mod_id, K857);   /* disconnect L from ACOM */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K819);   /* MOANON to L */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K814);   /* G to ACOM */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K752);   /* G to XG */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_aclose_rly(mod_id, K828);   /* REFR2 to DETHI */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
  vth_amoa_sel_wb(mod_id);

  vth_acal_rtn_fb(mod_id, RFB_1MEG, MODE_2WIRE);

  if (get_result_nolog(mod_id, &result))

    rfb = result.UU.Real_result;

  else

  {

    display_prompt("No result in result log, expected Rfb", true);

    rfb = 1e6;

  }



  /* setup the DETECTOR for DCV measurements */

  vth_dcv_setup(mod_id, SALES_LONG, AVERAGE, CPU, VEXP, TOUT);

  vth_aopen_rly(mod_id, K812);   /* remove DETHI from I */
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);


  /* setup the AUX */

  vth_aaux_en_30ma_ilim(mod_id);

  vth_aaux_set_ampl(mod_id, 0.0);

  vth_aaux_en(mod_id);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*measure the resistance*/

    vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[0][channel - 'A']);
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);
    flush_commands(mod_id);

    vth_mtmr_wait(mod_id, 1);

    vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



    resistance_xbus = measure_open_non(mod_id, VPLUS, VMINUS, rfb);

    if (resistance_xbus < -1.0e+11)

    {   /* large negative value */

      resistance_xbus = R_MAX_PARALLEL;

      result.UU.Real_result = log10(resistance_xbus);

    }

    else

    {

      if (resistance_xbus < -5.0e+10)

      {   /* moderate negative < 200uV noise */

        resistance_xbus = R_MAX_PARALLEL;



        /* warn the operator of a potential measurement problem */

        strcpy(message,

               "WARNING: High-Z measurement problem, Absolute value required");

        display_prompt(message, true);

        strcpy(message, "Test 9217 Module ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", mod_id);

        next = mtd_strlen(message) + 1;

        strcat(message, " Slot ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%d", slot);

        next = mtd_strlen(message) + 1;

        strcat(message, " Channel ");

        len = mtd_strlen(message) + 1;

        sprintf(message + len - 1, "%c", channel);

        next = mtd_strlen(message) + 1;

        display_prompt(message, true);



        result.UU.Real_result = log10(resistance_xbus);

      }

      else

      {

        if (resistance_xbus < 0)

        {   /* small negative > 200uV noise */

          resistance_xbus = fabs(resistance_xbus);

          result.UU.Real_result = -1.0 * log10(resistance_xbus);

        }

        else

        {  /* positive value */

          if (resistance_xbus > R_MAX_PARALLEL)

            resistance_xbus = R_MAX_PARALLEL;

          result.UU.Real_result = log10(resistance_xbus);

        }

      }

    }

    log_result(mod_id, result);



    vth_aopen_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

    vth_mtmr_wait(mod_id, RELAY_OPEN_WAIT_TIME);

    vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[0][channel - 'A']);



  }  /*measure the resistance*/



//mjs -- relock the fixture , but put the lock at the start of 9920

//  vth_cfxt_lock();



}  /*t9217*/

#undef SALES_LONG

#undef AVERAGE

#undef CPU

#undef VEXP

#undef TOUT

#undef RFB_1MEG

#undef MODE_2WIRE

#undef VPLUS

#undef VMINUS



#define LCR_MULT        5

#define LCR_FREQ        100e+03

#define WAIT_TIME       1500e-03//500e-03

#define LCR_FUNCTION    CAPACITANCE

#define LCR_DISPLAY     Q

#define LCR_CKT_MODE    PARALLEL

//------------------------------------------------------------------------------

void t9220(int mod_id, int slot)

{

  /* [PINCARD] Parallel Xn Bus Capacitance */



  /* For path and test descriptions, see the documentation for test: 9220 */



  int next;

  int start;



  double farads;



  int channel;

  test_result_type result;

  char *s_ptr;

  char s[MAX_S_LENGTH + 1];

  char *str1;



//  FILE *diagfile;

  OpenResourceManager();//chun 14032022

 //open_mux(mod_id);
  open_34980A(mod_id);

  open_lcr(mod_id);
  //open_E4980AL_LCR(mod_id);


  //mjs 6/97

  double correction;   //correction factor because results of this test are dependent

                       // on the number and type of cards in module

//mjs FIX THIS DOCUMENTATION!!!!!!!!!!!!!!!!!!!!

/* the .435ns is the correction factor for 1 single density card.  it was observed from

   Report data that indicated the shift in this test.  it was calculated as follows:



   with 2 DD cards, mean for test was 1.12ns

   with 9 DD cards, mean for test was -4.97ns

   delta mean = 1.12 - -4.97 = 6.09ns

   delta cards = 9-2 = 7

   correction per DD card = 6.09ns / 7 = .87ns

   correction per SD card is thus .87ns /2 = .435ns

   */



  correction = calc_mod_correction(mod_id, .7e-12);



  /*diagfile = fopen("diag.mjs", "a");

  fprintf(diagfile, "=============================================\n", mod_id, slot);

  fprintf(diagfile, "TEST 9220/9920         module %2d   slot %2d \n", mod_id, slot);

  fprintf(diagfile, "single density correction constant = .7e-12\n");

  fprintf(diagfile, "calculated correction for Module %d is %1.12f\n", mod_id, correction);

  */



//mjs -- make sure the fixture is locked for this test

//  if (!vth_fxt_safe(VTH_READ_FIXTURE_SAFE))

//    display_prompt("Press footswitch to (un)lock fixture",true);



  vth_cfxt_lock();



  setup_lcr(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);
  //setup_E4980AL_LCR(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);



  vth_aopen_all_rlys(mod_id);


  if (get_34980A_IDN() == false)
  {
	  connect_dg(mod_id, true);
  }

  connect_lcr(mod_id);



  /* For Channel card compatibility */

  vth_popen_all_rlys(mod_id, slot);

  virt_card_select(mod_id, slot, 3);



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

  }  /*for*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_aclose_rly(mod_id, AIM_X_MINT_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_PLUS_1_MINT_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

    connect_plus_xn(mod_id, channel, true);

    connect_minus_xn_plus_1(mod_id, channel, true);   /* 'H'  Xn + 1 = 'A' */



    vth_mtmr_wait(mod_id, WAIT_TIME);

    measure_lcr(mod_id);
	//measure_E4980AL_LCR(mod_id);

    result.Measurement_class = CLASS_PSTRING_PTR;

    if (get_result_nolog(mod_id, &result))

    {  /*if*/

      s_ptr = static_cast(char*, result.UU.Pstring_ptr);

      strcpy(s, s_ptr);

//  Debug

//    start = strpos2("C", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
      start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

      farads = strtod(s + start - 1, &str1);

      next = str1 - s + 1;

      if (mod_id == 0 || mod_id == 3)

        farads -= sales_rack_offset_cap[0][channel - 'A'];

      else

        farads -= sales_rack_offset_cap[1][channel - 'A'];

      result.Measurement_class = CLASS_REAL;

      result.UU.Real_result = farads - correction;

      log_result(mod_id, result);





//mjs -- the limits for this test are 0 to 140pF.  the correction factor subtracts off

//some capacitance because increasing numbers of boards were pushing us off the top



/*      if ((result.UU.Real_result+correction) > 140e-12)  //helped these subtests

      fprintf(diagfile, "   before correction:   %1.12f     after correction:   %1.12f\n", (result.UU.Real_result + correction), result.UU.Real_result);

      if (result.UU.Real_result < 0)  //hurt these subtests

      fprintf(diagfile, "   before correction:   %1.12f     after correction:   %1.12f\n", (result.UU.Real_result + correction), result.UU.Real_result);

*/



//MJS ADDED THE CORRECTION FACTOR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//ADD DOCUMENTATION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1



    }  /*if*/

    else

      display_prompt("No result in result log (Expected Xn to XG C)", true);



    connect_plus_xn(mod_id, channel, false);

    connect_minus_xn_plus_1(mod_id, channel, false);   /* 'H'  Xn + 1 = 'A' */

    vth_aopen_rly(mod_id, AIM_X_MINT_RLYS[channel - 'A']);

    vth_aopen_rly(mod_id, AIM_X_PLUS_1_MINT_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

  }  /*for*/



  vth_ainit(mod_id);

  vth_pinit(mod_id, slot);

//  fclose(diagfile);

  close_34980A(mod_id);//close_mux(mod_id);

  close_lcr(mod_id);
  //close_E4980AL_LCR(mod_id);

  CloseResourceManager();//chun 140302022

}  /*t9220*/

#undef LCR_MULT

#undef LCR_FREQ

#undef WAIT_TIME

#undef LCR_FUNCTION

#undef LCR_DISPLAY

#undef LCR_CKT_MODE



#define MUX_NODE_PIN    7

#define LCR_MULT        5

#define LCR_FREQ        100e+03

#define WAIT_TIME       500e-03

#define LCR_FUNCTION    CAPACITANCE

#define LCR_DISPLAY     Q

#define LCR_CKT_MODE    PARALLEL

//------------------------------------------------------------------------------

void t9221(int mod_id, int slot)

{

  /* [PINCARD] Parallel Xall to XG Bus Capacitance */



  /* For path and test descriptions, see the documentation for test: 9221 */

  int next;

  int start;



  double farads;



int channel;

  test_result_type result;

  char *s_ptr;

  char s[MAX_S_LENGTH + 1];

  char *str1;




  OpenResourceManager();//chun 140302022


  //open_mux(mod_id);
  open_34980A(mod_id);

  open_lcr(mod_id);
  //open_E4980AL_LCR(mod_id);


  setup_lcr(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);
  //setup_E4980AL_LCR(mod_id, LCR_FUNCTION, LCR_DISPLAY, LCR_CKT_MODE, LCR_FREQ, LCR_MULT);



  vth_aopen_all_rlys(mod_id);



  vth_aclose_rly(mod_id, K752);   /* Gout to XG relay       */

  vth_aclose_rly(mod_id, K760);   /* Gout to XG relay       */

  vth_aclose_rly(mod_id, K741);   /* X1 to mint field relay */

  vth_pclose_rly(mod_id, slot, KDCG);   /* XG to XGL relay        */


  if (get_34980A_IDN() == false)
  {
	  connect_dg(mod_id, true);
  }



  /* ------------------------------------------------------------------ */

  /* Modified 01.28.91 JRM -------------------------------------------- */

  /* Added the following line for SS compatibility.  This allows all    */

  /* pin, pin6, and cp cards to run exactly the same code.              */

  /* ------------------------------------------------------------------ */

  virt_card_select(mod_id, slot, 3);   /*selects all three virtual cards.*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KGL_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

  }  /*for*/



  channel = 'H';



  vth_pclose_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

  vth_pclose_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);



  connect_lcr(mod_id);

  connect_minus_xn_plus_1(mod_id, channel, false);   /* 'H' of Xn + 1 = 'A' */ //chun comment out on 16032022
  connect_minus_xn_plus_2(mod_id, channel, true);   /* 'H' of Xn + 1 = 'A' */ //chun 16032022  //-

  //connect_minus_xn_plus_1(mod_id, channel, true);   /* 'H' of Xn + 1 = 'A' */ //chun comment out on 16032022

  connect_plus_gout(mod_id);  //+



  vth_popen_rly(mod_id, slot, PIN_RCVR_RLYS[MUX_NODE_PIN][channel - 'A']);

  vth_popen_rly(mod_id, slot, PIN_DRVR_RLYS[MUX_NODE_PIN][channel - 'A']);



  vth_mtmr_wait(mod_id, WAIT_TIME);

  measure_lcr(mod_id);
  //measure_E4980AL_LCR(mod_id);

  result.Measurement_class = CLASS_PSTRING_PTR;

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    s_ptr = static_cast(char*, result.UU.Pstring_ptr);

    strcpy(s, s_ptr);

//  Debug

//  start = strpos2("C", s, 1) + 1;

//    start = strpos2(",", s, 1) + 1;  //old LCR-4263B 17-Aug-2022  -fikri read array[1]
    start = strpos2(",", s, 0) + 1;   //new LCR-E4980AL 17-Aug-2022 -Fikri read array[0]

    farads = strtod(s + start - 1, &str1);

    next = str1 - s + 1;

    if (mod_id == 0 || mod_id == 3)

      farads -= sales_rack_offset_xg_cap[0];

    else

      farads -= sales_rack_offset_xg_cap[1];

    result.Measurement_class = CLASS_REAL;

    result.UU.Real_result = farads;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected Xn to XG C)", true);



  vth_aopen_all_rlys(mod_id);

  vth_pinit(mod_id, slot);



  close_34980A(mod_id);//close_mux(mod_id);

  close_lcr(mod_id);
  //close_E4980AL_LCR(mod_id);

  CloseResourceManager();//chun 14032022
}  /*t9221*/







#undef MUX_NODE_PIN

#undef LCR_MULT

#undef LCR_FREQ

#undef WAIT_TIME

#undef LCR_FUNCTION

#undef LCR_DISPLAY

#undef LCR_CKT_MODE



#define RANGE           30e-03

#define RESOLUTION      1e-06

#define LOAD_RESISTANCE  10e+03

#define DMM_FUNCTION    DCV

//------------------------------------------------------------------------------

void t9230(int mod_id, int slot)

{

  /* Xn BUS LEAKAGE CURRENT */

  double dmm_voltage;

  double leakage_current;

  int channel;

  test_result_type result;

  OpenResourceManager();//chun 14032022

  //open_mux(mod_id);
  open_34980A(mod_id);

  open_dmm(mod_id);



  setup_dmm(mod_id, DMM_FUNCTION, RANGE, RESOLUTION);



  vth_aclose_rly(mod_id, K741);   /* X1 to mint field relay */

  vth_aclose_rly(mod_id, K761);   /* SWD GND mint pin relay */



  /* ------------------------------------------------------------------ */

  /* Modified 01.28.91 JRM -------------------------------------------- */

  /* Added the following line for SS compatibility.  This allows all    */

  /* pin, pin6, and cp cards to run exactly the same code.              */

  /* ------------------------------------------------------------------ */

  virt_card_select(mod_id, slot, 3);   /*selects all three virtual cards.*/



  for (channel = 'A'; channel <= 'H'; channel++)

  {  /*for*/

    vth_pclose_rly(mod_id, slot, PIN_KDC_RLYS[channel - 'A']);

    vth_pclose_rly(mod_id, slot, PIN_KX_RLYS[channel - 'A']);

    vth_aclose_rly(mod_id, AIM_X_I_RLYS[channel - 'A']);

  }  /*for*/



  connect_10k_load(mod_id);



  channel = 'A';



  connect_dmm(mod_id);

  connect_plus_xn(mod_id, channel, true);

  connect_minus_swd_gnd(mod_id);



  measure_dmm(mod_id);

  result.Measurement_class = CLASS_REAL;

  if (get_result_nolog(mod_id, &result))

  {  /*if*/

    dmm_voltage = result.UU.Real_result;

    leakage_current = dmm_voltage / LOAD_RESISTANCE;

    result.UU.Real_result = leakage_current;

    log_result(mod_id, result);

  }  /*if*/

  else

    display_prompt("No result in result log (Expected volt Xn 10K)", true);



  vth_aopen_all_rlys(mod_id);

  vth_pinit(mod_id, slot);



  close_34980A(mod_id);//close_mux(mod_id);

  close_dmm(mod_id);

  CloseResourceManager();//chun 14032022

}  /*t9230*/







/* SRI - New test 9231 added for NASRU-DH, using Slot 7 pins involved are Pin 15-S and Pin 17-I*/



//#######################################START-9231 - Zener Diode######################################

#undef RANGE

#undef RESOLUTION

#undef LOAD_RESISTANCE

#undef DMM_FUNCTION



#define NUM_ZENER   1

#define NUM_MEASUREMENTS  2

#define PIN_SLOT        7



#define FILTER          10

#define DEFAULT_FILTER  1

typedef double val_array_zener[NUM_ZENER];

typedef int bus_array_zener[NUM_ZENER];

typedef int mux_array_zener[NUM_ZENER];

const val_array_zener ZENER_VALUES = {56};

const bus_array_zener S_BUSSES_ZENER = {'A'};

const bus_array_zener A_BUSSES_ZENER = {'B'};

const bus_array_zener B_BUSSES_ZENER = {'C'};

const bus_array_zener I_BUSSES_ZENER = {'D'};

const mux_array_zener MUX_NODE_ARRAY_ZENER = {3};

static int const INDUCTOR_FXT_2 = 3801;

//------------------------------------------------------------------------------

/* PIN STANDARD COMPONENTS ZENER DIODE */

void t9231(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int zener_no;

  FILE *infile;

  //std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  double current[NUM_MEASUREMENTS];

  double src_delay[NUM_MEASUREMENTS];

  int xtra_dig[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  double meas[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];



  test_result_type result;

  char buffer[81];



  infile = NULL;





// MD: Due to splitting the standard component fixture into

//     two fixtures (rc and ind) it was necessary to have an

//     "escape" loop so that the inductor fixture will not

//     run the RC tests and vice versa. This is NOT the best way

//     to do this however I have no time to do this the proper way



  if (get_fixture_id(mod_id) != INDUCTOR_FXT_2)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard ZENER Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9240 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      //load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.zener", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.zener' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%lg", &current[reading]);

        fscanf(infile, "%lg", &src_delay[reading]);

        fscanf(infile, "%d", &xtra_dig[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%lg", &meas[reading]);

        fscanf(infile, "%lg", &hi[reading]);

		fscanf(infile, "%lg", &lo[reading]);

		fscanf(infile, "%d", &opp[reading]);

		getc(infile);

      }





	  if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

      {  /* FOR READING */

        for (i = 1; i <= NUM_ZENER; i++)

        {

          if ( number_equal(nominal_value[reading], ZENER_VALUES[i - 1]) )

            zener_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K734);

        vth_pclose_rly(mod_id, PIN_SLOT, KDC2);

        vth_pclose_rly(mod_id, PIN_SLOT, KX2);

        vth_pclose_rly(mod_id, PIN_SLOT, K10B);





        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K728);

        vth_pclose_rly(mod_id, PIN_SLOT, KDC4);

        vth_pclose_rly(mod_id, PIN_SLOT, KX4);

        vth_pclose_rly(mod_id, PIN_SLOT, K10D);





        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_ZENER[zener_no - 1]]

                     [A_BUSSES_ZENER[zener_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_ZENER[zener_no - 1]]

                     [B_BUSSES_ZENER[zener_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







		//Setup for the zener

        vth_high_volt_zener_setup(mod_id, current[reading], src_delay[reading], xtra_dig[reading], sa[reading],

			sb[reading], sl[reading], meas[reading]);



		//Measure for the zener

		vth_high_volt_zener_meas(mod_id);



		//Process the results of the Zener measurement

		//vth_ra_diode(mod_id, hi[reading], lo[reading], opp[reading]);

		vth_get_diode_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          //result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K734);

        vth_popen_rly(mod_id, PIN_SLOT, KDC2);

        vth_popen_rly(mod_id, PIN_SLOT, KX2);

        vth_popen_rly(mod_id, PIN_SLOT, K10B);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K728);

        vth_popen_rly(mod_id, PIN_SLOT, KDC4);

        vth_popen_rly(mod_id, PIN_SLOT, KX4);

        vth_popen_rly(mod_id, PIN_SLOT, K10D);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_ZENER[zener_no - 1]]

                    [A_BUSSES_ZENER[zener_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_ZENER[zener_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_ZENER[zener_no - 1]]

                    [B_BUSSES_ZENER[zener_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }  /* for READING */

    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9231 */





#undef NUM_ZENER

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef FILTER

#undef DEFAULT_FILTER



//#############################################END-9231-Zener ##########################################





/* New test 9232 added for NASRU-DH, using Slot 5 pins involved are Pin 13-S, 14-A, 33-B, 34-I */



#define NUM_CAPACITORS  1

#define NUM_MEASUREMENTS  2

#define PIN_SLOT        3

typedef double val_array_mcu[NUM_CAPACITORS];

typedef int bus_array_mcu[NUM_CAPACITORS];

typedef int mux_array_mcu[NUM_CAPACITORS];

const val_array_mcu CAPACITOR_VALUES_MCU___ = {10.0e-012};

const bus_array_mcu S_BUSSES_MCU = {'E'};// pin 13

const bus_array_mcu A_BUSSES_MCU = {'B'};// pin 14

const bus_array_mcu B_BUSSES_MCU = {'C'};// pin 33

const bus_array_mcu I_BUSSES_MCU = {'H'};// pin 34

const mux_array_mcu MUX_NODE_ARRAY_MCU_____ = {6};

static int const INDUCTOR_FXT = 3801;

//------------------------------------------------------------------------------

/* PIN STANDARD COMPONENTS CAPACITORS USING NEW MCU BLOCK*/

void t9232(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;





  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];  // The below are all modified to suite the MCU block measurement/sri

  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

 // char s[MAX_S_LENGTH + 1];

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Capacitors Test requires a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9232 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.capacitor_MCU_HI_FREQ", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

      display_prompt("The 'std.capacitor_MCU_HI_FREQ' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);

		fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);

      }





	  /* These are for the debugging purposes!

      display_it(mod_id, "nominal_value[0] = ", nominal_value[0], nominal_value[0]);

      display_it(mod_id, "src_freq[0] = ", src_freq[0], src_freq[0]);

      display_it(mod_id, "src_amp[0] = ", src_amp[0], src_amp[0]);

      display_it(mod_id, "src_off[0] = ", src_off[0], src_off[0]);

      display_it(mod_id, "src_wait[0] = ", src_wait[0], src_wait[0]);

      display_it(mod_id, "src_comp[0] = ", src_comp[0], src_comp[0]);

      display_it(mod_id, "en[0] = ", en[0], en[0]);

      display_it(mod_id, "ed[0] = ", ed[0], ed[0]);

      display_it(mod_id, "rf[0] = ", rf[0], rf[0]);

      display_it(mod_id, "sa[0] = ", sa[0], sa[0]);

      display_it(mod_id, "sb[0] = ", sb[0], sb[0]);

      display_it(mod_id, "sl[0] = ", sl[0], sl[0]);

      display_it(mod_id, "wb[0] = ", wb[0], wb[0]);

      display_it(mod_id, "hfs_cap[0] = ", hfs_cap[0], hfs_cap[0]);

      display_it(mod_id, "diff_det[0] = ", diff_det[0], diff_det[0]);

      display_it(mod_id, "moa_out[0] = ", moa_out[0], moa_out[0]);

      display_it(mod_id, "det_wait[0] = ", det_wait[0], det_wait[0]);

      display_it(mod_id, "src_type[0] = ", src_type[0], src_type[0]);

      display_it(mod_id, "ser_mode[0] = ", ser_mode[0], ser_mode[0]);

      display_it(mod_id, "comp_type[0] = ", comp_type[0], comp_type[0]);

      display_it(mod_id, "dc_rej[0] = ", dc_rej[0], dc_rej[0]);

      display_it(mod_id, "ssvirt_card[0] = ", ssvirt_card[0], ssvirt_card[0]);

      */



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */



		  for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if (number_equal(nominal_value[reading], CAPACITOR_VALUES_MCU___[i - 1]))

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                   [S_BUSSES_MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                   [I_BUSSES_MCU[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                     [A_BUSSES_MCU[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                     [B_BUSSES_MCU[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





//########################old LCR capability #########################################

        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);*/



        //vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]); not required for MCU Block





//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function





//for reference purposes.



		/* - - - - - - - - - - - vth_mcu_rlc_measure - - - - - - - - - */

/*  Name  : vth_mcu_rlc_measure

   Author : Yue Zheng

   Date   : 11-Apr-2007



   Description:

      This routine is to do a rlc measurement using MCU block



   Parameters:

     fb_resistor      - Feedback resistor index

     rc_type          - Boolean: Device Under Test type; 0 - Res; 1 - Cap

	 average_count    - Number of measuremetns to average (fi option)

     src_freq         - Source frequence index;  0 - 128Hz, 1 - 1024Hz, 2 -8192

                           and 3-100k, 4-200k, 5-512, 6 - 4096

	 sense_a          - Flag: Sensing on bus a

     sense_b          - Flag: Sensing on bus b

     sense_l          - Flag: Sensing on bus l

     extra_digit      - Boolean: Indicates that the extra digit measurement

                           needs to be performed.

	 src_ampl         - The amplitude of the source

	 wait_time        - Wait time before first voltage measurement

	 moa_out_voltage  - Expected MOA output voltage

     low_limit        - The low measurement limit of the measurement

     high_limit       - The hgih measurement limit of the measurement

     opposite         - Boolean: Inicates if pass / fail criteria is

                           opposite of normal

     series_mode      - 1 -> series model

                        0 -> parallel model

	 audit_count      - Number of consecutive passes between audits



  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



       // vth_get_capacitor_result(mod_id);



//#####################################################################################



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                  [S_BUSSES_MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                  [I_BUSSES_MCU[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                    [A_BUSSES_MCU[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU_____[capacitor_no - 1]]

                    [B_BUSSES_MCU[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9232 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT







#undef RANGE

#undef RESOLUTION

#undef LOAD_RESISTANCE

#undef DMM_FUNCTION



///////////////////////////////////////////////END OF TEST 9232//////////////////////////////////////////



///////////////////////////////////////////////BEGINNIGN OF TEST T9240//////////////////////////////////

#define NUM_RESISTORS   9

#define NUM_MEASUREMENTS  22

#define PIN_SLOT        2

/* FOR 0.1 OHM RESISTOR ONLY */

#define FILTER          10

#define DEFAULT_FILTER  1

typedef double val_array[NUM_RESISTORS];

typedef int bus_array[NUM_RESISTORS];

typedef int mux_array[NUM_RESISTORS];

const val_array RESISTOR_VALUES______ = {100e-3, 1.0e0, 1.0e1, 1.0e2, 1e3, 1e4, 1e5, 1e6, 1e7};

const bus_array S_BUSSES_9240 = {'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array A_BUSSES_9240 = {'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array B_BUSSES_9240 = {'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array I_BUSSES_9240 = {'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array MUX_NODE_ARRAY_9240 = {2, 3, 4, 5, 6, 2, 3, 4, 5};

static int const INDUCTOR_FXT_4 = 3801;

//------------------------------------------------------------------------------

/* PIN STANDARD COMPONENTS RESISTORS */

void t9240(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int resistor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];



  infile = NULL;



// MD: Due to splitting the standard component fixture into

//     two fixtures (rc and ind) it was necessary to have an

//     "escape" loop so that the inductor fixture will not

//     run the RC tests and vice versa. This is NOT the best way

//     to do this however I have no time to do this the proper way



  if (get_fixture_id(mod_id) != INDUCTOR_FXT_4)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistors Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9240 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.resistor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

      {  /* FOR READING */

        for (i = 1; i <= NUM_RESISTORS; i++)

        {

          if ( number_equal(nominal_value[reading], RESISTOR_VALUES______[i - 1]) )

            resistor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                   [S_BUSSES_9240[resistor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                   [I_BUSSES_9240[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                     [A_BUSSES_9240[resistor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                     [B_BUSSES_9240[resistor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

        /* TO GETTING EACH INDIVIDUAL RESULT BACK. */

        vth_mra_in_mod(mod_id);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        /* FILTERING THE 0.1 OHM RESISTOR IS THE LABS IMMEDIATE SOLUTION TO */

        /* MEASUREMENT ACCURACY - RATHER THAN IMPLEMENT DETECTOR DOWNRANGING */

        /* VALID AT LEAST THROUGH A300 SOFTWARE. Tuesday, January 30, 1990 */

        if (resistor_no == 1)   /* 0.1 ohm resistor */

        {  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

          vth_ameas_set_averaging(mod_id, FILTER);

        }  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

        else

        {  /* USE THE DEFAULT FILTER VALUE */

          vth_ameas_set_averaging(mod_id, DEFAULT_FILTER);

        }  /* USE THE DEFAULT FILTER VALUE */



        vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_resistor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                  [S_BUSSES_9240[resistor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_9240[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                  [I_BUSSES_9240[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                    [A_BUSSES_9240[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_9240[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_9240[resistor_no - 1]]

                    [B_BUSSES_9240[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }  /* for READING */

    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9240 */





#undef NUM_RESISTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef FILTER

#undef DEFAULT_FILTER



////////////////////////////////////////////////END OF TEST 9240///////////////////////////////







//////////////BEGINNING OF TEST 9223(EQUAL TO T9240)-TEST ADDED FOR NASRU LOOSEN UP TEST LIMIT COMPARED TO T9240///////

#define NUM_RESISTORS   9

#define NUM_MEASUREMENTS  22

#define PIN_SLOT        2

/* FOR 0.1 OHM RESISTOR ONLY */

#define FILTER          10

#define DEFAULT_FILTER  1

typedef double val_array[NUM_RESISTORS];

typedef int bus_array[NUM_RESISTORS];

typedef int mux_array[NUM_RESISTORS];

const val_array RESISTOR_VALUES______NASRU = {100e-3, 1.0e0, 1.0e1, 1.0e2, 1e3, 1e4, 1e5, 1e6, 1e7};

const bus_array S_BUSSES_9223 = {'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array A_BUSSES_9223 = {'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array B_BUSSES_9223 = {'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array I_BUSSES_9223 = {'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array MUX_NODE_ARRAY_9223 = {2, 3, 4, 5, 6, 2, 3, 4, 5};

//static int const INDUCTOR_FXT_4 = 3801;

//------------------------------------------------------------------------------

/* PIN STANDARD COMPONENTS RESISTORS */

void t9223(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int resistor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];



  infile = NULL;



// MD: Due to splitting the standard component fixture into

//     two fixtures (rc and ind) it was necessary to have an

//     "escape" loop so that the inductor fixture will not

//     run the RC tests and vice versa. This is NOT the best way

//     to do this however I have no time to do this the proper way



  if (get_fixture_id(mod_id) != INDUCTOR_FXT_4)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistors Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9223 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.resistor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

      {  /* FOR READING */

        for (i = 1; i <= NUM_RESISTORS; i++)

        {

          if ( number_equal(nominal_value[reading], RESISTOR_VALUES______NASRU[i - 1]) )

            resistor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                   [S_BUSSES_9223[resistor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                   [I_BUSSES_9223[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                     [A_BUSSES_9223[resistor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                     [B_BUSSES_9223[resistor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

        /* TO GETTING EACH INDIVIDUAL RESULT BACK. */

        vth_mra_in_mod(mod_id);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        /* FILTERING THE 0.1 OHM RESISTOR IS THE LABS IMMEDIATE SOLUTION TO */

        /* MEASUREMENT ACCURACY - RATHER THAN IMPLEMENT DETECTOR DOWNRANGING */

        /* VALID AT LEAST THROUGH A300 SOFTWARE. Tuesday, January 30, 1990 */

        if (resistor_no == 1)   /* 0.1 ohm resistor */

        {  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

          vth_ameas_set_averaging(mod_id, FILTER);

        }  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

        else

        {  /* USE THE DEFAULT FILTER VALUE */

          vth_ameas_set_averaging(mod_id, DEFAULT_FILTER);

        }  /* USE THE DEFAULT FILTER VALUE */



        vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_resistor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                  [S_BUSSES_9223[resistor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_9223[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                  [I_BUSSES_9223[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                    [A_BUSSES_9223[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_9223[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_9223[resistor_no - 1]]

                    [B_BUSSES_9223[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }  /* for READING */

    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9223 */





#undef NUM_RESISTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef FILTER

#undef DEFAULT_FILTER





////////////////////////////////////////////////END OF TEST 9223///////////////////////////////





#define NUM_CAPACITORS  9

#define NUM_MEASUREMENTS  21

#define PIN_SLOT        3

typedef double val_array_[NUM_CAPACITORS];

typedef int bus_array_[NUM_CAPACITORS];

typedef int mux_array_[NUM_CAPACITORS];

const val_array_ CAPACITOR_VALUES = {150.0e-006, 15.0e-006, 1.5e-006, 150.0e-009, 15.0e-009, 1.5e-009, 150.0e-012, 15.0e-012, 10.0e-012};

const bus_array_ S_BUSSES_ = {'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E', 'E'};

const bus_array_ A_BUSSES_ = {'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F', 'F'};

const bus_array_ B_BUSSES_ = {'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G'};

const bus_array_ I_BUSSES_ = {'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H', 'H'};

const mux_array_ MUX_NODE_ARRAY_ = {3, 4, 5, 6, 2, 3, 4, 5, 6};

//------------------------------------------------------------------------------

/* PIN STANDARD LOW VALUE CAPACITORS WITHO

UT COMPENSATION */

void t9241(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;



  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Capacitors Test requires a pin or channel", true);

      display_prompt("type card in Slot 3.  Test 9241 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 3 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.capacitor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

      display_prompt("The 'std.capacitor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }

  /*

      display_it(mod_id, "nominal_value[0] = ", nominal_value[0], nominal_value[0]);

      display_it(mod_id, "src_freq[0] = ", src_freq[0], src_freq[0]);

      display_it(mod_id, "src_amp[0] = ", src_amp[0], src_amp[0]);

      display_it(mod_id, "src_off[0] = ", src_off[0], src_off[0]);

      display_it(mod_id, "src_wait[0] = ", src_wait[0], src_wait[0]);

      display_it(mod_id, "src_comp[0] = ", src_comp[0], src_comp[0]);

      display_it(mod_id, "en[0] = ", en[0], en[0]);

      display_it(mod_id, "ed[0] = ", ed[0], ed[0]);

      display_it(mod_id, "rf[0] = ", rf[0], rf[0]);

      display_it(mod_id, "sa[0] = ", sa[0], sa[0]);

      display_it(mod_id, "sb[0] = ", sb[0], sb[0]);

      display_it(mod_id, "sl[0] = ", sl[0], sl[0]);

      display_it(mod_id, "wb[0] = ", wb[0], wb[0]);

      display_it(mod_id, "hfs_cap[0] = ", hfs_cap[0], hfs_cap[0]);

      display_it(mod_id, "diff_det[0] = ", diff_det[0], diff_det[0]);

      display_it(mod_id, "moa_out[0] = ", moa_out[0], moa_out[0]);

      display_it(mod_id, "det_wait[0] = ", det_wait[0], det_wait[0]);

      display_it(mod_id, "src_type[0] = ", src_type[0], src_type[0]);

      display_it(mod_id, "ser_mode[0] = ", ser_mode[0], ser_mode[0]);

      display_it(mod_id, "comp_type[0] = ", comp_type[0], comp_type[0]);

      display_it(mod_id, "dc_rej[0] = ", dc_rej[0], dc_rej[0]);

      display_it(mod_id, "ssvirt_card[0] = ", ssvirt_card[0], ssvirt_card[0]);

      */



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal (nominal_value[reading], CAPACITOR_VALUES[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                   [S_BUSSES_[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                   [I_BUSSES_[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                     [A_BUSSES_[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                     [B_BUSSES_[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                  [S_BUSSES_[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                  [I_BUSSES_[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                    [A_BUSSES_[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_[capacitor_no - 1]]

                    [B_BUSSES_[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9241 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT





/////////////////////////////////////////////////Beginning of test T9242/////////////////////////////

#define NUM_INDUCTORS      9

#define NUM_MEASUREMENTS  13

#define PIN_SLOT           4

#define RC_FXT          3800

typedef double val_array__[NUM_INDUCTORS];

typedef int bus_array__[NUM_INDUCTORS];

typedef int mux_array__[NUM_INDUCTORS];

const val_array__ INDUCTOR_VALUES = {2e-6, 154e-6, 1.54e-3, 15.4e-3, 154e-3, 1.54, 15.4, 100.0, 20e-6};

const bus_array__ S_BUSSES__ = {'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array__ A_BUSSES__ = {'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array__ B_BUSSES__ = {'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array__ I_BUSSES__ = {'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array__ MUX_NODE_ARRAY__ = {2, 3, 4, 5, 6, 2, 3, 4, 6};

//------------------------------------------------------------------------------

/* INDUCTOR STANDARD COMPONENTS TESTS */

void t9242(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int inductor_no;

  FILE *infile;

  std_component_array actual_value;

  double value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != RC_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Inductors Test requires a pin or channel", true);

      display_prompt("type card in Slot 4.  Test 9242 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 4 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.inductor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.inductor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_INDUCTORS; i++)

        {

          if ( number_equal(value[reading], INDUCTOR_VALUES[i - 1]) )

            inductor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                   [S_BUSSES__[inductor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                   [I_BUSSES__[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                     [A_BUSSES__[inductor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                     [B_BUSSES__[inductor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_inductor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_inductor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                  [S_BUSSES__[inductor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES__[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                  [I_BUSSES__[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                    [A_BUSSES__[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES__[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__[inductor_no - 1]]

                    [B_BUSSES__[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }  /* Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9242 */

#undef NUM_INDUCTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef RC_FXT



///////////////////////////////////////END OF TEST 9242////////////////////////////////





///////////////////////////////BEGINNING OF T9224(EQUAL TO T9242 WITH LOOSEN TEST LIMIT)////////////

#define NUM_INDUCTORS      9

#define NUM_MEASUREMENTS  13

#define PIN_SLOT           4

#define RC_FXT          3800

typedef double val_array__[NUM_INDUCTORS];

typedef int bus_array__[NUM_INDUCTORS];

typedef int mux_array__[NUM_INDUCTORS];

const val_array__ INDUCTOR_VALUES_NASRU = {2e-6, 154e-6, 1.54e-3, 15.4e-3, 154e-3, 1.54, 15.4, 100.0, 20e-6};

const bus_array__ S_BUSSES__NASRU = {'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array__ A_BUSSES__NASRU = {'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array__ B_BUSSES__NASRU = {'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array__ I_BUSSES__NASRU = {'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array__ MUX_NODE_ARRAY__NASRU = {2, 3, 4, 5, 6, 2, 3, 4, 6};

//------------------------------------------------------------------------------

/* INDUCTOR STANDARD COMPONENTS TESTS */

void t9224(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int inductor_no;

  FILE *infile;

  std_component_array actual_value;

  double value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != RC_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Inductors Test requires a pin or channel", true);

      display_prompt("type card in Slot 4.  Test 9224 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 4 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.inductor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.inductor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_INDUCTORS; i++)

        {

          if ( number_equal(value[reading], INDUCTOR_VALUES_NASRU[i - 1]) )

            inductor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                   [S_BUSSES__NASRU[inductor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                   [I_BUSSES__NASRU[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                     [A_BUSSES__NASRU[inductor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                     [B_BUSSES__NASRU[inductor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_inductor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_inductor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                  [S_BUSSES__NASRU[inductor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES__NASRU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                  [I_BUSSES__NASRU[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                    [A_BUSSES__NASRU[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES__NASRU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__NASRU[inductor_no - 1]]

                    [B_BUSSES__NASRU[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }  /* Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9224 */

#undef NUM_INDUCTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef RC_FXT



//////////////////////////////////////END OF TEST 9224/////////////////////////////////////////////



#define NUM_COMPONENTS  2

#define NUM_MEASUREMENTS  2

#define PIN_SLOT        5

typedef double val_array___[NUM_COMPONENTS];

typedef int bus_array___[NUM_COMPONENTS];

typedef int mux_array___[NUM_COMPONENTS];

const val_array___ COMPONENT_VALUES = {10e3, 100e3};

const bus_array___ I_BUSSES___ = {'A', 'A'};

const bus_array___ B_BUSSES___ = {'B', 'B'};

const bus_array___ A_BUSSES___ = {'C', 'C'};

const bus_array___ S_BUSSES___ = {'D', 'D'};

const bus_array___ L_BUSSES = {'E', 'E'};

const bus_array___ G_BUSSES = {'F', 'F'};

const mux_array___ EXTRA_B_BUS = {7, 8};

const mux_array___ MUX_NODE_ARRAY___ = {2, 3};

//------------------------------------------------------------------------------

/* RESISTOR STANDARD COMPONENTS DELTA NETWORKS */

void t9243(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int component_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistor Deltas require a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9243 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.rdelta", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.rdelta' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {  /* FOR READING */

        for (i = 1; i <= NUM_COMPONENTS; i++)

        {

          if ( number_equal(nominal_value[reading], COMPONENT_VALUES[i - 1]) )

            component_no = i;

        }



       card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select all Channel Virtual Cards */

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                   [S_BUSSES___[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                   [I_BUSSES___[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE G BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K752);

        vth_aclose_rly(mod_id, K814);

        vth_pclose_rly(mod_id, PIN_SLOT, KDCG);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KGL_RLYS[G_BUSSES[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_DRVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                   [G_BUSSES[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                     [A_BUSSES___[component_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                     [B_BUSSES___[component_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* CONNECT THE L BUS */

          vth_aclose_rly(mod_id, AIM_X_L_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                     [L_BUSSES[component_no - 1] - 'A']);

        }  /* CONNECT THE L BUS */





        /* CLOSE THE ADDITIONAL CONNECTION TO THE B BUS TO COMPLETE THE NETWORK */

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[EXTRA_B_BUS[component_no - 1]]

                   [B_BUSSES___[component_no - 1] - 'A']);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        /* The following section was removed.  The benefit was marginal and it is not

           how IPG would handle the test, ie. it's cheating. 5-24-91 BDB              */



        /*     if (component_no = 2) then

                begin

                vth_adet_sel_rng(mod_id,0) ;

                vth_adet_store_src_rng(mod_id,0) ;

                end ;

        */



        vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_resistor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                  [S_BUSSES___[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES___[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                  [I_BUSSES___[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE G BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K752);

        vth_aopen_rly(mod_id, K814);

        vth_popen_rly(mod_id, PIN_SLOT, KDCG);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KGL_RLYS[G_BUSSES[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_DRVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                  [G_BUSSES[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                    [A_BUSSES___[component_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES___[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                    [B_BUSSES___[component_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* DISCONNECT THE L BUS */

          vth_aopen_rly(mod_id, AIM_X_L_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[L_BUSSES[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___[component_no - 1]]

                    [L_BUSSES[component_no - 1] - 'A']);

        }  /* DISCONNECT THE L BUS */





        /* OPEN THE ADDITIONAL CONNECTION TO THE I BUS TO COMPLETE THE NETWORK */



        vth_popen_rly(mod_id, PIN_SLOT, PIN_RCVR_RLYS[EXTRA_B_BUS[component_no - 1]]

                  [B_BUSSES___[component_no - 1] - 'A']);



      }  /* FOR READING */

    }  /* Do the test*/

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9243 */

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT



#define NUM_COMPONENTS  1

#define NUM_MEASUREMENTS  1

#define PIN_SLOT        5

typedef double val_array____[NUM_COMPONENTS];

typedef int bus_array____[NUM_COMPONENTS];

typedef int mux_array____[NUM_COMPONENTS];

const val_array____ COMPONENT_VALUES_ = {1e-9};

const bus_array____ I_BUSSES____ = {'A'};

const bus_array____ B_BUSSES____ = {'B'};

const bus_array____ A_BUSSES____ = {'C'};

const bus_array____ S_BUSSES____ = {'D'};

const bus_array____ L_BUSSES_ = {'E'};

const bus_array____ G_BUSSES_ = {'F'};

const mux_array____ EXTRA_B_BUS_ = {7};

const mux_array____ MUX_NODE_ARRAY____ = {4};

//------------------------------------------------------------------------------

/* CAPACITOR STANDARD COMPONENTS DELTA NETWORKS */

void t9244(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int component_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Capacitor Delta requires a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9244 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.cdelta", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.cdelta' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {  /* FOR READING */

        for (i = 1; i <= NUM_COMPONENTS; i++)

        {

          if ( number_equal(nominal_value[reading], COMPONENT_VALUES_[i - 1]) )

            component_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                   [S_BUSSES____[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                   [I_BUSSES____[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE G BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K752);

        vth_aclose_rly(mod_id, K814);

        vth_pclose_rly(mod_id, PIN_SLOT, KDCG);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KGL_RLYS[G_BUSSES_[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_DRVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                   [G_BUSSES_[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                     [A_BUSSES____[component_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                     [B_BUSSES____[component_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* CONNECT THE L BUS */

          vth_aclose_rly(mod_id, AIM_X_L_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                     [L_BUSSES_[component_no - 1] - 'A']);

        }  /* CONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* CLOSE THE ADDITIONAL CONNECTION TO THE B BUS TO COMPLETE THE NETWORK */

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[EXTRA_B_BUS_[component_no - 1]]

                   [B_BUSSES____[component_no - 1] - 'A']);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                  [S_BUSSES____[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                  [I_BUSSES____[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE G BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K752);

        vth_aopen_rly(mod_id, K814);

        vth_popen_rly(mod_id, PIN_SLOT, KDCG);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KGL_RLYS[G_BUSSES_[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_DRVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                  [G_BUSSES_[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                    [A_BUSSES____[component_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                    [B_BUSSES____[component_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* DISCONNECT THE L BUS */

          vth_aopen_rly(mod_id, AIM_X_L_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[L_BUSSES_[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY____[component_no - 1]]

                    [L_BUSSES_[component_no - 1] - 'A']);

        }  /* DISCONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* OPEN THE ADDITIONAL CONNECTION TO THE I BUS TO COMPLETE THE NETWORK */



        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[EXTRA_B_BUS_[component_no - 1]]

                  [B_BUSSES____[component_no - 1] - 'A']);



      }  /* FOR READING */

    }  /* Do the test*/

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9244 */

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT



#define NUM_COMPONENTS  1

#define NUM_MEASUREMENTS  1

#define PIN_SLOT        5

typedef double val_array_____[NUM_COMPONENTS];

typedef int bus_array_____[NUM_COMPONENTS];

typedef int mux_array_____[NUM_COMPONENTS];

const val_array_____ COMPONENT_VALUES__ = {10e-3};

const bus_array_____ I_BUSSES_____ = {'A'};

const bus_array_____ B_BUSSES_____ = {'B'};

const bus_array_____ A_BUSSES_____ = {'C'};

const bus_array_____ S_BUSSES_____ = {'D'};

const bus_array_____ L_BUSSES__ = {'E'};

const bus_array_____ G_BUSSES__ = {'F'};

const mux_array_____ EXTRA_B_BUS__ = {8};        /* virtual card #2 */

const mux_array_____ MUX_NODE_ARRAY_____ = {5};  /* virtual card #1 */

//------------------------------------------------------------------------------

/* INDUCTOR STANDARD COMPONENTS DELTA NETWORKS */

void t9245(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int component_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Inductor Delta requires a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9245 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.ldelta", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.ldelta' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {  /* FOR READING */

        for (i = 1; i <= NUM_COMPONENTS; i++)

        {

          if ( number_equal(nominal_value[reading], COMPONENT_VALUES__[i - 1]) )

            component_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                   [S_BUSSES_____[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                   [I_BUSSES_____[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE G BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K752);

        vth_aclose_rly(mod_id, K814);

        vth_pclose_rly(mod_id, PIN_SLOT, KDCG);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KGL_RLYS[G_BUSSES__[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_DRVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                   [G_BUSSES__[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_A_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                     [A_BUSSES_____[component_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_B_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                     [B_BUSSES_____[component_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* CONNECT THE L BUS */

          vth_aclose_rly(mod_id, AIM_X_L_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                     [L_BUSSES__[component_no - 1] - 'A']);

        }  /* CONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* CLOSE THE ADDITIONAL CONNECTION TO THE B BUS TO COMPLETE THE NETWORK */

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[EXTRA_B_BUS__[component_no - 1]]

                   [B_BUSSES_____[component_no - 1] - 'A']);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_inductor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_inductor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                  [S_BUSSES_____[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_____[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                  [I_BUSSES_____[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE G BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K752);

        vth_aopen_rly(mod_id, K814);

        vth_popen_rly(mod_id, PIN_SLOT, KDCG);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KGL_RLYS[G_BUSSES__[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_DRVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                  [G_BUSSES__[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                    [A_BUSSES_____[component_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_____[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                    [B_BUSSES_____[component_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* DISCONNECT THE L BUS */

          vth_aopen_rly(mod_id, AIM_X_L_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[L_BUSSES__[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____[component_no - 1]]

                    [L_BUSSES__[component_no - 1] - 'A']);

        }  /* DISCONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* OPEN THE ADDITIONAL CONNECTION TO THE I BUS TO COMPLETE THE NETWORK */



        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[EXTRA_B_BUS__[component_no - 1]]

                  [B_BUSSES_____[component_no - 1] - 'A']);



      }  /* FOR READING */

    }  /* Do the test*/

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);



} /* t9245 */

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef RC_FXT





//////////////////////////////////////BEGINNING OF T9246///////////////////////



#define NUM_CAPACITORS  6

#define NUM_MEASUREMENTS  11

#define PIN_SLOT        3

#define DGN_INFINITY    1e31

typedef double val_array______[NUM_CAPACITORS];

typedef int bus_array______[NUM_CAPACITORS];

typedef int mux_array______[NUM_CAPACITORS];

const val_array______ CAPACITOR_VALUES_ = {150.0e-009, 15.0e-009, 1.5e-009, 150.0e-012, 15.0e-012, 10.0e-012};

const bus_array______ S_BUSSES______ = {'A', 'E', 'E', 'E', 'E', 'E'};

const bus_array______ I_BUSSES______ = {'D', 'H', 'H', 'H', 'H', 'H'};

const mux_array______ MUX_NODE_ARRAY______ = {6, 2, 3, 4, 5, 6};

//------------------------------------------------------------------------------

// PIN STANDARD LOW VALUE CAPACITORS WITH COMPENSATION

void t9246(int mod_id, int /*slot*/)

{

  int next;

  double capacitor_reading;

  double compensation_reading;

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char s[MAX_S_LENGTH + 1];

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Caps Compensated Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 3.  Test 9246 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 3 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.compcap", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.compcap' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES_[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the appropriate virtual card*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

          compensation_reading = result.UU.Real_result;

        else

        {  /* No result present */

          display_prompt("No result in result log (Expected component value)",

                         true);

          compensation_reading = 0.0;

        }  /* No result present */



        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______[capacitor_no - 1]]

                   [S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______[capacitor_no - 1]]

                   [I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

          capacitor_reading = result.UU.Real_result;

        else

        {

          display_prompt("No result in result log (Expected comp value)", true);

          capacitor_reading = DGN_INFINITY - 1;

        }



        result.UU.Real_result = capacitor_reading - compensation_reading;

        result.UU.Real_result -= actual_value[reading];

        /* DEBUG */

        if (result.UU.Real_result > 1000)

        {

          sprintf(s, "%1.12f", compensation_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

          /* DEBUG */

          sprintf(s, "%1.12f", capacitor_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

        }

        log_result(mod_id, result);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______[capacitor_no - 1]]

                  [S_BUSSES______[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______[capacitor_no - 1]]

                  [I_BUSSES______[capacitor_no - 1] - 'A']);



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9246 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY



/////////////////////////////////////////////////END OF TEST 9246///////////////////////





///////////////////////////BEGINNING OF TEST T9225(EQUAL TO T9246 WITH LOOSEN TEST LIMIT FOR NASRU//////////



#define NUM_CAPACITORS  6

#define NUM_MEASUREMENTS  11

#define PIN_SLOT        3

#define DGN_INFINITY    1e31

typedef double val_array______[NUM_CAPACITORS];

typedef int bus_array______[NUM_CAPACITORS];

typedef int mux_array______[NUM_CAPACITORS];

const val_array______ CAPACITOR_VALUES_NASRU = {150.0e-009, 15.0e-009, 1.5e-009, 150.0e-012, 15.0e-012, 10.0e-012};

const bus_array______ S_BUSSES______NASRU = {'A', 'E', 'E', 'E', 'E', 'E'};

const bus_array______ I_BUSSES______NASRU = {'D', 'H', 'H', 'H', 'H', 'H'};

const mux_array______ MUX_NODE_ARRAY______NASRU = {6, 2, 3, 4, 5, 6};

//------------------------------------------------------------------------------

// PIN STANDARD LOW VALUE CAPACITORS WITH COMPENSATION

void t9225(int mod_id, int /*slot*/)

{

  int next;

  double capacitor_reading;

  double compensation_reading;

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char s[MAX_S_LENGTH + 1];

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Caps Compensated Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 3.  Test 9225 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 3 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.compcap", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.compcap' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES_NASRU[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the appropriate virtual card*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES______NASRU[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

          compensation_reading = result.UU.Real_result;

        else

        {  /* No result present */

          display_prompt("No result in result log (Expected component value)",

                         true);

          compensation_reading = 0.0;

        }  /* No result present */



        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______NASRU[capacitor_no - 1]]

                   [S_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______NASRU[capacitor_no - 1]]

                   [I_BUSSES______NASRU[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

          capacitor_reading = result.UU.Real_result;

        else

        {

          display_prompt("No result in result log (Expected comp value)", true);

          capacitor_reading = DGN_INFINITY - 1;

        }



        result.UU.Real_result = capacitor_reading - compensation_reading;

        result.UU.Real_result -= actual_value[reading];

        /* DEBUG */

        if (result.UU.Real_result > 1000)

        {

          sprintf(s, "%1.12f", compensation_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

          /* DEBUG */

          sprintf(s, "%1.12f", capacitor_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

        }

        log_result(mod_id, result);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______NASRU[capacitor_no - 1]]

                  [S_BUSSES______[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______NASRU[capacitor_no - 1]]

                  [I_BUSSES______[capacitor_no - 1] - 'A']);



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9225 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY



/////////////////////////////////////////////////END OF TEST T9225//////////////////////





#define NUM_CAPACITORS  3

#define NUM_MEASUREMENTS  3

#define PIN_SLOT        5

typedef double val_array_______[NUM_CAPACITORS];

typedef int bus_array_______[NUM_CAPACITORS];

typedef int mux_array_______[NUM_CAPACITORS];

const val_array_______ CAPACITOR_VALUES__ = {10e-003, 1e-003, 100e-006};

const bus_array_______ S_BUSSES_______ = {'H', 'H', 'H'};

const bus_array_______ A_BUSSES_______ = {'G', 'G', 'G'};

const bus_array_______ B_BUSSES_______ = {'F', 'F', 'F'};

const bus_array_______ I_BUSSES_______ = {'E', 'E', 'E'};

const mux_array_______ MUX_NODE_ARRAY_______ = {6, 3, 2};

//------------------------------------------------------------------------------

/* CAPACITOR STANDARD COMPONENTS - LARGE VALUE */

void t9247(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;





  if (get_fixture_id(mod_id) != INDUCTOR_FXT) //sri std 9247

    if ( INDUCTOR_FXT != 3)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Large Value Caps Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 5.  Test 9247 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.largecap", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.largecap' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d", &dc_rej[reading]);

        fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES__[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the appropriate virtual card*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_S_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                   [S_BUSSES_______[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_I_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                   [I_BUSSES_______[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_A_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                     [A_BUSSES_______[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */



        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_B_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                     [B_BUSSES_______[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */



        vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];//sri std t9247

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected comp value)", true);



        vth_astat_rd(mod_id);

        if (!get_result_nolog(mod_id, &result))

          display_prompt("No result in result log (Expected aim stat)", true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                  [S_BUSSES_______[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_______[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                  [I_BUSSES_______[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id,

                    AIM_X_A_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                    [A_BUSSES_______[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */



        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id,

                    AIM_X_B_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_______[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_______[capacitor_no - 1]]

                    [B_BUSSES_______[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

}/* t9247 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT



#define PIN_SLOT        2

/* PIN STANDARD COMPONENTS RESISTOR MEASUREMENT */

void t9248(int mod_id, int /*slot*/)

{

  FILE *infile;     //  Richard Devore

  test_result_type result;

  infile = NULL;

  char buffer[81];



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))



    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistors Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9247 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;



      sprintf(buffer, "%sstd.resistor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        /* CONNECT THE A BUS */

        /* CONNECT THE B BUS */

        /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

        /* TO GETTING EACH INDIVIDUAL RESULT BACK. */



        vth_aclose_rly(mod_id,K733);

        vth_pclose_rly(mod_id, PIN_SLOT, KDC1);

        vth_pclose_rly(mod_id, PIN_SLOT, KX1);

        vth_pclose_rly(mod_id, PIN_SLOT, K16E);

        vth_aclose_rly(mod_id,K728) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC4);

        vth_pclose_rly(mod_id, PIN_SLOT, KX4);

        vth_pclose_rly(mod_id, PIN_SLOT, K16G);



        vth_aclose_rly(mod_id,K710) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC2);

        vth_pclose_rly(mod_id, PIN_SLOT, KX2);

        vth_pclose_rly(mod_id, PIN_SLOT, K16F);

        vth_aclose_rly(mod_id,K703) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC3);

        vth_pclose_rly(mod_id, PIN_SLOT, KX3);

        vth_pclose_rly(mod_id, PIN_SLOT, K16H);

        vth_mra_in_mod(mod_id);



        vth_rlc_setup(mod_id, 1024, 1.0, 0.0, 0.0, 1, 0, 1, 5, 0, 0, 0, 1, 0, 0, 0.1, 0.0);

        vth_ameas_set_averaging(mod_id, 1);

        vth_capacitor_meas(mod_id, 1, 1);



        vth_get_capacitor_result(mod_id);



        if (get_result_nolog(mod_id, &result))

        {

          log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        /* DISCONNECT THE A BUS */

        /* DISCONNECT THE B BUS */

        /* DISCONNECT THE B BUS */



        vth_aopen_rly(mod_id,K733) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC1);

        vth_popen_rly(mod_id, PIN_SLOT, KX1);

        vth_popen_rly(mod_id, PIN_SLOT, K16E);

        vth_aopen_rly(mod_id,K728) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC4);

        vth_popen_rly(mod_id, PIN_SLOT, KX4);

        vth_popen_rly(mod_id, PIN_SLOT, K16G);



        vth_aopen_rly(mod_id,K710) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC2);

        vth_popen_rly(mod_id, PIN_SLOT, KX2);

        vth_popen_rly(mod_id, PIN_SLOT, K16F);

        vth_aopen_rly(mod_id,K703) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC3);

        vth_popen_rly(mod_id, PIN_SLOT, KX3);

        vth_popen_rly(mod_id, PIN_SLOT, K16H);



    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9248 */

#undef PIN_SLOT



#define NUM_RESISTORS   9

#define NUM_MEASUREMENTS  22

#define PIN_SLOT        2

/* FOR 1M OHM RESISTOR ONLY */

#define FILTER          10

#define DEFAULT_FILTER  1

typedef double val_array________[NUM_RESISTORS];

typedef int bus_array________[NUM_RESISTORS];

typedef int mux_array________[NUM_RESISTORS];

const val_array________ RESISTOR_VALUES_ = {100e-3, 1.0e0, 1.0e1, 1.0e2, 1e3, 1e4, 1e5, 1e6, 1e7};

const bus_array________ S_BUSSES________ = {'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array________ A_BUSSES________ = {'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array________ B_BUSSES________ = {'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array________ I_BUSSES________ = {'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array________ MUX_NODE_ARRAY________ = {2, 3, 4, 5, 6, 2, 3, 4, 5};

//------------------------------------------------------------------------------

/* RESISTOR STANDARD COMPONENTS */

void t9249(int mod_id, int slot)

{

  int reading;

  int i;

  int resistor_no;

  FILE *infile;

  double nominal_value[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

  char buffer[81];

  infile = NULL;



  if ((card_type != CDDP) && (card_type != CDD20) &&

      (card_type != CDD6) && (card_type != CDDJB) &&

      (card_type != CDDU) && (card_type != PIN) &&

      (card_type != PIN6) && (card_type != PIN6JB) &&

      (card_type != PIN12JB) && (card_type != PINTERM) &&

      (card_type != PIN20) && (card_type != CP) &&

      (card_type != CP20) && (card_type != ANALOG) &&

      (card_type != DD6) && (card_type != DDJB) &&

      (card_type != DDP) && (card_type != DD20) &&

      (card_type != SD6) && (card_type != SDP) &&

      (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

      (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

      (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

      (card_type != FDDU) && (card_type != VCDD2) &&

      (card_type != VFDD2))

  {  /*Display no pin card in pin_slot message*/

    display_prompt("Standard Resistors Test requires a pin or channel", true);

    display_prompt("type card in Slot 2.  Test 9249 will not be run!", true);

  }  /*Display no pin card in pin_slot message*/

  else

  {  /* After check for slot 2 pin card */

      sprintf(buffer, "%sstd.resistor", testwhere_path);

	  infile = fopen(buffer, "r");



    if (infile == NULL)

    {

      display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

      _EscIO(FileNotFound);

    }



    for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

    {

      fscanf(infile, "%lg", &nominal_value[reading]);

      fscanf(infile, "%d", &src_freq[reading]);

      fscanf(infile, "%lg", &src_amp[reading]);

      fscanf(infile, "%lg", &src_off[reading]);

      fscanf(infile, "%lg", &src_wait[reading]);

      fscanf(infile, "%d", &src_comp[reading]);

      fscanf(infile, "%d", &en[reading]);

      fscanf(infile, "%d", &ed[reading]);

      fscanf(infile, "%d", &rf[reading]);

      fscanf(infile, "%d", &sa[reading]);

      fscanf(infile, "%d", &sb[reading]);

      fscanf(infile, "%d", &sl[reading]);

      fscanf(infile, "%d", &wb[reading]);

      fscanf(infile, "%d", &hfs_cap[reading]);

      fscanf(infile, "%d", &diff_det[reading]);

      fscanf(infile, "%lg", &moa_out[reading]);

      fscanf(infile, "%lg", &det_wait[reading]);

      fscanf(infile, "%d", &src_type[reading]);

      fscanf(infile, "%d", &ser_mode[reading]);

      fscanf(infile, "%d", &comp_type[reading]);

      fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

      getc(infile);



    }



    if (infile != NULL)

      fclose(infile);

    infile = NULL;



    for (reading = 19; reading < NUM_MEASUREMENTS; reading++)

        /* FOR READING */

        {  /* FOR READING */

      for (i = 1; i <= NUM_RESISTORS; i++)

      {

        if ( number_equal(nominal_value[reading], RESISTOR_VALUES_[i - 1]) )

          resistor_no = i;

      }



      /*select all Channel Virtual Cards */

      virt_card_select(mod_id, slot, 3);



      /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

      vth_aclose_rly(mod_id,

                 AIM_X_S_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_KDC_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_KX_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                 [S_BUSSES________[resistor_no - 1] - 'A']);



      /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

      vth_aclose_rly(mod_id,

                 AIM_X_I_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_KDC_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_KX_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_pclose_rly(mod_id, slot,

                 PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                 [I_BUSSES________[resistor_no - 1] - 'A']);



      if (sa[reading] == 1)

      {  /* CONNECT THE A BUS */

        vth_aclose_rly(mod_id,

                   AIM_X_A_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_KDC_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_KX_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                   [A_BUSSES________[resistor_no - 1] - 'A']);

      }  /* CONNECT THE A BUS */





      if (sb[reading] == 1)

      {  /* CONNECT THE B BUS */

        vth_aclose_rly(mod_id,

                   AIM_X_B_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_KDC_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_KX_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, slot,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                   [B_BUSSES________[resistor_no - 1] - 'A']);

      }  /* CONNECT THE B BUS */







      /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

      /* TO GETTING EACH INDIVIDUAL RESULT BACK. */

      vth_mra_in_mod(mod_id);



      vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                src_wait[reading], src_comp[reading], en[reading],

                ed[reading], rf[reading], sa[reading], sb[reading],

                sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                moa_out[reading], det_wait[reading]);



      if (reading + 1 == 21)   /* 1M ohm resistor EN/ ED/*/

      {  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

        vth_ameas_set_averaging(mod_id, FILTER);

      }  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

      else

      {  /* USE THE DEFAULT FILTER VALUE */

        vth_ameas_set_averaging(mod_id, DEFAULT_FILTER);

      }  /* USE THE DEFAULT FILTER VALUE */



      vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



      vth_get_resistor_result(mod_id);



      /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

      vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_KDC_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_KX_RLYS[S_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                [S_BUSSES________[resistor_no - 1] - 'A']);



      /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

      vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_KDC_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_KX_RLYS[I_BUSSES________[resistor_no - 1] - 'A']);

      vth_popen_rly(mod_id, slot,

                PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                [I_BUSSES________[resistor_no - 1] - 'A']);



      if (sa[reading] == 1)

      {  /* DISCONNECT THE A BUS */

        vth_aopen_rly(mod_id,

                  AIM_X_A_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_KDC_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_KX_RLYS[A_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                  [A_BUSSES________[resistor_no - 1] - 'A']);

      }  /* DISCONNECT THE A BUS */





      if (sb[reading] == 1)

      {  /* DISCONNECT THE B BUS */

        vth_aopen_rly(mod_id,

                  AIM_X_B_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_KDC_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_KX_RLYS[B_BUSSES________[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, slot,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY________[resistor_no - 1]]

                  [B_BUSSES________[resistor_no - 1] - 'A']);

      }  /* DISCONNECT THE B BUS */



    }

  }  /* Do the test */



  if (infile != NULL)

    fclose(infile);

} /* t9249 */

#undef NUM_RESISTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef FILTER

#undef DEFAULT_FILTER









//////////////////////////////// Added by Sri Tharan for NASRU STD. COMP test ///////////////////////////

//#############################test added for replicated std. cmp. test # 9240-9248####################//

//####### new test number assigned for NASRU Std. Component test:9233, 9234, 9235, 9236, 9237, 9238, 9239, 9222#####//



#define NUM_RESISTORS_NASRU_MCU   8 //9 EXCLUDE 0.1OHM FOR NASRU MCU

#define NUM_MEASUREMENTS  21//22>>> 0.1 OHM CANT BE MEASURED BY NASRU MCU

#define PIN_SLOT        2

/* FOR 0.1 OHM RESISTOR ONLY */

#define FILTER          10

#define DEFAULT_FILTER  1

typedef double val_array_nasru[NUM_RESISTORS_NASRU_MCU];

typedef int bus_array_nasru[NUM_RESISTORS_NASRU_MCU];

typedef int mux_array_nasru[NUM_RESISTORS_NASRU_MCU];

const val_array_nasru RESISTOR_VALUES = {1.0e0, 1.0e1, 1.0e2, 1e3, 1e4, 1e5, 1e6, 1e7};// {100e-3, 1.0e0, 1.0e1, 1.0e2, 1e3, 1e4, 1e5, 1e6, 1e7};

const bus_array_nasru S_BUSSES = {'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'}; //{'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array_nasru A_BUSSES = {'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};//{'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array_nasru B_BUSSES = {'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};//{'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array_nasru I_BUSSES = {'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};//{'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array_nasru MUX_NODE_ARRAY = {3, 4, 5, 6, 2, 3, 4, 5};//{2, 3, 4, 5, 6, 2, 3, 4, 5};

static int const INDUCTOR_FXT_3 = 3801;

//------------------------------------------------------------------------------

/* PIN STANDARD COMPONENTS RESISTORS USING NEW MCU BLOCK */

void t9233(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int resistor_no;

  FILE *infile;

  std_component_array actual_value;



  double nominal_value[NUM_MEASUREMENTS];  // The below are all modified to suite the MCU block measurement/sri

  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];



  test_result_type result;

  char buffer[81];



  infile = NULL;



// MD: Due to splitting the standard component fixture into

//     two fixtures (rc and ind) it was necessary to have an

//     "escape" loop so that the inductor fixture will not

//     run the RC tests and vice versa. This is NOT the best way

//     to do this however I have no time to do this the proper way



  if (get_fixture_id(mod_id) != INDUCTOR_FXT_3)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistors Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9240 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.resistor_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



        fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);



		getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

      {  /* FOR READING */

        for (i = 1; i <= NUM_RESISTORS_NASRU_MCU; i++)

        {

          if ( number_equal(nominal_value[reading], RESISTOR_VALUES[i - 1]) )

            resistor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                   [S_BUSSES[resistor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                   [I_BUSSES[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                     [A_BUSSES[resistor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                     [B_BUSSES[resistor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

		vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



       // vth_get_resistor_result(mod_id);



//#####################################################################################





        /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

        /* TO GETTING EACH INDIVIDUAL RESULT BACK. */

       // vth_mra_in_mod(mod_id);



        //vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

        //          src_wait[reading], src_comp[reading], en[reading],

        //          ed[reading], rf[reading], sa[reading], sb[reading],

        //          sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

        //          moa_out[reading], det_wait[reading]);



        /* FILTERING THE 0.1 OHM RESISTOR IS THE LABS IMMEDIATE SOLUTION TO */

        /* MEASUREMENT ACCURACY - RATHER THAN IMPLEMENT DETECTOR DOWNRANGING */

        /* VALID AT LEAST THROUGH A300 SOFTWARE. Tuesday, January 30, 1990 */

        //if (resistor_no == 1)   /* 0.1 ohm resistor */

        //{  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

        //  vth_ameas_set_averaging(mod_id, FILTER);

        //}  /* TURN FILTERING ON TO DECREASE THE DISTRIBUTION OF THE READINGS */

        //else

        //{  /* USE THE DEFAULT FILTER VALUE */

        //  vth_ameas_set_averaging(mod_id, DEFAULT_FILTER);

        //}  /* USE THE DEFAULT FILTER VALUE */



        //vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        //vth_get_resistor_result(mod_id);

///////////////////////////////////////////////////////////////////////////



        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                  [S_BUSSES[resistor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES[resistor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                  [I_BUSSES[resistor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                    [A_BUSSES[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES[resistor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY[resistor_no - 1]]

                    [B_BUSSES[resistor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }  /* for READING */

    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9233 */





#undef NUM_RESISTORS_NASRU_MCU

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef FILTER

#undef DEFAULT_FILTER

















#undef RANGE

#undef RESOLUTION

#undef LOAD_RESISTANCE

#undef DMM_FUNCTION



#define NUM_CAPACITORS  9

#define NUM_MEASUREMENTS  21

#define PIN_SLOT        3

typedef double val_array_mcu_[NUM_CAPACITORS];

typedef int bus_array_mcu_[NUM_CAPACITORS];

typedef int mux_array_mcu_[NUM_CAPACITORS];

const val_array_mcu_ CAPACITOR_VALUES____ = {150.0e-006, 15.0e-006, 1.5e-006, 150.0e-009, 15.0e-009, 1.5e-009, 150.0e-012, 15.0e-012, 10.0e-012};

const bus_array_mcu_ S_BUSSES_MCU_ = {'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E', 'E'};

const bus_array_mcu_ A_BUSSES_MCU_ = {'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F', 'F'};

const bus_array_mcu_ B_BUSSES_MCU_ = {'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G'};

const bus_array_mcu_ I_BUSSES_MCU_ = {'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H', 'H'};

const mux_array_mcu_ MUX_NODE_ARRAY_MCU = {3, 4, 5, 6, 2, 3, 4, 5, 6};

//------------------------------------------------------------------------------

/* PIN STANDARD LOW VALUE CAPACITORS WITHO

UT COMPENSATION */

void t9234(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];



  test_result_type result;



  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Capacitors Test requires a pin or channel", true);

      display_prompt("type card in Slot 3.  Test 9241 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 3 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.capacitor_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

      display_prompt("The 'std.capacitor_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



		fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

        fscanf(infile, "%d", &ac[reading]);

		fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }

  /*

      display_it(mod_id, "nominal_value[0] = ", nominal_value[0], nominal_value[0]);

      display_it(mod_id, "src_freq[0] = ", src_freq[0], src_freq[0]);

      display_it(mod_id, "src_amp[0] = ", src_amp[0], src_amp[0]);

      display_it(mod_id, "src_off[0] = ", src_off[0], src_off[0]);

      display_it(mod_id, "src_wait[0] = ", src_wait[0], src_wait[0]);

      display_it(mod_id, "src_comp[0] = ", src_comp[0], src_comp[0]);

      display_it(mod_id, "en[0] = ", en[0], en[0]);

      display_it(mod_id, "ed[0] = ", ed[0], ed[0]);

      display_it(mod_id, "rf[0] = ", rf[0], rf[0]);

      display_it(mod_id, "sa[0] = ", sa[0], sa[0]);

      display_it(mod_id, "sb[0] = ", sb[0], sb[0]);

      display_it(mod_id, "sl[0] = ", sl[0], sl[0]);

      display_it(mod_id, "wb[0] = ", wb[0], wb[0]);

      display_it(mod_id, "hfs_cap[0] = ", hfs_cap[0], hfs_cap[0]);

      display_it(mod_id, "diff_det[0] = ", diff_det[0], diff_det[0]);

      display_it(mod_id, "moa_out[0] = ", moa_out[0], moa_out[0]);

      display_it(mod_id, "det_wait[0] = ", det_wait[0], det_wait[0]);

      display_it(mod_id, "src_type[0] = ", src_type[0], src_type[0]);

      display_it(mod_id, "ser_mode[0] = ", ser_mode[0], ser_mode[0]);

      display_it(mod_id, "comp_type[0] = ", comp_type[0], comp_type[0]);

      display_it(mod_id, "dc_rej[0] = ", dc_rej[0], dc_rej[0]);

      display_it(mod_id, "ssvirt_card[0] = ", ssvirt_card[0], ssvirt_card[0]);

      */



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal (nominal_value[reading], CAPACITOR_VALUES____[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                   [S_BUSSES_MCU_[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                   [I_BUSSES_MCU_[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                     [A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                     [B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





//##########################################################################################

        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id); */

//##########################################################################################



//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        	vth_set_dgn_use_mcu_flag(mod_id);

		    vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_capacitor_result(mod_id);



//#####################################################################################





        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                  [S_BUSSES_MCU_[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                  [I_BUSSES_MCU_[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                    [A_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_MCU[capacitor_no - 1]]

                    [B_BUSSES_MCU_[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9234 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT



#define NUM_INDUCTORS      8//9>> 2u cant be tested with NASRU MCU

#define NUM_MEASUREMENTS  12//13

#define PIN_SLOT           4

#define RC_FXT          3800

typedef double val_array__mcu[NUM_INDUCTORS];

typedef int bus_array__mcu[NUM_INDUCTORS];

typedef int mux_array__mcu[NUM_INDUCTORS];

const val_array__mcu INDUCTOR_VALUES_ = {154e-6, 1.54e-3, 15.4e-3, 154e-3, 1.54, 15.4, 100.0, 20e-6};//{2e-6, 154e-6, 1.54e-3, 15.4e-3, 154e-3, 1.54, 15.4, 100.0, 20e-6};

const bus_array__mcu S_BUSSES__MCU = {'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'}; //{'A', 'A', 'A', 'A', 'A', 'E', 'E', 'E', 'E'};

const bus_array__mcu A_BUSSES__MCU = {'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};//{'B', 'B', 'B', 'B', 'B', 'F', 'F', 'F', 'F'};

const bus_array__mcu B_BUSSES__MCU = {'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};//{'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G'};

const bus_array__mcu I_BUSSES__MCU = {'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};//{'D', 'D', 'D', 'D', 'D', 'H', 'H', 'H', 'H'};

const mux_array__mcu MUX_NODE_ARRAY__MCU = {3, 4, 5, 6, 2, 3, 4, 6};//{2, 3, 4, 5, 6, 2, 3, 4, 6};

//------------------------------------------------------------------------------

/* INDUCTOR STANDARD COMPONENTS TESTS */

void t9235(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int inductor_no;

  FILE *infile;

  std_component_array actual_value;

  double value[NUM_MEASUREMENTS];



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != RC_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Inductors Test requires a pin or channel", true);

      display_prompt("type card in Slot 4.  Test 9242 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 4 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.inductor_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.inductor_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &value[reading]);



		fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);

		fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_INDUCTORS; i++)

        {

          if ( number_equal(value[reading], INDUCTOR_VALUES_[i - 1]) )

            inductor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the Channel Virtual Card to be used for this subtest*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                   [S_BUSSES__MCU[inductor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                   [I_BUSSES__MCU[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                     [A_BUSSES__MCU[inductor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                     [B_BUSSES__MCU[inductor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */







        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_inductor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_inductor_result(mod_id);*/



		//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_inductor_result(mod_id);



//#####################################################################################







        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                  [S_BUSSES__MCU[inductor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES__MCU[inductor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                  [I_BUSSES__MCU[inductor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                    [A_BUSSES__MCU[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES__MCU[inductor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY__MCU[inductor_no - 1]]

                    [B_BUSSES__MCU[inductor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }  /* Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9235 */

#undef NUM_INDUCTORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef RC_FXT



#define NUM_COMPONENTS  2

#define NUM_MEASUREMENTS  2

#define PIN_SLOT        5

typedef double val_array___mcu[NUM_COMPONENTS];

typedef int bus_array___mcu[NUM_COMPONENTS];

typedef int mux_array___mcu[NUM_COMPONENTS];

const val_array___mcu COMPONENT_VALUES_MCU = {10e3, 100e3};

const bus_array___mcu I_BUSSES___MCU = {'A', 'A'};

const bus_array___mcu B_BUSSES___MCU = {'B', 'B'};

const bus_array___mcu A_BUSSES___MCU = {'C', 'C'};

const bus_array___mcu S_BUSSES___MCU = {'D', 'D'};

const bus_array___mcu L_BUSSES_MCU = {'E', 'E'};

const bus_array___mcu G_BUSSES_MCU = {'F', 'F'};

const mux_array___mcu EXTRA_B_BUS_MCU = {7, 8};

const mux_array___mcu MUX_NODE_ARRAY___MCU = {2, 3};

//------------------------------------------------------------------------------

/* RESISTOR STANDARD COMPONENTS DELTA NETWORKS */

void t9236(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int component_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];



  /*

  int src_freq[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double src_off[NUM_MEASUREMENTS];

  double src_wait[NUM_MEASUREMENTS];

  int src_comp[NUM_MEASUREMENTS];

  int en[NUM_MEASUREMENTS];

  int ed[NUM_MEASUREMENTS];

  int rf[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int wb[NUM_MEASUREMENTS];

  int hfs_cap[NUM_MEASUREMENTS];

  int diff_det[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  int src_type[NUM_MEASUREMENTS];

  int ser_mode[NUM_MEASUREMENTS];

  int comp_type[NUM_MEASUREMENTS];

  int dc_rej[NUM_MEASUREMENTS];

  */



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];



  test_result_type result;

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistor Deltas require a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9243 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.rdelta_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.rdelta_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



		/*

		fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &src_off[reading]);

        fscanf(infile, "%lg", &src_wait[reading]);

        fscanf(infile, "%d", &src_comp[reading]);

        fscanf(infile, "%d", &en[reading]);

        fscanf(infile, "%d", &ed[reading]);

        fscanf(infile, "%d", &rf[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &wb[reading]);

        fscanf(infile, "%d", &hfs_cap[reading]);

        fscanf(infile, "%d", &diff_det[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%d", &src_type[reading]);

        fscanf(infile, "%d", &ser_mode[reading]);

        fscanf(infile, "%d", &comp_type[reading]);

        fscanf(infile, "%d%*[^\n]", &dc_rej[reading]);

        */



		fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);





		getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {  /* FOR READING */

        for (i = 1; i <= NUM_COMPONENTS; i++)

        {

          if ( number_equal(nominal_value[reading], COMPONENT_VALUES_MCU[i - 1]) )

            component_no = i;

        }



       card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select all Channel Virtual Cards */

          virt_card_select(mod_id, PIN_SLOT, 3);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                   [S_BUSSES___MCU[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                   [I_BUSSES___MCU[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE G BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K752);

        vth_aclose_rly(mod_id, K814);

        vth_pclose_rly(mod_id, PIN_SLOT, KDCG);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KGL_RLYS[G_BUSSES_MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_DRVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                   [G_BUSSES_MCU[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id, AIM_X_A_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                     [A_BUSSES___MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id, AIM_X_B_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                     [B_BUSSES___MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* CONNECT THE L BUS */

          vth_aclose_rly(mod_id, AIM_X_L_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                     [L_BUSSES_MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE L BUS */





        /* CLOSE THE ADDITIONAL CONNECTION TO THE B BUS TO COMPLETE THE NETWORK */

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[EXTRA_B_BUS_MCU[component_no - 1]]

                   [B_BUSSES___MCU[component_no - 1] - 'A']);



        ////////////////////////////////////////////////////////

	//	vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

      //            src_wait[reading], src_comp[reading], en[reading],

      //          ed[reading], rf[reading], sa[reading], sb[reading],

      //        sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

      //      moa_out[reading], det_wait[reading]);



        /* The following section was removed.  The benefit was marginal and it is not

      //   how IPG would handle the test, ie. it's cheating. 5-24-91 BDB              */



        /*     if (component_no = 2) then

        //        begin

        //        vth_adet_sel_rng(mod_id,0) ;

        //        vth_adet_store_src_rng(mod_id,0) ;

        //        end ;

        */



        //vth_resistor_meas(mod_id, ser_mode[reading], dc_rej[reading]);

		////////////////////////////////////////////////////////



		//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

		vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_resistor_result(mod_id);



//#####################################################################################





          if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                  [S_BUSSES___MCU[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES___MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                  [I_BUSSES___MCU[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE G BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K752);

        vth_aopen_rly(mod_id, K814);

        vth_popen_rly(mod_id, PIN_SLOT, KDCG);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KGL_RLYS[G_BUSSES_MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_DRVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                  [G_BUSSES_MCU[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                    [A_BUSSES___MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES___MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                    [B_BUSSES___MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* DISCONNECT THE L BUS */

          vth_aopen_rly(mod_id, AIM_X_L_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[L_BUSSES_MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY___MCU[component_no - 1]]

                    [L_BUSSES_MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE L BUS */





        /* OPEN THE ADDITIONAL CONNECTION TO THE I BUS TO COMPLETE THE NETWORK */



        vth_popen_rly(mod_id, PIN_SLOT, PIN_RCVR_RLYS[EXTRA_B_BUS_MCU[component_no - 1]]

                  [B_BUSSES___MCU[component_no - 1] - 'A']);



      }  /* FOR READING */

    }  /* Do the test*/

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9236 */

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT







#define NUM_COMPONENTS  1

#define NUM_MEASUREMENTS  1

#define PIN_SLOT        5

typedef double val_array_____mcu[NUM_COMPONENTS];

typedef int bus_array_____mcu[NUM_COMPONENTS];

typedef int mux_array_____mcu[NUM_COMPONENTS];

const val_array_____mcu COMPONENT_VALUES__MCU = {10e-3};

const bus_array_____mcu I_BUSSES_____MCU = {'A'};

const bus_array_____mcu B_BUSSES_____MCU = {'B'};

const bus_array_____mcu A_BUSSES_____MCU = {'C'};

const bus_array_____mcu S_BUSSES_____MCU = {'D'};

const bus_array_____mcu L_BUSSES__MCU = {'E'};

const bus_array_____mcu G_BUSSES__MCU = {'F'};

const mux_array_____mcu EXTRA_B_BUS__MCU = {8};        /* virtual card #2 */

const mux_array_____mcu MUX_NODE_ARRAY_____MCU = {5};  /* virtual card #1 */

//------------------------------------------------------------------------------

/* INDUCTOR STANDARD COMPONENTS DELTA NETWORKS */

void t9237(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int component_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];



  test_result_type result;

  char buffer[81];

  infile = NULL;



  int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Inductor Delta requires a pin or channel", true);

      display_prompt("type card in Slot 5.  Test 9245 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.ldelta_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.ldelta_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



		fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);

		getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {  /* FOR READING */

        for (i = 1; i <= NUM_COMPONENTS; i++)

        {

          if ( number_equal(nominal_value[reading], COMPONENT_VALUES__MCU[i - 1]) )

            component_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                   [S_BUSSES_____MCU[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                   [I_BUSSES_____MCU[component_no - 1] - 'A']);



        /* ALWAYS CONNECT THE G BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, K752);

        vth_aclose_rly(mod_id, K814);

        vth_pclose_rly(mod_id, PIN_SLOT, KDCG);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KGL_RLYS[G_BUSSES__MCU[component_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_DRVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                   [G_BUSSES__MCU[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_A_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                     [A_BUSSES_____MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_B_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                     [B_BUSSES_____MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* CONNECT THE L BUS */

          vth_aclose_rly(mod_id, AIM_X_L_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                     [L_BUSSES__MCU[component_no - 1] - 'A']);

        }  /* CONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* CLOSE THE ADDITIONAL CONNECTION TO THE B BUS TO COMPLETE THE NETWORK */

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[EXTRA_B_BUS__MCU[component_no - 1]]

                   [B_BUSSES_____MCU[component_no - 1] - 'A']);



        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_inductor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_inductor_result(mod_id);*/





//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_capacitor_result(mod_id);



//#####################################################################################





        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #1*/

          virt_card_select(mod_id, PIN_SLOT, 1);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                  [S_BUSSES_____MCU[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_____MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                  [I_BUSSES_____MCU[component_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE G BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, K752);

        vth_aopen_rly(mod_id, K814);

        vth_popen_rly(mod_id, PIN_SLOT, KDCG);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KGL_RLYS[G_BUSSES__MCU[component_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_DRVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                  [G_BUSSES__MCU[component_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id, AIM_X_A_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                    [A_BUSSES_____MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */





        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id, AIM_X_B_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_____MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                    [B_BUSSES_____MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */





        if (sl[reading] == 1)

        {  /* DISCONNECT THE L BUS */

          vth_aopen_rly(mod_id, AIM_X_L_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[L_BUSSES__MCU[component_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_____MCU[component_no - 1]]

                    [L_BUSSES__MCU[component_no - 1] - 'A']);

        }  /* DISCONNECT THE L BUS */





        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select virtual card #2*/

          virt_card_select(mod_id, PIN_SLOT, 2);



        /* OPEN THE ADDITIONAL CONNECTION TO THE I BUS TO COMPLETE THE NETWORK */



        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[EXTRA_B_BUS__MCU[component_no - 1]]

                  [B_BUSSES_____MCU[component_no - 1] - 'A']);



      }  /* FOR READING */

    }  /* Do the test*/

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);



} /* t9237 */

#undef NUM_COMPONENTS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef RC_FXT



#define NUM_CAPACITORS  6

#define NUM_MEASUREMENTS  11

#define PIN_SLOT        3

#define DGN_INFINITY    1e31

typedef double val_array______mcu[NUM_CAPACITORS];

typedef int bus_array______mcu[NUM_CAPACITORS];

typedef int mux_array______mcu[NUM_CAPACITORS];

const val_array______mcu CAPACITOR_VALUES_MCU = {150.0e-009, 15.0e-009, 1.5e-009, 150.0e-012, 15.0e-012, 10.0e-012};

const bus_array______mcu S_BUSSES______MCU = {'A', 'E', 'E', 'E', 'E', 'E'};

const bus_array______mcu I_BUSSES______MCU = {'D', 'H', 'H', 'H', 'H', 'H'};

const mux_array______mcu MUX_NODE_ARRAY______MCU = {6, 2, 3, 4, 5, 6};

//------------------------------------------------------------------------------

// PIN STANDARD LOW VALUE CAPACITORS WITH COMPENSATION

void t9238(int mod_id, int /*slot*/)

{

  int next;

  double capacitor_reading;

  double compensation_reading;

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];

  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char s[MAX_S_LENGTH + 1];

  char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Caps Compensated Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 3.  Test 9246 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 3 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.compcap_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.compcap_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



	fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);

		fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES_MCU[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the appropriate virtual card*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);



        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);*/



       // vth_get_capacitor_result(mod_id);



		//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_capacitor_result(mod_id);



//#####################################################################################





        if (get_result_nolog(mod_id, &result))

          compensation_reading = result.UU.Real_result;

        else

        {  /* No result present */

          display_prompt("No result in result log (Expected component value)",

                         true);

          compensation_reading = 0.0;

        }  /* No result present */



        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______MCU[capacitor_no - 1]]

                   [S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY______MCU[capacitor_no - 1]]

                   [I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_mtmr_wait(mod_id, WAIT_TIME_FOR_RELAYS);







		/*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);*/



        //#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_capacitor_result(mod_id);



//#####################################################################################





        if (get_result_nolog(mod_id, &result))

          capacitor_reading = result.UU.Real_result;

        else

        {

          display_prompt("No result in result log (Expected comp value)", true);

          capacitor_reading = DGN_INFINITY - 1;

        }



        result.UU.Real_result = capacitor_reading - compensation_reading;

        result.UU.Real_result -= actual_value[reading];

        /* DEBUG */

        if (result.UU.Real_result > 1000)

        {

          sprintf(s, "%1.12f", compensation_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

          /* DEBUG */

          sprintf(s, "%1.12f", capacitor_reading);

          next = mtd_strlen(s) + 1;

          /* DEBUG */

          display_prompt(s, true);

          /* DEBUG */

        }

        log_result(mod_id, result);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______MCU[capacitor_no - 1]]

                  [S_BUSSES______MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY______MCU[capacitor_no - 1]]

                  [I_BUSSES______MCU[capacitor_no - 1] - 'A']);



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9238 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT

#undef DGN_INFINITY



#define NUM_CAPACITORS  2//3 >> cant test 10mf large cap using the NASRU MCU

#define NUM_MEASUREMENTS  2//3

#define PIN_SLOT        5

typedef double val_array_______mcu[NUM_CAPACITORS];

typedef int bus_array_______mcu[NUM_CAPACITORS];

typedef int mux_array_______mcu[NUM_CAPACITORS];

const val_array_______mcu CAPACITOR_VALUES__MCU = {1e-003, 100e-006};//{10e-003, 1e-003, 100e-006};

const bus_array_______mcu S_BUSSES_______MCU = {'H', 'H'};//{'H', 'H', 'H'};

const bus_array_______mcu A_BUSSES_______MCU = {'G', 'G'};//{'G', 'G', 'G'};

const bus_array_______mcu B_BUSSES_______MCU = {'F', 'F'};//{'F', 'F', 'F'};

const bus_array_______mcu I_BUSSES_______MCU = {'E', 'E'};//{'E', 'E', 'E'};

const mux_array_______mcu MUX_NODE_ARRAY_______MCU = {3, 2};//{6, 3, 2};

//------------------------------------------------------------------------------

/* CAPACITOR STANDARD COMPONENTS - LARGE VALUE */

void t9239(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS];



  int fb[NUM_MEASUREMENTS];

  int rc[NUM_MEASUREMENTS];

  int avr[NUM_MEASUREMENTS];

  int src_freq[NUM_MEASUREMENTS];

  int sa[NUM_MEASUREMENTS];

  int sb[NUM_MEASUREMENTS];

  int sl[NUM_MEASUREMENTS];

  int extra[NUM_MEASUREMENTS];

  double src_amp[NUM_MEASUREMENTS];

  double det_wait[NUM_MEASUREMENTS];

  double moa_out[NUM_MEASUREMENTS];

  double lo[NUM_MEASUREMENTS];

  double hi[NUM_MEASUREMENTS];

  int opp[NUM_MEASUREMENTS];

  int sm[NUM_MEASUREMENTS];

  int ac[NUM_MEASUREMENTS];



  int ssvirt_card[NUM_MEASUREMENTS];

  test_result_type result;

  char buffer[81];

  infile = NULL;





  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Large Value Caps Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 5.  Test 9247 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);



      sprintf(buffer, "%sstd.largecap_MCU", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.largecap_MCU' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

      {

        fscanf(infile, "%lg", &nominal_value[reading]);



		fscanf(infile, "%d", &fb[reading]);

        fscanf(infile, "%d", &rc[reading]);

        fscanf(infile, "%d", &avr[reading]);

        fscanf(infile, "%d", &src_freq[reading]);

        fscanf(infile, "%d", &sa[reading]);

        fscanf(infile, "%d", &sb[reading]);

        fscanf(infile, "%d", &sl[reading]);

        fscanf(infile, "%d", &extra[reading]);

        fscanf(infile, "%lg", &src_amp[reading]);

        fscanf(infile, "%lg", &det_wait[reading]);

        fscanf(infile, "%lg", &moa_out[reading]);

        fscanf(infile, "%lg", &lo[reading]);

        fscanf(infile, "%lg", &hi[reading]);

        fscanf(infile, "%d", &opp[reading]);

        fscanf(infile, "%d", &sm[reading]);

		fscanf(infile, "%d", &ac[reading]);

		fscanf(infile, "%d%*[^\n]", &ssvirt_card[reading]);

        getc(infile);



      }



      if (infile != NULL)

        fclose(infile);

      infile = NULL;



      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES__MCU[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else

        /*select the appropriate virtual card*/

          virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_S_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                   [S_BUSSES_______MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_I_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                   [I_BUSSES_______MCU[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* CONNECT THE A BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_A_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                     [A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE A BUS */



        if (sb[reading] == 1)

        {  /* CONNECT THE B BUS */

          vth_aclose_rly(mod_id,

                     AIM_X_B_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KDC_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_KX_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_pclose_rly(mod_id, PIN_SLOT,

                     PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                     [B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        }  /* CONNECT THE B BUS */



        /*vth_rlc_setup(mod_id, src_freq[reading], src_amp[reading], src_off[reading],

                  src_wait[reading], src_comp[reading], en[reading],

                  ed[reading], rf[reading], sa[reading], sb[reading],

                  sl[reading], wb[reading], hfs_cap[reading], diff_det[reading],

                  moa_out[reading], det_wait[reading]);



        vth_capacitor_meas(mod_id, ser_mode[reading], dc_rej[reading]);



        vth_get_capacitor_result(mod_id);*/





//#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function

        vth_set_dgn_use_mcu_flag(mod_id);

		vth_mcu_rlc_measure(mod_id, fb[reading], rc[reading], avr[reading], src_freq[reading], sa[reading],

			sb[reading], sl[reading],extra[reading], src_amp[reading], det_wait[reading], moa_out[reading],

			lo[reading], hi[reading], opp[reading], sm[reading], ac[reading]);



        //vth_get_capacitor_result(mod_id);



//#####################################################################################





        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected comp value)", true);



        vth_astat_rd(mod_id);

        if (!get_result_nolog(mod_id, &result))

          display_prompt("No result in result log (Expected aim stat)", true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                  [S_BUSSES_______MCU[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                  [I_BUSSES_______MCU[capacitor_no - 1] - 'A']);



        if (sa[reading] == 1)

        {  /* DISCONNECT THE A BUS */

          vth_aopen_rly(mod_id,

                    AIM_X_A_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                    [A_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE A BUS */



        if (sb[reading] == 1)

        {  /* DISCONNECT THE B BUS */

          vth_aopen_rly(mod_id,

                    AIM_X_B_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KDC_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_KX_RLYS[B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

          vth_popen_rly(mod_id, PIN_SLOT,

                    PIN_RCVR_RLYS[MUX_NODE_ARRAY_______MCU[capacitor_no - 1]]

                    [B_BUSSES_______MCU[capacitor_no - 1] - 'A']);

        }  /* DISCONNECT THE B BUS */



      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

}/* t9239 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT







// #############Below T9226 is developed for NASRU DC CAPS LARGE VALUE CAPS test at 10mF     #############



#define NUM_CAPACITORS  1

#define NUM_MEASUREMENTS  1

#define PIN_SLOT        5

typedef double val_array_______dc_caps[NUM_CAPACITORS];

typedef int bus_array_______dc_caps[NUM_CAPACITORS];

typedef int mux_array_______dc_caps[NUM_CAPACITORS];

const val_array_______dc_caps CAPACITOR_VALUES__DC_CAPS = {1e-003};//{10e-003, 1e-003, 100e-006};

const bus_array_______dc_caps S_BUSSES_______DC_CAPS = {'H'};//{'H', 'H', 'H'};

const bus_array_______dc_caps A_BUSSES_______DC_CAPS = {'G'};//{'G', 'G', 'G'};

const bus_array_______dc_caps B_BUSSES_______DC_CAPS = {'F'};//{'F', 'F', 'F'};

const bus_array_______dc_caps I_BUSSES_______DC_CAPS = {'E'};//{'E', 'E', 'E'};

const mux_array_______dc_caps MUX_NODE_ARRAY_______DC_CAPS = {3};//{6, 3, 2};

//------------------------------------------------------------------------------

/* CAPACITOR STANDARD COMPONENTS - DC CAPS MEASUREMENT METHOD LARGE VALUE */

void t9226(int mod_id, int /*slot*/)

{

  int reading;

  int i;

  int capacitor_no;

  FILE *infile;

  std_component_array actual_value;

  double nominal_value[NUM_MEASUREMENTS]={1e-003};



  int ssvirt_card[NUM_MEASUREMENTS]={2};

  test_result_type result;

  //char buffer[81];

  infile = NULL;



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))

    {  /*Display no pin card in pin_slot message*/

      display_prompt("Std Large Value Caps Test requires a pin or channel",

                     true);

      display_prompt("type card in Slot 5.  Test 9247 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else   /*Do the test*/

    {  /* After check for slot 5 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;

      load_fxt_specific_actual_values(mod_id, NUM_MEASUREMENTS, actual_value);





      for (reading = 0; reading < NUM_MEASUREMENTS; reading++)

          /* FOR READING */

          {  /* FOR READING */

        for (i = 1; i <= NUM_CAPACITORS; i++)

        {

          if ( number_equal(nominal_value[reading], CAPACITOR_VALUES__DC_CAPS[i - 1]) )

            capacitor_no = i;

        }



        card_type = get_testhead_actual_card(mod_id, PIN_SLOT);

        /* determine if card is caribou and put in compatibility mode */

        /* if not Caribou then select all Channel Virtual Cards */

        if ((card_type == CDDP) || (card_type == CDD20) ||

            (card_type == CDD6) || (card_type == CDDJB) ||

            (card_type == CDDU) || (card_type == VCDD2) ||

            (card_type == VFDD2))

          vth_pdis_32chan(mod_id, PIN_SLOT);

        else



         vth_ainit(mod_id);//init the ASRU card

		 /*select the appropriate virtual card*/

		 virt_card_select(mod_id, PIN_SLOT, ssvirt_card[reading]);



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_S_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______DC_CAPS[capacitor_no - 1]]

                   [S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);



        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        vth_aclose_rly(mod_id,

                   AIM_X_I_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KDC_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_KX_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_pclose_rly(mod_id, PIN_SLOT,

                   PIN_RCVR_RLYS[MUX_NODE_ARRAY_______DC_CAPS[capacitor_no - 1]]

                   [I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);





/*  Name   : dc_cap_setup
{  Author : Kathy Hird
{  Date   : 12-Mar-08
            05-Aug-08, Modified by Yue Zheng
{
{  Description:
        This routine uses the current mode
        parameter, Current, to calculate the source voltage and
        feedback resistor.  It also sets up the measurement path
        (MOA, detector and relays).
           mod_id : 0 - 3
           Current : 10 uAamps - 100 mAmps
           Interval : 25us - 31.2ms.  Interval between samples
           Enhance : 0 = unen, 1 = en
           Sense_a : 0 = nosa, 1 = sa
           Sense_b : 0 = nosb, 1 = sb
           Sense_l : 0 = nosl, 1 = sl
           Extra_digit : 0 = noed, 1 = ed
           Moa_vco : moa compliance voltage, 10.0 max
           Expected : expected diode voltage drop (real)
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


	    vth_dc_cap_set_sales_test_flag(mod_id);

		vth_dc_cap_setup(mod_id, 0.10000, 0.000046, 0, 0, 0, 0, 0, 3.000000, 1.500000);//Interval time set at 600us for 10mF
//ori 		vth_dc_cap_setup(mod_id, 0.100000, 0.000045, 0, 0, 0, 0, 0, 3.000000, 1.500000);//Interval time set at 600us for 10mF

		vth_dc_cap_meas(mod_id);

		vth_ra_dc_cap(mod_id, 0.015, 0.0095, 1, 0.100000, 0.000045);





        if (get_result_nolog(mod_id, &result))

        {  /* apply the actual to the reading to create a delta value */

          result.UU.Real_result -= actual_value[reading];

          log_result(mod_id, result);

        }  /* apply the actual to the reading to create a delta value */

        else

          display_prompt("No result in result log (Expected comp value)", true);





        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_S_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______DC_CAPS[capacitor_no - 1]]

                  [S_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);



        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        vth_aopen_rly(mod_id, AIM_X_I_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KDC_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_KX_RLYS[I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

        vth_popen_rly(mod_id, PIN_SLOT,

                  PIN_RCVR_RLYS[MUX_NODE_ARRAY_______DC_CAPS[capacitor_no - 1]]

                  [I_BUSSES_______DC_CAPS[capacitor_no - 1] - 'A']);

      }

    }

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

}/* t9226 */

#undef NUM_CAPACITORS

#undef NUM_MEASUREMENTS

#undef PIN_SLOT





///////////////////////////////END OF T9226//////////////////////////////////

#define PIN_SLOT        2

/* PIN STANDARD COMPONENTS RESISTOR MEASUREMENT */

void t9222(int mod_id, int /*slot*/)

{

  FILE *infile;     //  Richard Devore

  test_result_type result;

  infile = NULL;

  char buffer[81];



  if (get_fixture_id(mod_id) != INDUCTOR_FXT)

  { /* Bypass Loop */

    int card_type = get_testhead_actual_card(mod_id, PIN_SLOT);



    if ((card_type != CDDP) && (card_type != CDD20) &&

        (card_type != CDD6) && (card_type != CDDJB) &&

        (card_type != CDDU) && (card_type != PIN) &&

        (card_type != PIN6) && (card_type != PIN6JB) &&

        (card_type != PIN12JB) && (card_type != PINTERM) &&

        (card_type != PIN20) && (card_type != CP) &&

        (card_type != CP20) && (card_type != ANALOG) &&

        (card_type != DD6) && (card_type != DDJB) &&

        (card_type != DDP) && (card_type != DD20) &&

        (card_type != SD6) && (card_type != SDP) &&

        (card_type != DDA) && (card_type != FDD6) && (card_type != FDD6_H5) &&

        (card_type != FDDJB) && (card_type != FDDP) && (card_type != FDDP_H5) &&

        (card_type != FDD20) && (card_type != FDD20_H5) && (card_type != FDDA) &&

        (card_type != FDDU) && (card_type != VCDD2) &&

        (card_type != VFDD2))



    {  /*Display no pin card in pin_slot message*/

      display_prompt("Standard Resistors Test requires a pin or channel", true);

      display_prompt("type card in Slot 2.  Test 9247 will not be run!", true);

    }  /*Display no pin card in pin_slot message*/

    else

    {  /* Else After check for slot 2 pin card */

      present_slot[mod_id - NO_TESTHEAD_NUMBER] = PIN_SLOT;



      sprintf(buffer, "%sstd.resistor", testwhere_path);

	  infile = fopen(buffer, "r");



      if (infile == NULL)

      {

        display_prompt("The 'std.resistor' file was not found.  Please have sys admin replace.", true);

        _EscIO(FileNotFound);

      }



        /* ALWAYS CONNECT THE S BUS MEASUREMENT PATH */

        /* ALWAYS CONNECT THE I BUS MEASUREMENT PATH */

        /* CONNECT THE A BUS */

        /* CONNECT THE B BUS */

        /* SETUP TO DO THE AVERAGING OF THE RESULTS IN THE TESTHEAD AS OPPOSED */

        /* TO GETTING EACH INDIVIDUAL RESULT BACK. */



        vth_aclose_rly(mod_id,K733);

        vth_pclose_rly(mod_id, PIN_SLOT, KDC1);

        vth_pclose_rly(mod_id, PIN_SLOT, KX1);

        vth_pclose_rly(mod_id, PIN_SLOT, K16E);

        vth_aclose_rly(mod_id,K728) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC4);

        vth_pclose_rly(mod_id, PIN_SLOT, KX4);

        vth_pclose_rly(mod_id, PIN_SLOT, K16G);



        vth_aclose_rly(mod_id,K710) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC2);

        vth_pclose_rly(mod_id, PIN_SLOT, KX2);

        vth_pclose_rly(mod_id, PIN_SLOT, K16F);

        vth_aclose_rly(mod_id,K703) ;

        vth_pclose_rly(mod_id, PIN_SLOT, KDC3);

        vth_pclose_rly(mod_id, PIN_SLOT, KX3);

        vth_pclose_rly(mod_id, PIN_SLOT, K16H);

        vth_mra_in_mod(mod_id);





        /* vth_rlc_setup(mod_id, 1024, 1.0, 0.0, 0.0, 1, 0, 1, 5, 0, 0, 0, 1, 0, 0, 0.1, 0.0);

        vth_ameas_set_averaging(mod_id, 1);

        vth_capacitor_meas(mod_id, 1, 1);

        vth_get_capacitor_result(mod_id); */



        //#####################################################################################

//Below is the latest MCU LCR measure command, no need to do the init/setup but still need to call read result function



		vth_mcu_rlc_measure(mod_id, 1, 1, 1, 1, 1,

			1, 1,0, 0.1, 0.5, 0.1,

			0.2, 0.5, 0, 0, 0);



        vth_get_capacitor_result(mod_id);





		//#####################################################################################





        if (get_result_nolog(mod_id, &result))

        {

          log_result(mod_id, result);

        }

        else

          display_prompt("No result in result log (Expected component value)",

                         true);



        /* ALWAYS DISCONNECT THE S BUS MEASUREMENT PATH */

        /* ALWAYS DISCONNECT THE I BUS MEASUREMENT PATH */

        /* DISCONNECT THE A BUS */

        /* DISCONNECT THE B BUS */

        /* DISCONNECT THE B BUS */



        vth_aopen_rly(mod_id,K733) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC1);

        vth_popen_rly(mod_id, PIN_SLOT, KX1);

        vth_popen_rly(mod_id, PIN_SLOT, K16E);

        vth_aopen_rly(mod_id,K728) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC4);

        vth_popen_rly(mod_id, PIN_SLOT, KX4);

        vth_popen_rly(mod_id, PIN_SLOT, K16G);



        vth_aopen_rly(mod_id,K710) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC2);

        vth_popen_rly(mod_id, PIN_SLOT, KX2);

        vth_popen_rly(mod_id, PIN_SLOT, K16F);

        vth_aopen_rly(mod_id,K703) ;

        vth_popen_rly(mod_id, PIN_SLOT, KDC3);

        vth_popen_rly(mod_id, PIN_SLOT, KX3);

        vth_popen_rly(mod_id, PIN_SLOT, K16H);



    }  /* Else Do the test */

  } /* Bypass Loop */



  if (infile != NULL)

    fclose(infile);

} /* t9222 */

#undef PIN_SLOT



#define NUM_RESISTORS   9

#define NUM_MEASUREMENTS  22

#define PIN_SLOT        2

/* FOR 1M OHM RESISTOR ONLY */





//########################################end of new std. comp test added for NASRU############################//